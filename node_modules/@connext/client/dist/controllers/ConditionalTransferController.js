"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const hdnode_1 = require("ethers/utils/hdnode");
const lib_1 = require("../lib");
const crypto_1 = require("../lib/crypto");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class ConditionalTransferController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.conditionalTransfer = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Conditional transfer called with parameters: ${lib_1.stringify(params)}`);
            const res = yield this.conditionalExecutors[params.conditionType](params);
            return res;
        });
        this.handleLinkedTransferToRecipient = (params) => __awaiter(this, void 0, void 0, function* () {
            const { amount, assetId, paymentId, preImage, recipient } = types_1.convert.LinkedTransferToRecipient("bignumber", params);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBalance[this.connext.freeBalanceAddress];
            validation_1.validate(validation_1.notNegative(amount), validation_1.invalidAddress(assetId), validation_1.notLessThanOrEqualTo(amount, preTransferBal), validation_1.invalid32ByteHexString(paymentId), validation_1.invalid32ByteHexString(preImage), validation_1.invalidXpub(recipient));
            const linkedHash = lib_1.createLinkedHash(amount, assetId, paymentId, preImage);
            const ret = yield this.handleLinkedTransfers(Object.assign({}, params, { conditionType: "LINKED_TRANSFER" }));
            const recipientPublicKey = hdnode_1.fromExtendedKey(recipient).derivePath("0").publicKey;
            const encryptedPreImage = yield crypto_1.encryptWithPublicKey(recipientPublicKey.replace(/^0x/, ""), preImage);
            yield this.connext.setRecipientAndEncryptedPreImageForLinkedTransfer(recipient, encryptedPreImage, linkedHash);
            this.connext.messaging.publish(`transfer.send-async.${recipient}`, lib_1.stringify({
                amount: amount.toString(),
                assetId,
                encryptedPreImage,
                paymentId,
            }));
            yield this.connext.messaging.flush();
            return Object.assign({}, ret, { recipient });
        });
        this.handleLinkedTransfers = (params) => __awaiter(this, void 0, void 0, function* () {
            const { amount, assetId, paymentId, preImage, meta } = types_1.convert.LinkedTransfer("bignumber", params);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBalance[this.connext.freeBalanceAddress];
            validation_1.validate(validation_1.notNegative(amount), validation_1.invalidAddress(assetId), validation_1.notLessThanOrEqualTo(amount, preTransferBal), validation_1.invalid32ByteHexString(paymentId), validation_1.invalid32ByteHexString(preImage));
            const appInfo = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.SimpleLinkedTransferApp);
            const linkedHash = lib_1.createLinkedHash(amount, assetId, paymentId, preImage);
            const initialState = {
                amount,
                assetId,
                coinTransfers: [
                    {
                        amount,
                        to: lib_1.xpubToAddress(this.connext.publicIdentifier),
                    },
                    {
                        amount: constants_1.Zero,
                        to: lib_1.xpubToAddress(this.connext.nodePublicIdentifier),
                    },
                ],
                linkedHash,
                paymentId,
                preImage: constants_1.HashZero,
            };
            const appId = yield this.conditionalTransferAppInstalled(amount, assetId, initialState, appInfo, meta);
            if (!appId) {
                throw new Error(`App was not installed`);
            }
            return {
                freeBalance: yield this.connext.getFreeBalance(assetId),
                paymentId,
                preImage,
            };
        });
        this.conditionalTransferAppInstalled = (initiatorDeposit, assetId, initialState, appInfo, meta) => __awaiter(this, void 0, void 0, function* () {
            const { appDefinitionAddress: appDefinition, outcomeType, stateEncoding, actionEncoding, } = appInfo;
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit,
                initiatorDepositTokenAddress: assetId,
                meta,
                outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
            };
            const appId = yield this.proposeAndInstallLedgerApp(params);
            return appId;
        });
        this.conditionalExecutors = {
            LINKED_TRANSFER: this.handleLinkedTransfers,
            LINKED_TRANSFER_TO_RECIPIENT: this.handleLinkedTransferToRecipient,
        };
    }
}
exports.ConditionalTransferController = ConditionalTransferController;
//# sourceMappingURL=ConditionalTransferController.js.map