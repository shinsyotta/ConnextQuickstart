"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const src_1 = require("../../src");
const constants_2 = require("../../src/constants");
const types_1 = require("../../src/types");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const setup_1 = require("./setup");
const utils_1 = require("./utils");
expect.extend({ toBeLt: bignumber_jest_matcher_1.toBeLt });
const { TicTacToeApp } = global["networkContext"];
describe("Node method follows spec - install", () => {
    let multisigAddress;
    let nodeA;
    let nodeB;
    describe("Node A gets app install proposal, sends to node B, B approves it, installs it, " +
        "sends acks back to A, A installs it, both nodes have the same app instance", () => {
        beforeEach(async () => {
            const context = await setup_1.setup(global);
            nodeA = context["A"].node;
            nodeB = context["B"].node;
            multisigAddress = await utils_1.createChannel(nodeA, nodeB);
        });
        it("install app with ETH", async (done) => {
            await utils_1.collateralizeChannel(multisigAddress, nodeA, nodeB);
            let preInstallETHBalanceNodeA;
            let postInstallETHBalanceNodeA;
            let preInstallETHBalanceNodeB;
            let postInstallETHBalanceNodeB;
            let proposeInstallParams;
            nodeB.on(types_1.NODE_EVENTS.PROPOSE_INSTALL, async (msg) => {
                [
                    preInstallETHBalanceNodeA,
                    preInstallETHBalanceNodeB
                ] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
                utils_1.assertProposeMessage(nodeA.publicIdentifier, msg, proposeInstallParams);
                utils_1.makeInstallCall(nodeB, msg.data.appInstanceId);
            });
            nodeA.on(types_1.NODE_EVENTS.INSTALL, async (msg) => {
                const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
                const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
                expect(appInstanceNodeA).toBeDefined();
                expect(appInstanceNodeA).toEqual(appInstanceNodeB);
                const proposedAppsA = await utils_1.getProposedAppInstances(nodeA);
                expect(proposedAppsA.length).toBe(0);
                [
                    postInstallETHBalanceNodeA,
                    postInstallETHBalanceNodeB
                ] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
                expect(postInstallETHBalanceNodeA).toBeLt(preInstallETHBalanceNodeA);
                expect(postInstallETHBalanceNodeB).toBeLt(preInstallETHBalanceNodeB);
                utils_1.assertInstallMessage(nodeB.publicIdentifier, msg, appInstanceNodeA.identityHash);
                done();
            });
            const { params } = await utils_1.makeAndSendProposeCall(nodeA, nodeB, TicTacToeApp, undefined, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
            proposeInstallParams = params;
        });
        it("install app with ERC20", async (done) => {
            await utils_1.transferERC20Tokens(await nodeA.signerAddress());
            await utils_1.transferERC20Tokens(await nodeB.signerAddress());
            const erc20TokenAddress = global["networkContext"].DolphinCoin;
            await utils_1.collateralizeChannel(multisigAddress, nodeA, nodeB, constants_1.One, erc20TokenAddress);
            let preInstallERC20BalanceNodeA;
            let postInstallERC20BalanceNodeA;
            let preInstallERC20BalanceNodeB;
            let postInstallERC20BalanceNodeB;
            let proposedParams;
            nodeB.on(types_1.NODE_EVENTS.PROPOSE_INSTALL, async (msg) => {
                [
                    preInstallERC20BalanceNodeA,
                    preInstallERC20BalanceNodeB
                ] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, erc20TokenAddress);
                utils_1.assertProposeMessage(nodeA.publicIdentifier, msg, proposedParams);
                utils_1.makeInstallCall(nodeB, msg.data.appInstanceId);
            });
            nodeA.on(types_1.NODE_EVENTS.INSTALL, async (msg) => {
                const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
                const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
                expect(appInstanceNodeA).toEqual(appInstanceNodeB);
                [
                    postInstallERC20BalanceNodeA,
                    postInstallERC20BalanceNodeB
                ] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, erc20TokenAddress);
                expect(postInstallERC20BalanceNodeA).toBeLt(preInstallERC20BalanceNodeA);
                expect(postInstallERC20BalanceNodeB).toBeLt(preInstallERC20BalanceNodeB);
                utils_1.assertInstallMessage(nodeB.publicIdentifier, msg, appInstanceNodeA.identityHash);
                done();
            });
            const { params } = await utils_1.makeAndSendProposeCall(nodeA, nodeB, TicTacToeApp, undefined, constants_1.One, erc20TokenAddress, constants_1.One, erc20TokenAddress);
            proposedParams = params;
        });
        it("sends proposal with null initial state", async () => {
            const appContext = utils_1.getAppContext(TicTacToeApp);
            const appInstanceProposalReq = utils_1.constructAppProposalRpc(nodeB.publicIdentifier, appContext.appDefinition, appContext.abiEncodings, appContext.initialState);
            appInstanceProposalReq.parameters["initialState"] = undefined;
            await expect(nodeA.rpcRouter.dispatch(appInstanceProposalReq)).rejects.toThrowError(src_1.NULL_INITIAL_STATE_FOR_PROPOSAL);
        });
    });
});
//# sourceMappingURL=install.spec.js.map