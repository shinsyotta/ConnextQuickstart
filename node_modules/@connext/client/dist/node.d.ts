import { IMessagingService } from "@connext/messaging";
import { TransactionResponse } from "ethers/providers";
import { Transaction } from "ethers/utils";
import { ChannelProvider } from "./channelProvider";
import { Logger } from "./lib";
import { AppRegistry, CFCoreTypes, ChannelAppSequences, CreateChannelResponse, GetChannelResponse, GetConfigResponse, NodeInitializationParameters, PaymentProfile, RequestCollateralResponse, SupportedApplication, SupportedNetwork, Transfer } from "./types";
export interface INodeApiClient {
    acquireLock(lockName: string, callback: (...args: any[]) => any, timeout: number): Promise<any>;
    addPaymentProfile(profile: PaymentProfile): Promise<PaymentProfile>;
    appRegistry(appDetails?: {
        name: SupportedApplication;
        network: SupportedNetwork;
    }): Promise<AppRegistry>;
    config(): Promise<GetConfigResponse>;
    createChannel(): Promise<CreateChannelResponse>;
    getChannel(): Promise<GetChannelResponse>;
    getLatestSwapRate(from: string, to: string): Promise<string>;
    getPaymentProfile(assetId?: string): Promise<PaymentProfile>;
    getTransferHistory(publicIdentifier: string): Promise<Transfer[]>;
    requestCollateral(assetId: string): Promise<RequestCollateralResponse | void>;
    withdraw(tx: CFCoreTypes.MinimalTransaction): Promise<TransactionResponse>;
    fetchLinkedTransfer(paymentId: string): Promise<any>;
    resolveLinkedTransfer(paymentId: string, preImage: string, recipientPublicIdentifier?: string): Promise<void>;
    recipientOnline(recipientPublicIdentifier: string): Promise<boolean>;
    restoreState(publicIdentifier: string): Promise<any>;
    subscribeToSwapRates(from: string, to: string, callback: any): void;
    unsubscribeFromSwapRates(from: string, to: string): void;
    verifyAppSequenceNumber(appSequenceNumber: number): Promise<ChannelAppSequences>;
}
export declare class NodeApiClient implements INodeApiClient {
    messaging: IMessagingService;
    latestSwapRates: {
        [key: string]: string;
    };
    log: Logger;
    private _userPublicIdentifier;
    private _nodePublicIdentifier;
    private _channelProvider;
    constructor(opts: NodeInitializationParameters);
    channelProvider: ChannelProvider | undefined;
    userPublicIdentifier: string | undefined;
    nodePublicIdentifier: string | undefined;
    acquireLock(lockName: string, callback: (...args: any[]) => any, timeout: number): Promise<any>;
    appRegistry(appDetails?: {
        name: SupportedApplication;
        network: SupportedNetwork;
    }): Promise<AppRegistry>;
    config(): Promise<GetConfigResponse>;
    createChannel(): Promise<CreateChannelResponse>;
    getChannel(): Promise<GetChannelResponse>;
    getPendingAsyncTransfers(): Promise<{
        assetId: string;
        amount: string;
        encryptedPreImage: string;
        linkedHash: string;
        paymentId: string;
    }[]>;
    getLatestSwapRate(from: string, to: string): Promise<string>;
    getTransferHistory(): Promise<Transfer[]>;
    requestCollateral(assetId: string): Promise<RequestCollateralResponse | void>;
    withdraw(tx: CFCoreTypes.MinimalTransaction): Promise<TransactionResponse>;
    fetchLinkedTransfer(paymentId: string): Promise<any>;
    resolveLinkedTransfer(paymentId: string, preImage: string, recipientPublicIdentifier?: string): Promise<void>;
    addPaymentProfile(profile: PaymentProfile): Promise<PaymentProfile>;
    getPaymentProfile(assetId?: string): Promise<PaymentProfile>;
    setRecipientAndEncryptedPreImageForLinkedTransfer(recipientPublicIdentifier: string, encryptedPreImage: string, linkedHash: string): Promise<any>;
    verifyAppSequenceNumber(appSequenceNumber: number): Promise<ChannelAppSequences>;
    recipientOnline: (recipientPublicIdentifier: string) => Promise<boolean>;
    setUserPublicIdentifier(publicIdentifier: string): void;
    setNodePublicIdentifier(publicIdentifier: string): void;
    subscribeToSwapRates(from: string, to: string, callback: any): Promise<void>;
    unsubscribeFromSwapRates(from: string, to: string): Promise<void>;
    restoreState(publicIdentifier: string): Promise<any>;
    getLatestWithdrawal(): Promise<Transaction>;
    private getAuthToken;
    private send;
    private sendAttempt;
}
//# sourceMappingURL=node.d.ts.map