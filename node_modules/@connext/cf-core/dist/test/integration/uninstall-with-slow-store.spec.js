"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../src/types");
const utils_1 = require("../../src/utils");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
const { TicTacToeApp } = global["networkContext"];
describe("Node method follows spec - uninstall", () => {
    let nodeA;
    let nodeB;
    beforeAll(async () => {
        const context = await setup_1.setupWithMemoryMessagingAndSlowStore(global);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
    });
    describe("Node A and B install TTT, then uninstall it", () => {
        it("sends proposal with non-null initial state", async (done) => {
            const initialState = {
                versionNumber: 0,
                winner: 1,
                board: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
            };
            await utils_2.createChannel(nodeA, nodeB);
            await utils_1.timeout(2000);
            const [appInstanceId] = await utils_2.installApp(nodeA, nodeB, TicTacToeApp, initialState);
            nodeB.once(types_1.NODE_EVENTS.UNINSTALL, async (msg) => {
                expect(msg.data.appInstanceId).toBe(appInstanceId);
                await utils_1.timeout(1000);
                expect(await utils_2.getInstalledAppInstances(nodeB)).toEqual([]);
                done();
            });
            await nodeA.rpcRouter.dispatch(utils_2.constructUninstallRpc(appInstanceId));
            expect(await utils_2.getInstalledAppInstances(nodeA)).toEqual([]);
        });
    });
});
//# sourceMappingURL=uninstall-with-slow-store.spec.js.map