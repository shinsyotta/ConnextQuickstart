"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../../src/constants");
const contracts_1 = require("../../contracts");
const ethereum_1 = require("../../../src/ethereum");
const machine_1 = require("../../../src/machine");
const models_1 = require("../../../src/models");
const free_balance_1 = require("../../../src/models/free-balance");
const utils_2 = require("../../../src/utils");
const bignumber_jest_matcher_1 = require("./bignumber-jest-matcher");
const connect_ganache_1 = require("./connect-ganache");
const random_signing_keys_1 = require("./random-signing-keys");
const CREATE_PROXY_AND_SETUP_GAS = 6e9;
const SETUP_COMMITMENT_GAS = 6e9;
const SETSTATE_COMMITMENT_GAS = 6e9;
let provider;
let wallet;
let network;
let appRegistry;
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
jest.setTimeout(10000);
beforeAll(async () => {
    [provider, wallet, {}] = await connect_ganache_1.connectToGanache();
    network = global["networkContext"];
    appRegistry = new ethers_1.Contract(network.ChallengeRegistry, contracts_1.ChallengeRegistry.abi, wallet);
});
describe("Scenario: Setup, set state on free balance, go on chain", () => {
    it("should distribute funds in ETH free balance when put on chain", async (done) => {
        const xprvs = random_signing_keys_1.getRandomExtendedPrvKeys(2);
        const multisigOwnerKeys = machine_1.xkeysToSortedKthSigningKeys(xprvs, 0);
        const proxyFactory = new ethers_1.Contract(network.ProxyFactory, contracts_1.ProxyFactory.abi, wallet);
        proxyFactory.once("ProxyCreation", async (proxy) => {
            expect(proxy).toBe(await utils_2.getCreate2MultisigAddress(xprvs, network.ProxyFactory, network.MinimumViableMultisig, provider));
            const stateChannel = models_1.StateChannel.setupChannel(network.IdentityApp, network.ProxyFactory, proxy, xprvs.map(random_signing_keys_1.extendedPrvKeyToExtendedPubKey), 1).setFreeBalance(free_balance_1.FreeBalanceClass.createWithFundedTokenAmounts(multisigOwnerKeys.map(key => key.address), constants_1.WeiPerEther, [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]));
            const freeBalance = stateChannel.freeBalance;
            const setStateCommitment = new ethereum_1.SetStateCommitment(network, freeBalance.identity, utils_1.keccak256(freeBalance.encodedLatestState), freeBalance.versionNumber, freeBalance.timeout);
            const setStateTx = setStateCommitment.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(setStateCommitment.hashToSign()),
                multisigOwnerKeys[1].signDigest(setStateCommitment.hashToSign())
            ]);
            await wallet.sendTransaction(Object.assign({}, setStateTx, { gasLimit: SETSTATE_COMMITMENT_GAS }));
            for (const _ of Array(freeBalance.timeout)) {
                await provider.send("evm_mine", []);
            }
            await appRegistry.functions.setOutcome(freeBalance.identity, freeBalance.encodedLatestState);
            const setupCommitment = new ethereum_1.SetupCommitment(network, stateChannel.multisigAddress, stateChannel.multisigOwners, stateChannel.freeBalance.identity);
            const setupTx = setupCommitment.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(setupCommitment.hashToSign()),
                multisigOwnerKeys[1].signDigest(setupCommitment.hashToSign())
            ]);
            await wallet.sendTransaction({ to: proxy, value: constants_1.WeiPerEther.mul(2) });
            await wallet.sendTransaction(Object.assign({}, setupTx, { gasLimit: SETUP_COMMITMENT_GAS }));
            expect(await provider.getBalance(proxy)).toBeEq(constants_1.Zero);
            expect(await provider.getBalance(multisigOwnerKeys[0].address)).toBeEq(constants_1.WeiPerEther);
            expect(await provider.getBalance(multisigOwnerKeys[1].address)).toBeEq(constants_1.WeiPerEther);
            done();
        });
        await proxyFactory.functions.createProxyWithNonce(network.MinimumViableMultisig, new utils_1.Interface(contracts_1.MinimumViableMultisig.abi).functions.setup.encode([
            multisigOwnerKeys.map(x => x.address)
        ]), 0, { gasLimit: CREATE_PROXY_AND_SETUP_GAS });
    });
});
//# sourceMappingURL=setup-then-set-state.spec.js.map