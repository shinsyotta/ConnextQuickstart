"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const utils_1 = require("ethers/utils");
const src_1 = require("../../src");
const constants_2 = require("../../src/constants");
const contracts_1 = require("../contracts");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq, toBeLt: bignumber_jest_matcher_1.toBeLt });
function confirmWithdrawalMessages(initiator, responder, params) {
    initiator.once(src_1.NODE_EVENTS.WITHDRAWAL_CONFIRMED, (msg) => {
        utils_2.assertNodeMessage(msg, {
            from: initiator.publicIdentifier,
            type: src_1.NODE_EVENTS.WITHDRAWAL_CONFIRMED,
            data: {
                txReceipt: {
                    from: initiator.freeBalanceAddress,
                    to: params.multisigAddress
                }
            }
        }, [
            "data.txReceipt.blockHash",
            "data.txReceipt.blockNumber",
            "data.txReceipt.byzantium",
            "data.txReceipt.confirmations",
            "data.txReceipt.contractAddress",
            "data.txReceipt.cumulativeGasUsed",
            "data.txReceipt.gasUsed",
            "data.txReceipt.logs",
            "data.txReceipt.logsBloom",
            "data.txReceipt.status",
            "data.txReceipt.transactionHash",
            "data.txReceipt.transactionIndex"
        ]);
    });
    const startedMsg = {
        from: initiator.publicIdentifier,
        type: src_1.NODE_EVENTS.WITHDRAWAL_STARTED,
        data: { params }
    };
    initiator.once(src_1.NODE_EVENTS.WITHDRAWAL_STARTED, (msg) => {
        utils_2.assertNodeMessage(msg, startedMsg, ["data.txHash"]);
    });
    responder.once(src_1.NODE_EVENTS.WITHDRAWAL_STARTED, (msg) => {
        utils_2.assertNodeMessage(msg, startedMsg);
    });
}
describe("Node method follows spec - withdraw", () => {
    let nodeA;
    let nodeB;
    let provider;
    let multisigAddress;
    beforeEach(async () => {
        const context = await setup_1.setup(global);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
        multisigAddress = await utils_2.createChannel(nodeA, nodeB);
        expect(multisigAddress).toBeDefined();
        const txHash = await utils_2.deployStateDepositHolder(nodeA, multisigAddress);
        expect(txHash).toBeDefined();
        nodeB.on(src_1.NODE_EVENTS.DEPOSIT_CONFIRMED, () => { });
    });
    it("has the right balance for both parties after withdrawal", async () => {
        const startingMultisigBalance = await provider.getBalance(multisigAddress);
        await utils_2.deposit(nodeA, multisigAddress, constants_1.One, nodeB);
        const postDepositMultisigBalance = await provider.getBalance(multisigAddress);
        expect(postDepositMultisigBalance).toBeEq(startingMultisigBalance.add(constants_1.One));
        const recipient = utils_1.getAddress(utils_1.hexlify(crypto_1.randomBytes(20)));
        expect(await provider.getBalance(recipient)).toBeEq(constants_1.Zero);
        const withdrawReq = utils_2.constructWithdrawRpc(multisigAddress, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, recipient);
        confirmWithdrawalMessages(nodeA, nodeB, withdrawReq.parameters);
        const { result: { result: { txHash } } } = await nodeA.rpcRouter.dispatch(withdrawReq);
        expect(txHash).toBeDefined();
        expect(txHash.length).toBe(66);
        expect(txHash.substr(0, 2)).toBe("0x");
        expect(await provider.getBalance(multisigAddress)).toBeEq(startingMultisigBalance);
        expect(await provider.getBalance(recipient)).toBeEq(constants_1.One);
    });
    it("has the right balance for both parties after withdrawal of ERC20 tokens", async () => {
        const erc20ContractAddress = global["networkContext"].DolphinCoin;
        const erc20Contract = new ethers_1.Contract(erc20ContractAddress, contracts_1.DolphinCoin.abi, new providers_1.JsonRpcProvider(global["ganacheURL"]));
        expect(multisigAddress).toBeDefined();
        await utils_2.transferERC20Tokens(await nodeA.signerAddress());
        const startingMultisigTokenBalance = await erc20Contract.functions.balanceOf(multisigAddress);
        await utils_2.deposit(nodeA, multisigAddress, constants_1.One, nodeB, erc20ContractAddress);
        const postDepositMultisigTokenBalance = await erc20Contract.functions.balanceOf(multisigAddress);
        expect(postDepositMultisigTokenBalance).toBeEq(startingMultisigTokenBalance.add(constants_1.One));
        const recipient = utils_1.getAddress(utils_1.hexlify(crypto_1.randomBytes(20)));
        expect(await erc20Contract.functions.balanceOf(recipient)).toBeEq(constants_1.Zero);
        const withdrawReq = utils_2.constructWithdrawRpc(multisigAddress, constants_1.One, erc20ContractAddress, recipient);
        confirmWithdrawalMessages(nodeA, nodeB, withdrawReq.parameters);
        await nodeA.rpcRouter.dispatch(withdrawReq);
        expect(await erc20Contract.functions.balanceOf(multisigAddress)).toBeEq(startingMultisigTokenBalance);
        expect(await erc20Contract.functions.balanceOf(recipient)).toBeEq(constants_1.One);
    });
    it("Node A produces a withdraw commitment and non-Node A submits the commitment to the network", async () => {
        const startingMultisigBalance = await provider.getBalance(multisigAddress);
        await utils_2.deposit(nodeA, multisigAddress, constants_1.One, nodeB);
        const postDepositMultisigBalance = await provider.getBalance(multisigAddress);
        const getFreeBalance = async (node) => {
            return utils_2.getFreeBalanceState(node, multisigAddress, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
        };
        expect(await getFreeBalance(nodeA)).toEqual(await getFreeBalance(nodeB));
        expect(postDepositMultisigBalance).toBeEq(startingMultisigBalance.add(constants_1.One));
        const recipient = utils_1.getAddress(utils_1.hexlify(crypto_1.randomBytes(20)));
        expect(await provider.getBalance(recipient)).toBeEq(constants_1.Zero);
        const withdrawCommitmentReq = utils_2.constructWithdrawCommitmentRpc(multisigAddress, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, recipient);
        confirmWithdrawalMessages(nodeA, nodeB, withdrawCommitmentReq.parameters);
        const { result: { result: { transaction } } } = await nodeA.rpcRouter.dispatch(withdrawCommitmentReq);
        expect(transaction).toBeDefined();
        const externalFundedAccount = new ethers_1.Wallet(global["fundedPrivateKey"], provider);
        const externalAccountPreTxBalance = await provider.getBalance(externalFundedAccount.address);
        const nodeAPreTxBalance = await provider.getBalance(nodeA.signerAddress());
        expect(await getFreeBalance(nodeA)).toEqual(await getFreeBalance(nodeB));
        await externalFundedAccount.sendTransaction(transaction);
        const externalAccountPostTxBalance = await provider.getBalance(externalFundedAccount.address);
        const nodeAPostTxBalance = await provider.getBalance(nodeA.signerAddress());
        expect(externalAccountPostTxBalance).toBeLt(externalAccountPreTxBalance);
        expect(nodeAPreTxBalance).toBeEq(nodeAPostTxBalance);
        expect(await provider.getBalance(multisigAddress)).toBeEq(startingMultisigBalance);
        expect(await provider.getBalance(recipient)).toBeEq(constants_1.One);
    });
});
//# sourceMappingURL=secure-withdraw.spec.js.map