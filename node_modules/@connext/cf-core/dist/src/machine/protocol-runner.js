"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = __importDefault(require("uuid"));
const protocol_1 = require("../protocol");
const enums_1 = require("./enums");
const middleware_1 = require("./middleware");
function firstRecipientFromProtocolName(protocolName) {
    if ([enums_1.Protocol.UninstallVirtualApp, enums_1.Protocol.InstallVirtualApp].indexOf(protocolName) !== -1) {
        return "intermediaryXpub";
    }
    if ([
        enums_1.Protocol.Update,
        enums_1.Protocol.Uninstall,
        enums_1.Protocol.TakeAction,
        enums_1.Protocol.Install,
        enums_1.Protocol.Withdraw,
        enums_1.Protocol.Propose
    ].indexOf(protocolName) !== -1) {
        return "responderXpub";
    }
    throw Error(`Unknown protocolName ${protocolName} passed to firstRecipientFromProtocolName`);
}
class ProtocolRunner {
    constructor(network, provider) {
        this.network = network;
        this.provider = provider;
        this.network.provider = network.provider || provider;
        this.middlewares = new middleware_1.MiddlewareContainer();
    }
    register(scope, method) {
        this.middlewares.add(scope, method);
    }
    async runProtocolWithMessage(msg, sc) {
        const protocol = protocol_1.getProtocolFromName(msg.protocol);
        const step = protocol[msg.seq];
        if (step === undefined) {
            throw Error(`Received invalid seq ${msg.seq} for protocol ${msg.protocol}`);
        }
        return this.runProtocol(sc, step, msg);
    }
    async initiateProtocol(protocolName, sc, params) {
        return this.runProtocol(sc, protocol_1.getProtocolFromName(protocolName)[0], {
            params,
            protocol: protocolName,
            processID: uuid_1.default.v1(),
            seq: 0,
            toXpub: params[firstRecipientFromProtocolName(protocolName)],
            customData: {}
        });
    }
    async runSetupProtocol(params) {
        const protocol = enums_1.Protocol.Setup;
        return this.runProtocol(new Map(), protocol_1.getProtocolFromName(protocol)[0], {
            protocol,
            params,
            processID: uuid_1.default.v1(),
            seq: 0,
            toXpub: params.responderXpub,
            customData: {}
        });
    }
    async runProtocol(stateChannelsMap, instruction, message) {
        const context = {
            message,
            stateChannelsMap,
            network: this.network,
            provider: this.provider
        };
        let lastMiddlewareRet = undefined;
        const process = instruction(context);
        while (true) {
            const ret = await process.next(lastMiddlewareRet);
            if (ret.done) {
                break;
            }
            const [opcode, ...args] = ret.value;
            lastMiddlewareRet = await this.middlewares.run(opcode, args);
        }
        return context.stateChannelsMap;
    }
}
exports.ProtocolRunner = ProtocolRunner;
//# sourceMappingURL=protocol-runner.js.map