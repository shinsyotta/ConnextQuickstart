"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const ethereum_1 = require("../ethereum");
const conditional_transaction_commitment_1 = require("../ethereum/conditional-transaction-commitment");
const enums_1 = require("../machine/enums");
const errors_1 = require("../methods/errors");
const models_1 = require("../models");
const types_1 = require("../types");
const signature_forwarder_1 = require("./utils/signature-forwarder");
const signature_validator_1 = require("./utils/signature-validator");
const { OP_SIGN, IO_SEND, IO_SEND_AND_WAIT, WRITE_COMMITMENT, PERSIST_STATE_CHANNEL } = enums_1.Opcode;
const { Update, Install } = enums_1.Protocol;
exports.INSTALL_PROTOCOL = {
    0: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { stateChannelsMap, message: { params, processID }, network } = context;
            const { responderXpub, multisigAddress } = params;
            const preProtocolStateChannel = stateChannelsMap.get(multisigAddress);
            const postProtocolStateChannel = computeStateChannelTransition(preProtocolStateChannel, params);
            const newAppInstance = postProtocolStateChannel.mostRecentlyInstalledAppInstance();
            const conditionalTransactionData = constructConditionalTransactionData(network, postProtocolStateChannel);
            const mySignatureOnConditionalTransaction = yield yield __await([
                OP_SIGN,
                conditionalTransactionData
            ]);
            const { customData: { signature: counterpartySignatureOnConditionalTransaction, signature2: counterpartySignatureOnFreeBalanceStateUpdate } } = yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    params,
                    protocol: Install,
                    toXpub: responderXpub,
                    customData: {
                        signature: mySignatureOnConditionalTransaction
                    },
                    seq: 1
                }
            ]);
            signature_validator_1.assertIsValidSignature(preProtocolStateChannel.getFreeBalanceAddrOf(responderXpub), conditionalTransactionData, counterpartySignatureOnConditionalTransaction);
            const signedConditionalTransaction = conditionalTransactionData.getSignedTransaction([
                mySignatureOnConditionalTransaction,
                counterpartySignatureOnConditionalTransaction
            ]);
            context.stateChannelsMap.set(postProtocolStateChannel.multisigAddress, postProtocolStateChannel);
            yield yield __await([
                WRITE_COMMITMENT,
                Install,
                signedConditionalTransaction,
                newAppInstance.identityHash
            ]);
            const freeBalanceUpdateData = new ethereum_1.SetStateCommitment(network, postProtocolStateChannel.freeBalance.identity, postProtocolStateChannel.freeBalance.hashOfLatestState, postProtocolStateChannel.freeBalance.versionNumber, postProtocolStateChannel.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(preProtocolStateChannel.getFreeBalanceAddrOf(responderXpub), freeBalanceUpdateData, counterpartySignatureOnFreeBalanceStateUpdate);
            const mySignatureOnFreeBalanceStateUpdate = yield yield __await([
                OP_SIGN,
                freeBalanceUpdateData
            ]);
            const signedFreeBalanceStateUpdate = freeBalanceUpdateData.getSignedTransaction([
                mySignatureOnFreeBalanceStateUpdate,
                counterpartySignatureOnFreeBalanceStateUpdate
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Update,
                signedFreeBalanceStateUpdate,
                postProtocolStateChannel.freeBalance.identityHash
            ]);
            yield yield __await([PERSIST_STATE_CHANNEL, [postProtocolStateChannel]]);
            yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    protocol: Install,
                    toXpub: responderXpub,
                    customData: {
                        signature: mySignatureOnFreeBalanceStateUpdate
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
        });
    },
    1: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { stateChannelsMap, message: { params, processID, customData: { signature } }, network } = context;
            const counterpartySignatureOnConditionalTransaction = signature;
            const { initiatorXpub, multisigAddress } = params;
            const preProtocolStateChannel = stateChannelsMap.get(multisigAddress);
            const postProtocolStateChannel = computeStateChannelTransition(preProtocolStateChannel, params);
            const newAppInstance = postProtocolStateChannel.mostRecentlyInstalledAppInstance();
            const conditionalTransactionData = constructConditionalTransactionData(network, postProtocolStateChannel);
            signature_validator_1.assertIsValidSignature(preProtocolStateChannel.getFreeBalanceAddrOf(initiatorXpub), conditionalTransactionData, counterpartySignatureOnConditionalTransaction);
            const mySignatureOnConditionalTransaction = yield yield __await([
                OP_SIGN,
                conditionalTransactionData
            ]);
            const signedConditionalTransaction = conditionalTransactionData.getSignedTransaction([
                mySignatureOnConditionalTransaction,
                counterpartySignatureOnConditionalTransaction
            ]);
            context.stateChannelsMap.set(postProtocolStateChannel.multisigAddress, postProtocolStateChannel);
            yield yield __await([
                WRITE_COMMITMENT,
                Install,
                signedConditionalTransaction,
                newAppInstance.identityHash
            ]);
            const freeBalanceUpdateData = new ethereum_1.SetStateCommitment(network, postProtocolStateChannel.freeBalance.identity, postProtocolStateChannel.freeBalance.hashOfLatestState, postProtocolStateChannel.freeBalance.versionNumber, postProtocolStateChannel.freeBalance.timeout);
            const mySignatureOnFreeBalanceStateUpdate = yield yield __await([
                OP_SIGN,
                freeBalanceUpdateData
            ]);
            const { customData: { signature: counterpartySignatureOnFreeBalanceStateUpdate } } = yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    protocol: Install,
                    toXpub: initiatorXpub,
                    customData: {
                        signature: mySignatureOnConditionalTransaction,
                        signature2: mySignatureOnFreeBalanceStateUpdate
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
            signature_validator_1.assertIsValidSignature(preProtocolStateChannel.getFreeBalanceAddrOf(initiatorXpub), freeBalanceUpdateData, counterpartySignatureOnFreeBalanceStateUpdate);
            const signedFreeBalanceStateUpdate = freeBalanceUpdateData.getSignedTransaction([
                mySignatureOnFreeBalanceStateUpdate,
                counterpartySignatureOnFreeBalanceStateUpdate
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Update,
                signedFreeBalanceStateUpdate,
                postProtocolStateChannel.freeBalance.identityHash
            ]);
            yield yield __await([PERSIST_STATE_CHANNEL, [postProtocolStateChannel]]);
            const m4 = {
                processID,
                protocol: Install,
                toXpub: initiatorXpub,
                customData: {
                    dataPersisted: true
                },
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
            };
            yield yield __await([IO_SEND, m4]);
        });
    }
};
function computeStateChannelTransition(stateChannel, params) {
    const { initiatorBalanceDecrement, responderBalanceDecrement, initiatorDepositTokenAddress, responderDepositTokenAddress, initiatorXpub, responderXpub, participants, initialState, appInterface, defaultTimeout, appSeqNo, outcomeType, disableLimit } = params;
    const initiatorFbAddress = stateChannel.getFreeBalanceAddrOf(initiatorXpub);
    const responderFbAddress = stateChannel.getFreeBalanceAddrOf(responderXpub);
    const { multiAssetMultiPartyCoinTransferInterpreterParams, twoPartyOutcomeInterpreterParams, singleAssetTwoPartyCoinTransferInterpreterParams } = computeInterpreterParameters(outcomeType, initiatorDepositTokenAddress, responderDepositTokenAddress, initiatorBalanceDecrement, responderBalanceDecrement, initiatorFbAddress, responderFbAddress, disableLimit);
    const appInstanceToBeInstalled = new models_1.AppInstance(participants, defaultTimeout, appInterface, false, appSeqNo, initialState, 0, defaultTimeout, outcomeType, twoPartyOutcomeInterpreterParams, multiAssetMultiPartyCoinTransferInterpreterParams, singleAssetTwoPartyCoinTransferInterpreterParams);
    let tokenIndexedBalanceDecrement;
    if (initiatorDepositTokenAddress !== responderDepositTokenAddress) {
        tokenIndexedBalanceDecrement = {
            [initiatorDepositTokenAddress]: {
                [initiatorFbAddress]: initiatorBalanceDecrement
            },
            [responderDepositTokenAddress]: {
                [responderFbAddress]: responderBalanceDecrement
            }
        };
    }
    else {
        tokenIndexedBalanceDecrement = {
            [initiatorDepositTokenAddress]: {
                [initiatorFbAddress]: initiatorBalanceDecrement,
                [responderFbAddress]: responderBalanceDecrement
            }
        };
    }
    return stateChannel.installApp(appInstanceToBeInstalled, tokenIndexedBalanceDecrement);
}
function computeInterpreterParameters(outcomeType, initiatorDepositTokenAddress, responderDepositTokenAddress, initiatorBalanceDecrement, responderBalanceDecrement, initiatorFbAddress, responderFbAddress, disableLimit) {
    switch (outcomeType) {
        case types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME: {
            if (initiatorDepositTokenAddress !== responderDepositTokenAddress) {
                throw Error(errors_1.TWO_PARTY_OUTCOME_DIFFERENT_ASSETS(initiatorDepositTokenAddress, responderDepositTokenAddress));
            }
            return {
                twoPartyOutcomeInterpreterParams: {
                    tokenAddress: initiatorDepositTokenAddress,
                    playerAddrs: [initiatorFbAddress, responderFbAddress],
                    amount: initiatorBalanceDecrement.add(responderBalanceDecrement)
                }
            };
        }
        case types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER: {
            return initiatorDepositTokenAddress === responderDepositTokenAddress
                ? {
                    multiAssetMultiPartyCoinTransferInterpreterParams: {
                        limit: [initiatorBalanceDecrement.add(responderBalanceDecrement)],
                        tokenAddresses: [initiatorDepositTokenAddress]
                    }
                }
                : {
                    multiAssetMultiPartyCoinTransferInterpreterParams: {
                        limit: [initiatorBalanceDecrement, responderBalanceDecrement],
                        tokenAddresses: [
                            initiatorDepositTokenAddress,
                            responderDepositTokenAddress
                        ]
                    }
                };
        }
        case types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER: {
            if (initiatorDepositTokenAddress !== responderDepositTokenAddress) {
                throw Error(errors_1.TWO_PARTY_OUTCOME_DIFFERENT_ASSETS(initiatorDepositTokenAddress, responderDepositTokenAddress));
            }
            return {
                singleAssetTwoPartyCoinTransferInterpreterParams: {
                    limit: disableLimit
                        ? constants_1.MaxUint256
                        : initiatorBalanceDecrement.add(responderBalanceDecrement),
                    tokenAddress: initiatorDepositTokenAddress
                }
            };
        }
        default: {
            throw Error("The outcome type in this application logic contract is not supported yet.");
        }
    }
}
function constructConditionalTransactionData(networkContext, stateChannel) {
    const appInstance = stateChannel.mostRecentlyInstalledAppInstance();
    return new conditional_transaction_commitment_1.ConditionalTransaction(networkContext, stateChannel.multisigAddress, stateChannel.multisigOwners, appInstance.identityHash, stateChannel.freeBalance.identityHash, getInterpreterAddressFromOutcomeType(appInstance.outcomeType, networkContext), appInstance.encodedInterpreterParams);
}
function getInterpreterAddressFromOutcomeType(outcomeType, networkContext) {
    switch (outcomeType) {
        case types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER: {
            return networkContext.MultiAssetMultiPartyCoinTransferInterpreter;
        }
        case types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER: {
            return networkContext.SingleAssetTwoPartyCoinTransferInterpreter;
        }
        case types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME: {
            return networkContext.TwoPartyFixedOutcomeInterpreter;
        }
        default: {
            throw Error("The outcome type in this application logic contract is not supported yet.");
        }
    }
}
//# sourceMappingURL=install.js.map