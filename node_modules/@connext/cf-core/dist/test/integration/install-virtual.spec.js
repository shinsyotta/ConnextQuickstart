"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const src_1 = require("../../src");
const setup_1 = require("./setup");
const utils_1 = require("./utils");
const constants_1 = require("ethers/constants");
const constants_2 = require("../../src/constants");
const { TicTacToeApp } = global["networkContext"];
describe("Node method follows spec - proposeInstallVirtual", () => {
    let nodeA;
    let nodeB;
    let nodeC;
    beforeAll(async () => {
        const context = await setup_1.setup(global, true);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        nodeC = context["C"].node;
    });
    describe("Node A makes a proposal through an intermediary Node B to install a " +
        "Virtual AppInstance with Node C. All Nodes confirm receipt of proposal", () => {
        it("sends proposal with non-null initial state", async (done) => {
            const multisigAddressAB = await utils_1.createChannel(nodeA, nodeB);
            const multisigAddressBC = await utils_1.createChannel(nodeB, nodeC);
            await utils_1.collateralizeChannel(multisigAddressAB, nodeA, nodeB);
            await utils_1.collateralizeChannel(multisigAddressBC, nodeB, nodeC);
            nodeA.once("INSTALL_VIRTUAL_EVENT", async (msg) => {
                const [virtualAppNodeA] = await utils_1.getInstalledAppInstances(nodeA);
                const [virtualAppNodeC] = await utils_1.getInstalledAppInstances(nodeC);
                expect(virtualAppNodeA).toEqual(virtualAppNodeC);
                utils_1.assertNodeMessage(msg, {
                    from: nodeC.publicIdentifier,
                    type: "INSTALL_VIRTUAL_EVENT",
                    data: {
                        params: {
                            appInstanceId: virtualAppNodeA.identityHash
                        }
                    }
                });
                done();
            });
            nodeC.once("PROPOSE_INSTALL_EVENT", async (msg) => {
                const { params: proposedParams } = await proposal;
                utils_1.assertProposeMessage(nodeA.publicIdentifier, msg, proposedParams);
                const { data: { params, appInstanceId } } = msg;
                const [proposedAppNodeC] = await utils_1.getProposedAppInstances(nodeC);
                utils_1.confirmProposedAppInstance(params, proposedAppNodeC, true);
                expect(proposedAppNodeC.proposedByIdentifier).toEqual(nodeA.publicIdentifier);
                await utils_1.installTTTVirtual(nodeC, appInstanceId, nodeB.publicIdentifier);
            });
            const proposal = utils_1.makeVirtualProposal(nodeA, nodeC, TicTacToeApp);
            const { params } = await proposal;
            const [proposedAppNodeA] = await utils_1.getProposedAppInstances(nodeA);
            utils_1.confirmProposedAppInstance(params, proposedAppNodeA);
        });
    });
    describe("Node A makes a virtual proposal through intermediary B to install a virtual app instance with c", () => {
        let nodeA;
        let nodeB;
        let nodeC;
        let multisigAddressAB;
        let multisigAddressBC;
        beforeAll(async () => {
            const context = await setup_1.setup(global, true);
            nodeA = context["A"].node;
            nodeB = context["B"].node;
            nodeC = context["C"].node;
            multisigAddressAB = await utils_1.createChannel(nodeA, nodeB);
            multisigAddressBC = await utils_1.createChannel(nodeB, nodeC);
        });
        it("should fail if intermediary has insufficient collateral in the channel", async (done) => {
            await utils_1.collateralizeChannel(multisigAddressAB, nodeA, nodeB, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, false);
            nodeC.once("PROPOSE_INSTALL_EVENT", async (msg) => {
                const { data: { appInstanceId } } = msg;
                try {
                    await utils_1.installTTTVirtual(nodeC, appInstanceId, nodeB.publicIdentifier);
                }
                catch (e) {
                    expect(e.message.includes(`Node Error: ${src_1.VIRTUAL_APP_INSTALLATION_FAIL}`)).toBeTruthy();
                }
                done();
            });
            const { params } = await utils_1.makeVirtualProposal(nodeA, nodeC, TicTacToeApp);
            expect(src_1.bigNumberifyJson(params.initiatorDeposit).gt(constants_1.Zero)).toBeTruthy();
            const [proposedAppNodeA] = await utils_1.getProposedAppInstances(nodeA);
            utils_1.confirmProposedAppInstance(params, proposedAppNodeA);
        });
        it.skip("should emit an event on intermediaries node", async (done) => {
            await utils_1.collateralizeChannel(multisigAddressAB, nodeA, nodeB);
            await utils_1.collateralizeChannel(multisigAddressBC, nodeB, nodeC);
            nodeB.once("INSTALL_VIRTUAL_EVENT", () => done());
            nodeC.once("PROPOSE_INSTALL_EVENT", async (msg) => {
                const { data: { appInstanceId } } = msg;
                await utils_1.installTTTVirtual(nodeC, appInstanceId, nodeB.publicIdentifier);
            });
            const { params } = await utils_1.makeVirtualProposal(nodeA, nodeC, TicTacToeApp);
            expect(src_1.bigNumberifyJson(params.initiatorDeposit).gt(constants_1.Zero)).toBeTruthy();
            const [proposedAppNodeA] = await utils_1.getProposedAppInstances(nodeA);
            utils_1.confirmProposedAppInstance(params, proposedAppNodeA);
        });
    });
});
//# sourceMappingURL=install-virtual.spec.js.map