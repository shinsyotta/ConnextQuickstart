"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid");
const lib_1 = require("./lib");
const types_1 = require("./types");
const validation_1 = require("./validation");
const guardedSubjects = ["channel", "lock", "transfer"];
const sendFailed = "Failed to send message";
class NodeApiClient {
    constructor(opts) {
        this.latestSwapRates = {};
        this.recipientOnline = (recipientPublicIdentifier) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.send(`online.${recipientPublicIdentifier}`);
            }
            catch (e) {
                if (e.message.startsWith("Request timed out")) {
                    return false;
                }
                throw e;
            }
        });
        this.messaging = opts.messaging;
        this.log = new lib_1.Logger("NodeApiClient", opts.logLevel);
        this._userPublicIdentifier = opts.userPublicIdentifier;
        this._nodePublicIdentifier = opts.nodePublicIdentifier;
        this._channelProvider = opts.channelProvider;
    }
    get channelProvider() {
        return this._channelProvider;
    }
    set channelProvider(channelProvider) {
        this._channelProvider = channelProvider;
    }
    get userPublicIdentifier() {
        return this._userPublicIdentifier;
    }
    set userPublicIdentifier(userXpub) {
        this._userPublicIdentifier = userXpub;
    }
    get nodePublicIdentifier() {
        return this._nodePublicIdentifier;
    }
    set nodePublicIdentifier(nodeXpub) {
        this._nodePublicIdentifier = nodeXpub;
    }
    acquireLock(lockName, callback, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const lockValue = yield this.send(`lock.acquire.${lockName}`, { lockTTL: timeout });
            this.log.debug(`Acquired lock at ${Date.now()} for ${lockName} with secret ${lockValue}`);
            let retVal;
            try {
                retVal = yield callback();
            }
            catch (e) {
                this.log.error(`Failed to execute callback while lock is held: ${e.stack || e.message}`);
            }
            finally {
                yield this.send(`lock.release.${lockName}`, { lockValue });
                this.log.debug(`Released lock at ${Date.now()} for ${lockName}`);
            }
            return retVal;
        });
    }
    appRegistry(appDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.send("app-registry", appDetails));
        });
    }
    config() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.send("config.get"));
        });
    }
    createChannel() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.create.${this.userPublicIdentifier}`);
        });
    }
    getChannel() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.get.${this.userPublicIdentifier}`);
        });
    }
    getPendingAsyncTransfers() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.send(`transfer.get-pending.${this.userPublicIdentifier}`)) || [];
        });
    }
    getLatestSwapRate(from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`swap-rate.${from}.${to}`);
        });
    }
    getTransferHistory() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.send(`transfer.get-history.${this.userPublicIdentifier}`)) || [];
        });
    }
    requestCollateral(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.send(`channel.request-collateral.${this.userPublicIdentifier}`, {
                    assetId,
                });
            }
            catch (e) {
                if (e.message.startsWith("Request timed out")) {
                    this.log.warn(`request collateral message timed out`);
                    return;
                }
                throw e;
            }
        });
    }
    withdraw(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.withdraw.${this.userPublicIdentifier}`, {
                tx,
            });
        });
    }
    fetchLinkedTransfer(paymentId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`transfer.fetch-linked.${this.userPublicIdentifier}`, {
                paymentId,
            });
        });
    }
    resolveLinkedTransfer(paymentId, linkedHash, meta = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`transfer.resolve-linked.${this.userPublicIdentifier}`, {
                linkedHash,
                meta,
                paymentId,
            });
        });
    }
    addPaymentProfile(profile) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.add-profile.${this.userPublicIdentifier}`, profile);
        });
    }
    getPaymentProfile(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.get-profile.${this.userPublicIdentifier}`, {
                assetId: types_1.makeChecksumOrEthAddress(assetId),
            });
        });
    }
    setRecipientAndEncryptedPreImageForLinkedTransfer(recipientPublicIdentifier, encryptedPreImage, linkedHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`transfer.set-recipient.${this.userPublicIdentifier}`, {
                encryptedPreImage,
                linkedHash,
                recipientPublicIdentifier,
            });
        });
    }
    verifyAppSequenceNumber(appSequenceNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.verify-app-sequence.${this.userPublicIdentifier}`, {
                userAppSequenceNumber: appSequenceNumber,
            });
        });
    }
    setUserPublicIdentifier(publicIdentifier) {
        const ret = validation_1.invalidXpub(publicIdentifier);
        if (ret !== undefined) {
            throw new Error(ret);
        }
        this.userPublicIdentifier = publicIdentifier;
    }
    setNodePublicIdentifier(publicIdentifier) {
        const ret = validation_1.invalidXpub(publicIdentifier);
        if (ret !== undefined) {
            throw new Error(ret);
        }
        this.nodePublicIdentifier = publicIdentifier;
    }
    subscribeToSwapRates(from, to, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.messaging.subscribe(`swap-rate.${from}.${to}`, callback);
        });
    }
    unsubscribeFromSwapRates(from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.messaging.unsubscribe(`swap-rate.${from}.${to}`);
        });
    }
    restoreState(publicIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send(`channel.restore-states.${publicIdentifier}`);
        });
    }
    getLatestWithdrawal() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`channel.latestWithdrawal.${this.userPublicIdentifier}`);
        });
    }
    clientCheckIn() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send(`client.check-in.${this.userPublicIdentifier}`);
        });
    }
    getAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.channelProvider) {
                throw new Error(`Must have instantiated a channel provider (ie a signing thing) before setting auth token`);
            }
            const nonce = yield this.send("auth.getNonce", {
                address: this.channelProvider.signerAddress,
            });
            const sig = yield this.channelProvider.send("chan_nodeAuth", { message: nonce });
            const token = `${nonce}:${sig}`;
            return token;
        });
    }
    send(subject, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let error;
            for (let attempt = 1; attempt <= lib_1.NATS_ATTEMPTS; attempt += 1) {
                const timeout = new Promise((resolve) => setTimeout(resolve, lib_1.NATS_TIMEOUT));
                try {
                    return yield this.sendAttempt(subject, data);
                }
                catch (e) {
                    error = e;
                    if (e.message.startsWith(sendFailed)) {
                        this.log.warn(`Attempt ${attempt}/${lib_1.NATS_ATTEMPTS} to send ${subject} failed: ${e.message}`);
                        yield this.messaging.disconnect();
                        yield this.messaging.connect();
                        if (attempt + 1 <= lib_1.NATS_ATTEMPTS) {
                            yield timeout;
                        }
                    }
                    else {
                        throw e;
                    }
                }
            }
            throw error;
        });
    }
    sendAttempt(subject, data) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.debug(`Sending request to ${subject} ${data ? `with data: ${lib_1.stringify(data)}` : `without data`}`);
            const payload = Object.assign({}, data, { id: uuid.v4() });
            if (guardedSubjects.includes(subject.split(".")[0])) {
                payload.token = yield this.getAuthToken();
            }
            let msg;
            try {
                msg = yield this.messaging.request(subject, lib_1.NATS_TIMEOUT, payload);
            }
            catch (e) {
                throw new Error(`${sendFailed}: ${e.message}`);
            }
            let error = msg ? (msg.data ? (msg.data.response ? msg.data.response.err : "") : "") : "";
            if (error && error.startsWith("Invalid token")) {
                this.log.info(`Auth error, token might have expired. Let's get a fresh token & try again.`);
                payload.token = yield this.getAuthToken();
                msg = yield this.messaging.request(subject, lib_1.NATS_TIMEOUT, payload);
                error = msg ? (msg.data ? (msg.data.response ? msg.data.response.err : "") : "") : "";
            }
            if (!msg.data) {
                this.log.info(`Maybe this message is malformed: ${lib_1.stringify(msg)}`);
                return undefined;
            }
            const _a = msg.data, { err, response } = _a, rest = __rest(_a, ["err", "response"]);
            if (err || error) {
                throw new Error(`Error sending request. Message: ${lib_1.stringify(msg)}`);
            }
            const isEmptyObj = typeof response === "object" && Object.keys(response).length === 0;
            return !response || isEmptyObj ? undefined : response;
        });
    }
}
exports.NodeApiClient = NodeApiClient;
//# sourceMappingURL=node.js.map