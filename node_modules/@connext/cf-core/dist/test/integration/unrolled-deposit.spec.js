"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const types_1 = require("../../src/types");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const setup_1 = require("./setup");
const utils_1 = require("./utils");
const machine_1 = require("../../src/machine");
expect.extend({ toBeLt: bignumber_jest_matcher_1.toBeLt, toBeEq: bignumber_jest_matcher_1.toBeEq });
const { CoinBalanceRefundApp } = global["networkContext"];
describe("Node method follows spec - install balance refund", () => {
    let multisigAddress;
    let nodeA;
    let nodeB;
    let provider;
    beforeEach(async () => {
        const context = await setup_1.setup(global);
        provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        multisigAddress = await utils_1.createChannel(nodeA, nodeB);
    });
    it("install app with ETH, sending ETH should increase free balance", async (done) => {
        nodeB.on(types_1.NODE_EVENTS.INSTALL, async () => {
            const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
            const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
            expect(appInstanceNodeA).toBeDefined();
            expect(appInstanceNodeA).toEqual(appInstanceNodeB);
            expect(appInstanceNodeA.latestState.recipient).toBe(machine_1.xkeyKthAddress(nodeA.publicIdentifier, 0));
            const proposedAppsA = await utils_1.getProposedAppInstances(nodeA);
            expect(proposedAppsA.length).toBe(0);
            const [preSendBalA, preSendBalB] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_1.AddressZero);
            expect(preSendBalA).toBeEq(0);
            expect(preSendBalB).toBeEq(0);
            const preDepositMultisig = await provider.getBalance(multisigAddress);
            const tx = await provider.getSigner().sendTransaction({
                to: multisigAddress,
                value: constants_1.One
            });
            await provider.waitForTransaction(tx.hash);
            const multisigBalance = await provider.getBalance(multisigAddress);
            expect(multisigBalance).toBeEq(preDepositMultisig.add(constants_1.One));
            await utils_1.rescindDepositRights(nodeA, multisigAddress);
            const [postSendBalA, postSendBalB] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_1.AddressZero);
            expect(postSendBalA).toBeEq(1);
            expect(postSendBalB).toBeEq(0);
            done();
        });
        await utils_1.requestDepositRights(nodeA, multisigAddress);
    });
    it("install app with tokens, sending tokens should increase free balance", async (done) => {
        const erc20TokenAddress = global["networkContext"].DolphinCoin;
        nodeB.on(types_1.NODE_EVENTS.INSTALL, async () => {
            const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
            const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
            expect(appInstanceNodeA).toBeDefined();
            expect(appInstanceNodeA).toEqual(appInstanceNodeB);
            expect(appInstanceNodeA.latestState.recipient).toBe(machine_1.xkeyKthAddress(nodeA.publicIdentifier, 0));
            const proposedAppsA = await utils_1.getProposedAppInstances(nodeA);
            expect(proposedAppsA.length).toBe(0);
            const [preSendBalA, preSendBalB] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, erc20TokenAddress);
            expect(preSendBalA).toBeEq(0);
            expect(preSendBalB).toBeEq(0);
            await utils_1.transferERC20Tokens(multisigAddress, erc20TokenAddress);
            await utils_1.rescindDepositRights(nodeB, multisigAddress, erc20TokenAddress);
            const [postSendBalA, postSendBalB] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, erc20TokenAddress);
            expect(postSendBalA).toBeEq(1);
            expect(postSendBalB).toBeEq(0);
            done();
        });
        await utils_1.requestDepositRights(nodeA, multisigAddress, erc20TokenAddress);
    });
    it("install app with both eth and tokens, sending eth and tokens should increase free balance", async (done) => {
        const erc20TokenAddress = global["networkContext"].DolphinCoin;
        let installedCount = 0;
        nodeB.on(types_1.NODE_EVENTS.INSTALL, async () => {
            installedCount += 1;
            const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
            const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
            expect(appInstanceNodeA).toBeDefined();
            expect(appInstanceNodeA).toEqual(appInstanceNodeB);
            expect(appInstanceNodeA.latestState.recipient).toBe(machine_1.xkeyKthAddress(nodeA.publicIdentifier, 0));
            const proposedAppsA = await utils_1.getProposedAppInstances(nodeA);
            expect(proposedAppsA.length).toBe(0);
            if (installedCount < 2) {
                return;
            }
            const [preSendBalAToken, preSendBalBToken] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, erc20TokenAddress);
            expect(preSendBalAToken).toBeEq(0);
            expect(preSendBalBToken).toBeEq(0);
            await utils_1.transferERC20Tokens(multisigAddress, erc20TokenAddress);
            await utils_1.rescindDepositRights(nodeB, multisigAddress, erc20TokenAddress);
            const [postSendBalAToken, postSendBalBToken] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, erc20TokenAddress);
            expect(postSendBalAToken).toBeEq(1);
            expect(postSendBalBToken).toBeEq(0);
            const [preSendBalAEth, preSendBalBEth] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_1.AddressZero);
            expect(preSendBalAEth).toBeEq(0);
            expect(preSendBalBEth).toBeEq(0);
            const preDepositMultisig = await provider.getBalance(multisigAddress);
            const tx = await provider.getSigner().sendTransaction({
                to: multisigAddress,
                value: constants_1.One
            });
            await provider.waitForTransaction(tx.hash);
            const multisigBalance = await provider.getBalance(multisigAddress);
            expect(multisigBalance).toBeEq(preDepositMultisig.add(constants_1.One));
            await utils_1.rescindDepositRights(nodeB, multisigAddress);
            const [postSendBalAEth, postSendBalBEth] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_1.AddressZero);
            expect(postSendBalAEth).toBeEq(1);
            expect(postSendBalBEth).toBeEq(0);
            done();
        });
        let parameters = await utils_1.getProposeCoinBalanceRefundAppParams(multisigAddress, nodeA.publicIdentifier, nodeB.publicIdentifier, constants_1.AddressZero);
        await new Promise(async (res) => {
            nodeB.once(types_1.NODE_EVENTS.PROPOSE_INSTALL, data => res(data));
            await nodeA.rpcRouter.dispatch({
                id: Date.now(),
                methodName: types_1.Node.RpcMethodName.PROPOSE_INSTALL,
                parameters
            });
        });
        await utils_1.requestDepositRights(nodeA, multisigAddress);
        parameters = await utils_1.getProposeCoinBalanceRefundAppParams(multisigAddress, nodeA.publicIdentifier, nodeB.publicIdentifier, erc20TokenAddress);
        await new Promise(async (res) => {
            nodeB.once(types_1.NODE_EVENTS.PROPOSE_INSTALL, data => res(data));
            await nodeA.rpcRouter.dispatch({
                id: Date.now(),
                methodName: types_1.Node.RpcMethodName.PROPOSE_INSTALL,
                parameters
            });
        });
        await utils_1.requestDepositRights(nodeA, multisigAddress, erc20TokenAddress);
    });
    it("install does not error if already installed", async (done) => {
        nodeB.on(types_1.NODE_EVENTS.INSTALL, async () => {
            const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
            const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
            expect(appInstanceNodeA).toBeDefined();
            expect(appInstanceNodeA).toEqual(appInstanceNodeB);
            expect(appInstanceNodeA.latestState.recipient).toBe(machine_1.xkeyKthAddress(nodeA.publicIdentifier, 0));
            done();
        });
        await utils_1.requestDepositRights(nodeA, multisigAddress);
    });
    it("can uninstall with no changes", async (done) => {
        nodeB.on(types_1.NODE_EVENTS.INSTALL, async () => {
            await utils_1.rescindDepositRights(nodeB, multisigAddress);
            const appInstancesNodeA = await utils_1.getInstalledAppInstances(nodeA);
            const appInstancesNodeB = await utils_1.getInstalledAppInstances(nodeB);
            expect(appInstancesNodeA.length).toBe(0);
            expect(appInstancesNodeB.length).toBe(0);
            done();
        });
        await utils_1.requestDepositRights(nodeA, multisigAddress);
    });
    it("uninstall does not error if not installed", async () => {
        await utils_1.rescindDepositRights(nodeA, multisigAddress);
        const appInstancesNodeA = await utils_1.getInstalledAppInstances(nodeA);
        const appInstancesNodeB = await utils_1.getInstalledAppInstances(nodeB);
        expect(appInstancesNodeA.length).toBe(0);
        expect(appInstancesNodeB.length).toBe(0);
    });
});
//# sourceMappingURL=unrolled-deposit.spec.js.map