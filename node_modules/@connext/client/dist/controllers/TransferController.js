"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class TransferController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.transfer = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Transfer called with parameters: ${lib_1.stringify(params)}`);
            const { recipient, amount, assetId, meta } = types_1.convert.TransferParameters("bignumber", params);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBalance[this.connext.freeBalanceAddress];
            validation_1.validate(validation_1.invalidXpub(recipient), validation_1.invalidAddress(assetId), validation_1.notLessThanOrEqualTo(amount, preTransferBal));
            const appInfo = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.SimpleTransferApp);
            const appId = yield this.transferAppInstalled(amount, recipient, assetId, appInfo, meta);
            if (!appId) {
                throw new Error(`App was not installed`);
            }
            this.log.info(`Uninstalling app ${appId}`);
            yield this.connext.uninstallVirtualApp(appId);
            const postTransferBal = yield this.connext.getFreeBalance(assetId);
            const diff = preTransferBal.sub(postTransferBal[this.connext.freeBalanceAddress]);
            if (!diff.eq(amount)) {
                this.log.info("Welp it appears the difference of the free balance before and after " +
                    "uninstalling is not what we expected......");
            }
            else if (postTransferBal[this.connext.freeBalanceAddress].gte(preTransferBal)) {
                this.log.info("Free balance after transfer is gte free balance " +
                    "before transfer..... That's not great..");
            }
            const newState = yield this.connext.getChannel();
            return newState;
        });
        this.resolveInstallTransfer = (res, appId, data) => {
            if (appId !== data.params.appInstanceId) {
                this.log.warn(`Caught INSTALL_VIRTUAL event for different app ${lib_1.stringify(data)}, expected ${appId}. This should not happen.`);
                return;
            }
            res(data);
            return data;
        };
        this.rejectInstallTransfer = (rej, appId, msg) => {
            if (appId !== msg.data.appInstanceId) {
                this.log.warn(`Caught INSTALL_VIRTUAL event for different app ${lib_1.stringify(msg)}, expected ${appId}. This should not happen.`);
                return;
            }
            return rej(`Install virtual failed. Event data: ${lib_1.stringify(msg)}`);
        };
        this.transferAppInstalled = (amount, recipient, assetId, appInfo, meta) => __awaiter(this, void 0, void 0, function* () {
            let boundResolve;
            let boundReject;
            const initialState = {
                coinTransfers: [
                    {
                        amount,
                        to: lib_1.xpubToAddress(this.connext.publicIdentifier),
                    },
                    {
                        amount: constants_1.Zero,
                        to: lib_1.xpubToAddress(recipient),
                    },
                ],
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding, outcomeType, } = appInfo;
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: amount,
                initiatorDepositTokenAddress: assetId,
                outcomeType,
                proposedToIdentifier: recipient,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
                meta,
            };
            const res = yield this.connext.proposeInstallApp(params);
            const appId = res.appInstanceId;
            try {
                yield Promise.race([
                    new Promise((res, rej) => {
                        boundReject = this.rejectInstallTransfer.bind(null, rej, appId);
                        boundResolve = this.resolveInstallTransfer.bind(null, res, appId);
                        this.listener.on(types_1.CFCoreTypes.EventNames.INSTALL_VIRTUAL_EVENT, boundResolve);
                        this.listener.on(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
                    }),
                    lib_1.delayAndThrow(lib_1.CF_METHOD_TIMEOUT, `App install took longer than ${lib_1.CF_METHOD_TIMEOUT / 1000} seconds`),
                ]);
                this.log.info(`App was installed successfully!: ${lib_1.stringify(res)}`);
                return res.appInstanceId;
            }
            catch (e) {
                this.log.error(`Error installing app: ${e.stack || e.message}`);
                return undefined;
            }
            finally {
                this.cleanupInstallListeners(boundResolve, boundReject);
            }
        });
        this.cleanupInstallListeners = (boundResolve, boundReject) => {
            this.listener.removeListener(types_1.CFCoreTypes.EventNames.INSTALL_VIRTUAL_EVENT, boundResolve);
            this.listener.removeListener(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
        };
    }
}
exports.TransferController = TransferController;
//# sourceMappingURL=TransferController.js.map