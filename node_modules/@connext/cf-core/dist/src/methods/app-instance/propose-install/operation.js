"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../../constants");
const machine_1 = require("../../../machine");
async function createProposedAppInstance(myIdentifier, store, networkContext, params) {
    const { abiEncodings, appDefinition, initialState, initiatorDeposit, initiatorDepositTokenAddress, outcomeType, proposedToIdentifier, responderDeposit, responderDepositTokenAddress, timeout } = params;
    const multisigAddress = await store.getMultisigAddressWithCounterparty([myIdentifier, proposedToIdentifier], networkContext.ProxyFactory, networkContext.MinimumViableMultisig, networkContext.provider);
    const stateChannel = await store.getOrCreateStateChannelBetweenVirtualAppParticipants(multisigAddress, myIdentifier, proposedToIdentifier);
    const appInstanceProposal = {
        identityHash: machine_1.appIdentityToHash({
            appDefinition,
            channelNonce: stateChannel.numProposedApps,
            participants: stateChannel.getSigningKeysFor(stateChannel.numProposedApps),
            defaultTimeout: timeout.toNumber()
        }),
        abiEncodings: abiEncodings,
        appDefinition: appDefinition,
        appSeqNo: stateChannel.numProposedApps,
        initialState: initialState,
        initiatorDeposit: initiatorDeposit.toHexString(),
        initiatorDepositTokenAddress: initiatorDepositTokenAddress || constants_1.CONVENTION_FOR_ETH_TOKEN_ADDRESS,
        outcomeType: outcomeType,
        proposedByIdentifier: myIdentifier,
        proposedToIdentifier: proposedToIdentifier,
        responderDeposit: responderDeposit.toHexString(),
        responderDepositTokenAddress: responderDepositTokenAddress || constants_1.CONVENTION_FOR_ETH_TOKEN_ADDRESS,
        timeout: timeout.toHexString()
    };
    await store.saveStateChannel(stateChannel.addProposal(appInstanceProposal));
    return appInstanceProposal.identityHash;
}
exports.createProposedAppInstance = createProposedAppInstance;
//# sourceMappingURL=operation.js.map