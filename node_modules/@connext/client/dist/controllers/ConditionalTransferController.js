"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const eth_crypto_1 = __importDefault(require("eth-crypto"));
const constants_1 = require("ethers/constants");
const hdnode_1 = require("ethers/utils/hdnode");
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class ConditionalTransferController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.conditionalTransfer = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Conditional transfer called with parameters: ${lib_1.stringify(params)}`);
            const res = yield this.conditionalExecutors[params.conditionType](params);
            return res;
        });
        this.handleLinkedTransferToRecipient = (params) => __awaiter(this, void 0, void 0, function* () {
            const { amount, assetId, paymentId, preImage, recipient } = types_1.convert.LinkedTransferToRecipient("bignumber", params);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBalance[this.connext.freeBalanceAddress];
            validation_1.validate(validation_1.notNegative(amount), validation_1.invalidAddress(assetId), validation_1.notLessThanOrEqualTo(amount, preTransferBal), validation_1.invalid32ByteHexString(paymentId), validation_1.invalid32ByteHexString(preImage), validation_1.invalidXpub(recipient));
            const linkedHash = lib_1.createLinkedHash(amount, assetId, paymentId, preImage);
            const ret = yield this.handleLinkedTransfers(Object.assign({}, params, { conditionType: "LINKED_TRANSFER" }));
            const recipientPublicKey = hdnode_1.fromExtendedKey(recipient).derivePath("0").publicKey;
            const encryptedPreImageCipher = yield eth_crypto_1.default.encryptWithPublicKey(recipientPublicKey.slice(2), preImage);
            const encryptedPreImage = eth_crypto_1.default.cipher.stringify(encryptedPreImageCipher);
            yield this.connext.setRecipientAndEncryptedPreImageForLinkedTransfer(recipient, encryptedPreImage, linkedHash);
            this.connext.messaging.publish(`transfer.send-async.${recipient}`, lib_1.stringify({
                amount: amount.toString(),
                assetId,
                encryptedPreImage,
                paymentId,
            }));
            yield this.connext.messaging.flush();
            return Object.assign({}, ret, { recipient });
        });
        this.handleLinkedTransfers = (params) => __awaiter(this, void 0, void 0, function* () {
            const { amount, assetId, paymentId, preImage, meta } = types_1.convert.LinkedTransfer("bignumber", params);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBalance[this.connext.freeBalanceAddress];
            validation_1.validate(validation_1.notNegative(amount), validation_1.invalidAddress(assetId), validation_1.notLessThanOrEqualTo(amount, preTransferBal), validation_1.invalid32ByteHexString(paymentId), validation_1.invalid32ByteHexString(preImage));
            const appInfo = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.SimpleLinkedTransferApp);
            const linkedHash = lib_1.createLinkedHash(amount, assetId, paymentId, preImage);
            const initialState = {
                amount,
                assetId,
                coinTransfers: [
                    {
                        amount,
                        to: lib_1.xpubToAddress(this.connext.publicIdentifier),
                    },
                    {
                        amount: constants_1.Zero,
                        to: lib_1.xpubToAddress(this.connext.nodePublicIdentifier),
                    },
                ],
                linkedHash,
                paymentId,
                preImage: constants_1.HashZero,
            };
            const appId = yield this.conditionalTransferAppInstalled(amount, assetId, initialState, appInfo, meta);
            if (!appId) {
                throw new Error(`App was not installed`);
            }
            return {
                freeBalance: yield this.connext.getFreeBalance(assetId),
                paymentId,
                preImage,
            };
        });
        this.conditionalTransferAppInstalled = (initiatorDeposit, assetId, initialState, appInfo, meta) => __awaiter(this, void 0, void 0, function* () {
            let boundResolve;
            let boundReject;
            const { appDefinitionAddress: appDefinition, outcomeType, stateEncoding, actionEncoding, } = appInfo;
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit,
                initiatorDepositTokenAddress: assetId,
                meta,
                outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
            };
            const proposeRes = yield this.connext.proposeInstallApp(params);
            this.appId = proposeRes.appInstanceId;
            try {
                const raceRes = yield Promise.race([
                    new Promise((res, rej) => {
                        boundResolve = this.resolveInstallTransfer.bind(null, res);
                        boundReject = this.rejectInstallTransfer.bind(null, rej);
                        this.connext.messaging.subscribe(`indra.node.${this.connext.nodePublicIdentifier}.install.${proposeRes.appInstanceId}`, boundResolve);
                        this.listener.on(types_1.CFCoreTypes.EventName.REJECT_INSTALL, boundReject);
                    }),
                    lib_1.delayAndThrow(lib_1.CF_METHOD_TIMEOUT, `App install took longer than ${lib_1.CF_METHOD_TIMEOUT / 1000} seconds`),
                ]);
                this.log.info(`Installed app ${this.appId}`);
                this.log.debug(`Installed app details: ${lib_1.stringify(raceRes)}`);
                return proposeRes.appInstanceId;
            }
            catch (e) {
                this.log.error(`Error installing app: ${e.toString()}`);
                return undefined;
            }
            finally {
                this.cleanupInstallListeners(boundReject, proposeRes.appInstanceId);
            }
        });
        this.resolveInstallTransfer = (res, message) => {
            const appInstance = message.data.data ? message.data.data : message.data;
            if (appInstance.identityHash !== this.appId) {
                this.log.info(`Caught INSTALL event for different app ${lib_1.stringify(message)}, expected ${this.appId}`);
                return;
            }
            res(message);
            return message;
        };
        this.rejectInstallTransfer = (rej, msg) => {
            if (this.appId !== msg.data.appInstanceId) {
                return;
            }
            return rej(`Install failed. Event data: ${lib_1.stringify(msg)}`);
        };
        this.cleanupInstallListeners = (boundReject, appId) => {
            this.connext.messaging.unsubscribe(`indra.node.${this.connext.nodePublicIdentifier}.install.${appId}`);
            this.listener.removeListener(types_1.CFCoreTypes.EventName.REJECT_INSTALL, boundReject);
        };
        this.conditionalExecutors = {
            LINKED_TRANSFER: this.handleLinkedTransfers,
            LINKED_TRANSFER_TO_RECIPIENT: this.handleLinkedTransferToRecipient,
        };
    }
}
exports.ConditionalTransferController = ConditionalTransferController;
//# sourceMappingURL=ConditionalTransferController.js.map