"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../../constants");
const contracts_1 = require("../../../contracts");
const machine_1 = require("../../../machine");
const models_1 = require("../../../models");
const types_1 = require("../../../types");
const errors_1 = require("../../errors");
const DEPOSIT_RETRY_COUNT = 3;
async function installBalanceRefundApp(requestHandler, params) {
    const { publicIdentifier, protocolRunner, networkContext, store, provider } = requestHandler;
    const { multisigAddress, tokenAddress } = params;
    const [peerAddress] = await models_1.StateChannel.getPeersAddressFromChannel(publicIdentifier, store, multisigAddress);
    const stateChannel = await store.getStateChannel(multisigAddress);
    const stateChannelsMap = new Map([
        [stateChannel.multisigAddress, stateChannel]
    ]);
    const depositContext = await getDepositContext(params, publicIdentifier, provider, networkContext, tokenAddress);
    const installProtocolParams = {
        initialState: depositContext.initialState,
        initiatorXpub: publicIdentifier,
        responderXpub: peerAddress,
        multisigAddress: stateChannel.multisigAddress,
        initiatorBalanceDecrement: constants_1.Zero,
        responderBalanceDecrement: constants_1.Zero,
        participants: stateChannel.getNextSigningKeys(),
        appInterface: depositContext.appInterface,
        defaultTimeout: 1008,
        appSeqNo: stateChannel.numProposedApps,
        outcomeType: types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER,
        initiatorDepositTokenAddress: tokenAddress,
        responderDepositTokenAddress: tokenAddress,
        disableLimit: true
    };
    await protocolRunner.initiateProtocol(machine_1.Protocol.Install, stateChannelsMap, installProtocolParams);
}
exports.installBalanceRefundApp = installBalanceRefundApp;
async function makeDeposit(requestHandler, params) {
    const { multisigAddress, amount, tokenAddress } = params;
    const { provider, blocksNeededForConfirmation, outgoing, publicIdentifier } = requestHandler;
    const signer = await requestHandler.getSigner();
    const signerAddress = await signer.getAddress();
    let txResponse;
    let retryCount = DEPOSIT_RETRY_COUNT;
    const errors = [];
    while (retryCount > 0) {
        try {
            if (tokenAddress === constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
                const tx = {
                    to: multisigAddress,
                    value: utils_1.bigNumberify(amount),
                    gasLimit: 30000,
                    gasPrice: await provider.getGasPrice(),
                    nonce: provider.getTransactionCount(signerAddress, "pending"),
                };
                txResponse = await signer.sendTransaction(tx);
            }
            else {
                const erc20Contract = new ethers_1.Contract(tokenAddress, contracts_1.ERC20.abi, signer);
                txResponse = await erc20Contract.functions.transfer(multisigAddress, utils_1.bigNumberify(amount), {
                    nonce: provider.getTransactionCount(signerAddress, "pending"),
                });
            }
            break;
        }
        catch (e) {
            errors.push(e.toString());
            const failMsg = {
                from: publicIdentifier,
                type: types_1.NODE_EVENTS.DEPOSIT_FAILED_EVENT,
                data: { errors, params }
            };
            if (e.toString().includes("reject") || e.toString().includes("denied")) {
                outgoing.emit(types_1.NODE_EVENTS.DEPOSIT_FAILED_EVENT, failMsg);
                throw Error(`${errors_1.DEPOSIT_FAILED}: ${e.message}`);
            }
            retryCount -= 1;
            if (retryCount === 0) {
                outgoing.emit(types_1.NODE_EVENTS.DEPOSIT_FAILED_EVENT, failMsg);
                throw Error(`${errors_1.DEPOSIT_FAILED}: ${e.message}`);
            }
        }
    }
    outgoing.emit("DEPOSIT_STARTED_EVENT", {
        from: publicIdentifier,
        type: "DEPOSIT_STARTED_EVENT",
        data: {
            value: amount,
            txHash: txResponse.hash
        }
    });
    await txResponse.wait(blocksNeededForConfirmation);
}
exports.makeDeposit = makeDeposit;
async function uninstallBalanceRefundApp(requestHandler, params, blockNumberToUseIfNecessary) {
    const { publicIdentifier, store, protocolRunner, networkContext } = requestHandler;
    const { multisigAddress, tokenAddress } = params;
    const { CoinBalanceRefundApp } = networkContext;
    const [peerAddress] = await models_1.StateChannel.getPeersAddressFromChannel(publicIdentifier, store, multisigAddress);
    const stateChannel = await store.getStateChannel(params.multisigAddress);
    let refundApp;
    try {
        refundApp = stateChannel.getBalanceRefundAppInstance(CoinBalanceRefundApp, tokenAddress);
    }
    catch (e) {
        if (e.message.includes(`No CoinBalanceRefund app instance`)) {
            return;
        }
    }
    await protocolRunner.initiateProtocol(machine_1.Protocol.Uninstall, new Map([
        [stateChannel.multisigAddress, stateChannel]
    ]), {
        initiatorXpub: publicIdentifier,
        responderXpub: peerAddress,
        multisigAddress: stateChannel.multisigAddress,
        appIdentityHash: refundApp.identityHash,
        blockNumberToUseIfNecessary
    });
}
exports.uninstallBalanceRefundApp = uninstallBalanceRefundApp;
async function getDepositContext(params, publicIdentifier, provider, networkContext, tokenAddress) {
    const { multisigAddress } = params;
    const threshold = tokenAddress === constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS
        ? await provider.getBalance(multisigAddress)
        : await new ethers_1.Contract(tokenAddress, contracts_1.ERC20.abi, provider).functions.balanceOf(multisigAddress);
    const initialState = {
        threshold,
        tokenAddress,
        recipient: machine_1.xkeyKthAddress(publicIdentifier, 0),
        multisig: multisigAddress
    };
    return {
        initialState,
        appInterface: {
            addr: networkContext.CoinBalanceRefundApp,
            stateEncoding: types_1.coinBalanceRefundStateEncoding,
            actionEncoding: undefined
        }
    };
}
//# sourceMappingURL=operation.js.map