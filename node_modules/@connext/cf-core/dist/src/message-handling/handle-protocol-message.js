"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const machine_1 = require("../machine");
const errors_1 = require("../methods/errors");
const signature_forwarder_1 = require("../protocol/utils/signature-forwarder");
const utils_1 = require("../utils");
async function handleReceivedProtocolMessage(requestHandler, msg) {
    const { protocolRunner, store, router, networkContext, publicIdentifier } = requestHandler;
    const { data } = utils_1.bigNumberifyJson(msg);
    const { protocol, seq, params } = data;
    if (seq === signature_forwarder_1.UNASSIGNED_SEQ_NO)
        return;
    const preProtocolStateChannelsMap = await store.getStateChannelsMap();
    const postProtocolStateChannelsMap = await protocolRunner.runProtocolWithMessage(data, preProtocolStateChannelsMap);
    const outgoingEventData = await getOutgoingEventDataFromProtocol(protocol, params, postProtocolStateChannelsMap, networkContext, store, publicIdentifier);
    if (outgoingEventData &&
        (protocol === machine_1.Protocol.Install || protocol === machine_1.Protocol.InstallVirtualApp)) {
        const appInstanceId = outgoingEventData.data["appInstanceId"] ||
            outgoingEventData.data.params["appInstanceId"];
        if (appInstanceId) {
            let proposal;
            try {
                proposal = await store.getAppInstanceProposal(appInstanceId);
            }
            catch (e) {
                if (!e
                    .toString()
                    .includes(errors_1.NO_PROPOSED_APP_INSTANCE_FOR_APP_INSTANCE_ID(appInstanceId))) {
                    throw e;
                }
            }
            if (proposal) {
                await store.saveStateChannel((await store.getChannelFromAppInstanceID(appInstanceId)).removeProposal(appInstanceId));
            }
        }
    }
    if (outgoingEventData) {
        await emitOutgoingNodeMessage(router, outgoingEventData);
    }
}
exports.handleReceivedProtocolMessage = handleReceivedProtocolMessage;
function emitOutgoingNodeMessage(router, msg) {
    return router.emit(msg["type"], msg, "outgoing");
}
async function getOutgoingEventDataFromProtocol(protocol, params, stateChannelsMap, networkContext, store, publicIdentifier) {
    const baseEvent = { from: params.initiatorXpub };
    switch (protocol) {
        case machine_1.Protocol.Propose:
            const _a = params, { multisigAddress, initiatorXpub, responderXpub } = _a, emittedParams = __rest(_a, ["multisigAddress", "initiatorXpub", "responderXpub"]);
            return Object.assign({}, baseEvent, { type: "PROPOSE_INSTALL_EVENT", data: {
                    params: Object.assign({}, emittedParams, { proposedToIdentifier: responderXpub }),
                    appInstanceId: stateChannelsMap
                        .get(params.multisigAddress)
                        .mostRecentlyProposedAppInstance().identityHash
                } });
        case machine_1.Protocol.Install:
            return Object.assign({}, baseEvent, { type: "INSTALL_EVENT", data: {
                    params: {
                        appInstanceId: stateChannelsMap
                            .get(params.multisigAddress)
                            .mostRecentlyInstalledAppInstance().identityHash
                    }
                } });
        case machine_1.Protocol.Uninstall:
            return Object.assign({}, baseEvent, { type: "UNINSTALL_EVENT", data: getUninstallEventData(params) });
        case machine_1.Protocol.Setup:
            return Object.assign({}, baseEvent, { type: "CREATE_CHANNEL_EVENT", data: getSetupEventData(params, stateChannelsMap.get(params.multisigAddress)
                    .multisigOwners) });
        case machine_1.Protocol.Withdraw:
            return Object.assign({}, baseEvent, { type: "WITHDRAWAL_STARTED_EVENT", data: getWithdrawEventData(params) });
        case machine_1.Protocol.TakeAction:
        case machine_1.Protocol.Update:
            return Object.assign({}, baseEvent, { type: "UPDATE_STATE_EVENT", data: getStateUpdateEventData(params, stateChannelsMap
                    .get(params
                    .multisigAddress)
                    .getAppInstance(params
                    .appIdentityHash).state) });
        case machine_1.Protocol.InstallVirtualApp:
            const { initiatorXpub: initiator, intermediaryXpub, responderXpub: responder } = params;
            const isIntermediary = publicIdentifier === intermediaryXpub;
            const virtualChannel = await store.getMultisigAddressWithCounterparty([responder, initiator], networkContext.ProxyFactory, networkContext.MinimumViableMultisig, isIntermediary ? networkContext.provider : undefined);
            if (stateChannelsMap.has(virtualChannel)) {
                return Object.assign({}, baseEvent, { type: "INSTALL_VIRTUAL_EVENT", data: {
                        params: {
                            appInstanceId: stateChannelsMap
                                .get(virtualChannel)
                                .mostRecentlyInstalledAppInstance().identityHash
                        }
                    } });
            }
            return;
        case machine_1.Protocol.UninstallVirtualApp:
            return Object.assign({}, baseEvent, { type: "UNINSTALL_VIRTUAL_EVENT", data: getUninstallVirtualAppEventData(params) });
        default:
            throw Error(`handleReceivedProtocolMessage received invalid protocol message: ${protocol}`);
    }
}
function getStateUpdateEventData(params, newState) {
    const { appIdentityHash: appInstanceId, action } = params;
    return { newState, appInstanceId, action };
}
function getUninstallVirtualAppEventData({ intermediaryXpub: intermediaryIdentifier, targetAppIdentityHash: appInstanceId }) {
    return { appInstanceId, intermediaryIdentifier };
}
function getUninstallEventData({ appIdentityHash: appInstanceId }) {
    return { appInstanceId };
}
function getWithdrawEventData(params) {
    const { multisigAddress, tokenAddress, recipient, amount } = params;
    return {
        params: {
            multisigAddress,
            tokenAddress,
            recipient,
            amount
        }
    };
}
function getSetupEventData({ initiatorXpub: counterpartyXpub, multisigAddress }, owners) {
    return { multisigAddress, owners, counterpartyXpub };
}
async function getQueueNamesListByProtocolName(protocol, params, requestHandler) {
    const { networkContext, provider, publicIdentifier, store } = requestHandler;
    async function multisigAddressFor(xpubs) {
        const allowed = protocol === machine_1.Protocol.Setup;
        return await store.getMultisigAddressWithCounterparty(xpubs, networkContext.ProxyFactory, networkContext.MinimumViableMultisig, allowed ? provider : undefined);
    }
    switch (protocol) {
        case machine_1.Protocol.Install:
        case machine_1.Protocol.Setup:
        case machine_1.Protocol.Withdraw:
        case machine_1.Protocol.Propose:
            const { multisigAddress } = params;
            return [multisigAddress];
        case machine_1.Protocol.TakeAction:
        case machine_1.Protocol.Update:
            const { appIdentityHash } = params;
            return [appIdentityHash];
        case machine_1.Protocol.Uninstall:
            const { multisigAddress: addr, appIdentityHash: appInstanceId } = params;
            return [addr, appInstanceId];
        case machine_1.Protocol.InstallVirtualApp:
            const { initiatorXpub, intermediaryXpub, responderXpub } = params;
            if (publicIdentifier === intermediaryXpub) {
                return [
                    await multisigAddressFor([initiatorXpub, intermediaryXpub]),
                    await multisigAddressFor([responderXpub, intermediaryXpub])
                ];
            }
            if (publicIdentifier === responderXpub) {
                return [
                    await multisigAddressFor([responderXpub, intermediaryXpub]),
                    await multisigAddressFor([responderXpub, initiatorXpub])
                ];
            }
        case machine_1.Protocol.UninstallVirtualApp:
            const { initiatorXpub: initiator, intermediaryXpub: intermediary, responderXpub: responder, targetAppIdentityHash } = params;
            if (publicIdentifier === intermediary) {
                return [
                    await multisigAddressFor([initiator, intermediary]),
                    await multisigAddressFor([responder, intermediary]),
                    targetAppIdentityHash
                ];
            }
            if (publicIdentifier === responder) {
                return [
                    await multisigAddressFor([responder, intermediary]),
                    await multisigAddressFor([responder, initiator]),
                    targetAppIdentityHash
                ];
            }
        default:
            throw Error(`handleReceivedProtocolMessage received invalid protocol message: ${protocol}`);
    }
}
//# sourceMappingURL=handle-protocol-message.js.map