import { IMessagingService } from "@connext/messaging";
import "core-js/stable";
import { Contract, providers } from "ethers";
import { BigNumber, Network, Transaction } from "ethers/utils";
import "regenerator-runtime/runtime";
import { ChannelRouter } from "./channelRouter";
import { Logger } from "./lib";
import { ConnextListener } from "./listener";
import { NodeApiClient } from "./node";
import { Address, AppInstanceJson, AppRegistry, CFCoreChannel, CFCoreTypes, ChannelProviderConfig, ChannelState, ClientOptions, ConditionalTransferParameters, ConditionalTransferResponse, CreateChannelResponse, DefaultApp, DepositParameters, GetConfigResponse, IConnextClient, InternalClientOptions, PaymentProfile, ResolveConditionParameters, ResolveLinkedTransferResponse, RpcType, Store, SwapParameters, Transfer, TransferParameters, WithdrawalResponse, WithdrawParameters } from "./types";
export declare const connect: (opts: ClientOptions) => Promise<IConnextClient>;
export declare class ConnextClient implements IConnextClient {
    appRegistry: AppRegistry;
    channelRouter: ChannelRouter;
    config: GetConfigResponse;
    ethProvider: providers.JsonRpcProvider;
    freeBalanceAddress: string;
    listener: ConnextListener;
    log: Logger;
    messaging: IMessagingService;
    multisigAddress: Address;
    network: Network;
    node: NodeApiClient;
    nodePublicIdentifier: string;
    publicIdentifier: string;
    routerType: RpcType;
    signerAddress: Address;
    store: Store;
    token: Contract;
    private opts;
    private keyGen;
    private depositController;
    private transferController;
    private swapController;
    private withdrawalController;
    private conditionalTransferController;
    private resolveConditionController;
    private requestDepositRightsController;
    constructor(opts: InternalClientOptions);
    isAvailable: () => Promise<void>;
    getBalanceRefundApp: (assetId?: string) => Promise<AppInstanceJson>;
    registerSubscriptions: () => Promise<void>;
    restart: () => Promise<void>;
    getChannel: () => Promise<CFCoreChannel>;
    requestCollateral: (tokenAddress: string) => Promise<void | CFCoreTypes.DepositResult>;
    setRecipientAndEncryptedPreImageForLinkedTransfer: (recipient: string, encryptedPreImage: string, linkedHash: string) => Promise<any>;
    channelProviderConfig: () => Promise<ChannelProviderConfig>;
    getLinkedTransfer: (paymentId: string) => Promise<any>;
    getAppRegistry: (appDetails?: {
        name: "CoinBalanceRefundApp" | "SimpleLinkedTransferApp" | "SimpleTransferApp" | "SimpleTwoPartySwapApp";
        network: "ganache" | "goerli" | "homestead" | "kovan" | "rinkeby" | "ropsten";
    }) => Promise<DefaultApp[]>;
    createChannel: () => Promise<CreateChannelResponse>;
    subscribeToSwapRates: (from: string, to: string, callback: any) => Promise<any>;
    getLatestSwapRate: (from: string, to: string) => Promise<string>;
    unsubscribeToSwapRates: (from: string, to: string) => Promise<void>;
    addPaymentProfile: (profile: PaymentProfile<string>) => Promise<PaymentProfile<string>>;
    getPaymentProfile: (assetId?: string) => Promise<PaymentProfile<string>>;
    getTransferHistory: () => Promise<Transfer<string>[]>;
    deposit: (params: DepositParameters<string>) => Promise<ChannelState<string>>;
    requestDepositRights: (params: Pick<DepositParameters<string>, "assetId">) => Promise<CFCoreTypes.RequestDepositRightsResult>;
    rescindDepositRights: (assetId: string) => Promise<CFCoreTypes.DepositResult>;
    swap: (params: SwapParameters<string>) => Promise<CFCoreChannel>;
    transfer: (params: TransferParameters<string>) => Promise<CFCoreChannel>;
    withdraw: (params: WithdrawParameters<string>) => Promise<WithdrawalResponse>;
    resolveCondition: (params: ResolveConditionParameters<string>) => Promise<ResolveLinkedTransferResponse>;
    conditionalTransfer: (params: ConditionalTransferParameters<string>) => Promise<ConditionalTransferResponse>;
    getLatestNodeSubmittedWithdrawal: () => Promise<{
        retry: number;
        tx: CFCoreTypes.MinimalTransaction;
    }>;
    watchForUserWithdrawal: () => Promise<void>;
    restoreState: () => Promise<void>;
    on: (event: "RECIEVE_TRANSFER_FAILED" | "RECIEVE_TRANSFER_FINISHED" | "RECIEVE_TRANSFER_STARTED" | CFCoreTypes.EventName, callback: (...args: any[]) => void) => ConnextListener;
    once: (event: "RECIEVE_TRANSFER_FAILED" | "RECIEVE_TRANSFER_FINISHED" | "RECIEVE_TRANSFER_STARTED" | CFCoreTypes.EventName, callback: (...args: any[]) => void) => ConnextListener;
    emit: (event: "RECIEVE_TRANSFER_FAILED" | "RECIEVE_TRANSFER_FINISHED" | "RECIEVE_TRANSFER_STARTED" | CFCoreTypes.EventName, data: any) => boolean;
    getState: () => Promise<CFCoreTypes.GetStateResult>;
    providerDeposit: (amount: BigNumber, assetId: string, notifyCounterparty?: boolean) => Promise<CFCoreTypes.DepositResult>;
    getAppInstances: () => Promise<AppInstanceJson[]>;
    getFreeBalance: (assetId?: string) => Promise<CFCoreTypes.GetFreeBalanceStateResult>;
    getProposedAppInstances: () => Promise<CFCoreTypes.GetProposedAppInstancesResult>;
    getProposedAppInstance: (appInstanceId: string) => Promise<CFCoreTypes.GetProposedAppInstanceResult>;
    getAppInstanceDetails: (appInstanceId: string) => Promise<CFCoreTypes.GetAppInstanceDetailsResult>;
    getAppState: (appInstanceId: string) => Promise<CFCoreTypes.GetStateResult>;
    takeAction: (appInstanceId: string, action: import("@connext/types").AppAction<T>) => Promise<CFCoreTypes.TakeActionResult>;
    updateState: (appInstanceId: string, newState: any) => Promise<CFCoreTypes.UpdateStateResult>;
    proposeInstallApp: (params: CFCoreTypes.ProposeInstallParams) => Promise<CFCoreTypes.ProposeInstallResult>;
    installVirtualApp: (appInstanceId: string) => Promise<CFCoreTypes.InstallResult>;
    installApp: (appInstanceId: string) => Promise<CFCoreTypes.InstallResult>;
    uninstallApp: (appInstanceId: string) => Promise<CFCoreTypes.UninstallResult>;
    uninstallVirtualApp: (appInstanceId: string) => Promise<CFCoreTypes.UninstallResult>;
    rejectInstallApp: (appInstanceId: string) => Promise<CFCoreTypes.UninstallResult>;
    providerWithdraw: (assetId: string, amount: BigNumber, recipient?: string) => Promise<CFCoreTypes.WithdrawResult>;
    withdrawCommitment: (amount: BigNumber, assetId?: string, recipient?: string) => Promise<CFCoreTypes.WithdrawCommitmentResult>;
    verifyAppSequenceNumber: () => Promise<any>;
    reclaimPendingAsyncTransfers: () => Promise<void>;
    reclaimPendingAsyncTransfer: (paymentId: string, encryptedPreImage: string) => Promise<ResolveLinkedTransferResponse>;
    getRegisteredAppDetails: (appName: "CoinBalanceRefundApp" | "SimpleLinkedTransferApp" | "SimpleTransferApp" | "SimpleTwoPartySwapApp") => DefaultApp;
    matchTx: (givenTransaction: Transaction, expected: CFCoreTypes.MinimalTransaction) => boolean;
    uninstallCoinBalanceIfNeeded: () => Promise<void>;
    resubmitActiveWithdrawal: () => Promise<void>;
    retryNodeSubmittedWithdrawal: () => Promise<void>;
    private appNotInstalled;
    private appInstalled;
    private checkForUserWithdrawal;
}
//# sourceMappingURL=connext.d.ts.map