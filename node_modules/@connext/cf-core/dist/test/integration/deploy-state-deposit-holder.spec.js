"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const utils_1 = require("ethers/utils");
const loglevel_1 = __importDefault(require("loglevel"));
const constants_2 = require("../../src/constants");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
loglevel_1.default.setLevel(loglevel_1.default.levels.SILENT);
describe("Node method follows spec - deploy state deposit holder", () => {
    let nodeA;
    let nodeB;
    let provider;
    let multisigAddress;
    beforeEach(async () => {
        const context = await setup_1.setup(global, true, true);
        provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        multisigAddress = await utils_2.createChannel(nodeA, nodeB);
        expect(multisigAddress).toBeDefined();
    });
    it("deploys the multisig when the method is called", async () => {
        const deployTxHash = await utils_2.deployStateDepositHolder(nodeA, multisigAddress);
        expect(deployTxHash).toBeDefined();
        expect(deployTxHash !== constants_1.HashZero).toBeTruthy();
    });
    it("cannot withdraw when multisig has not been deployed", async () => {
        const startingMultisigBalance = await provider.getBalance(multisigAddress);
        await utils_2.deposit(nodeA, multisigAddress, constants_1.One, nodeB);
        const postDepositMultisigBalance = await provider.getBalance(multisigAddress);
        expect(postDepositMultisigBalance).toBeEq(startingMultisigBalance.add(constants_1.One));
        const recipient = utils_1.getAddress(utils_1.hexlify(utils_1.randomBytes(20)));
        expect(await provider.getBalance(recipient)).toBeEq(constants_1.Zero);
        const withdrawReq = utils_2.constructWithdrawRpc(multisigAddress, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, recipient);
        expect(nodeA.rpcRouter.dispatch(withdrawReq)).rejects.toBeDefined();
    });
});
//# sourceMappingURL=deploy-state-deposit-holder.spec.js.map