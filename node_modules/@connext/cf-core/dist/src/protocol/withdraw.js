"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../constants");
const ethereum_1 = require("../ethereum");
const enums_1 = require("../machine/enums");
const models_1 = require("../models");
const types_1 = require("../types");
const signature_forwarder_1 = require("./utils/signature-forwarder");
const signature_validator_1 = require("./utils/signature-validator");
const { IO_SEND, IO_SEND_AND_WAIT, OP_SIGN, PERSIST_STATE_CHANNEL, WRITE_COMMITMENT } = enums_1.Opcode;
const { Install, Update, Withdraw } = enums_1.Protocol;
exports.WITHDRAW_PROTOCOL = {
    0: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { stateChannelsMap, message: { params, processID }, network } = context;
            const { responderXpub, multisigAddress, recipient, amount, tokenAddress } = params;
            const preInstallRefundAppStateChannel = stateChannelsMap.get(multisigAddress);
            const responderAddress = preInstallRefundAppStateChannel.getFreeBalanceAddrOf(responderXpub);
            const postInstallRefundAppStateChannel = addRefundAppToStateChannel(preInstallRefundAppStateChannel, params, network);
            const refundApp = postInstallRefundAppStateChannel.mostRecentlyInstalledAppInstance();
            const conditionalTransactionData = constructConditionalTransactionForRefundApp(network, postInstallRefundAppStateChannel);
            const mySignatureOnConditionalTransaction = yield yield __await([
                OP_SIGN,
                conditionalTransactionData
            ]);
            const { customData: { signature: counterpartySignatureOnConditionalTransaction, signature2: counterpartySignatureOnFreeBalanceStateUpdate } } = yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    params,
                    protocol: Withdraw,
                    toXpub: responderXpub,
                    customData: {
                        signature: mySignatureOnConditionalTransaction
                    },
                    seq: 1
                }
            ]);
            signature_validator_1.assertIsValidSignature(responderAddress, conditionalTransactionData, counterpartySignatureOnConditionalTransaction);
            const signedConditionalTransaction = conditionalTransactionData.getSignedTransaction([
                mySignatureOnConditionalTransaction,
                counterpartySignatureOnConditionalTransaction
            ]);
            context.stateChannelsMap.set(postInstallRefundAppStateChannel.multisigAddress, postInstallRefundAppStateChannel);
            yield yield __await([
                WRITE_COMMITMENT,
                Install,
                signedConditionalTransaction,
                refundApp.identityHash
            ]);
            const freeBalanceUpdateData = new ethereum_1.SetStateCommitment(network, postInstallRefundAppStateChannel.freeBalance.identity, postInstallRefundAppStateChannel.freeBalance.hashOfLatestState, postInstallRefundAppStateChannel.freeBalance.versionNumber, postInstallRefundAppStateChannel.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(responderAddress, freeBalanceUpdateData, counterpartySignatureOnFreeBalanceStateUpdate);
            const mySignatureOnFreeBalanceStateUpdate = yield yield __await([
                OP_SIGN,
                freeBalanceUpdateData
            ]);
            const signedFreeBalanceStateUpdate = freeBalanceUpdateData.getSignedTransaction([
                mySignatureOnFreeBalanceStateUpdate,
                counterpartySignatureOnFreeBalanceStateUpdate
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Update,
                signedFreeBalanceStateUpdate,
                postInstallRefundAppStateChannel.freeBalance.identityHash
            ]);
            const withdrawCommitment = constructWithdrawalCommitment(postInstallRefundAppStateChannel, recipient, amount, tokenAddress);
            const mySignatureOnWithdrawalCommitment = yield yield __await([
                OP_SIGN,
                withdrawCommitment
            ]);
            const { customData: { signature: counterpartySignatureOnWithdrawalCommitment, signature2: counterpartySignatureOnUninstallCommitment } } = yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    protocol: Withdraw,
                    toXpub: responderXpub,
                    customData: {
                        signature: mySignatureOnFreeBalanceStateUpdate,
                        signature2: mySignatureOnWithdrawalCommitment
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
            signature_validator_1.assertIsValidSignature(responderAddress, withdrawCommitment, counterpartySignatureOnWithdrawalCommitment);
            const postUninstallRefundAppStateChannel = postInstallRefundAppStateChannel.uninstallApp(refundApp.identityHash, {});
            context.stateChannelsMap.set(postUninstallRefundAppStateChannel.multisigAddress, postUninstallRefundAppStateChannel);
            const uninstallRefundAppCommitment = new ethereum_1.SetStateCommitment(network, postUninstallRefundAppStateChannel.freeBalance.identity, postUninstallRefundAppStateChannel.freeBalance.hashOfLatestState, postUninstallRefundAppStateChannel.freeBalance.versionNumber, postUninstallRefundAppStateChannel.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(responderAddress, uninstallRefundAppCommitment, counterpartySignatureOnUninstallCommitment);
            const mySignatureOnUninstallCommitment = yield yield __await([
                OP_SIGN,
                uninstallRefundAppCommitment
            ]);
            yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    protocol: Withdraw,
                    processID: context.message.processID,
                    toXpub: responderXpub,
                    customData: {
                        signature: mySignatureOnUninstallCommitment
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
            const signedWithdrawalCommitment = withdrawCommitment.getSignedTransaction([
                mySignatureOnWithdrawalCommitment,
                counterpartySignatureOnWithdrawalCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Withdraw,
                signedWithdrawalCommitment,
                multisigAddress
            ]);
            const signedUninstallCommitment = uninstallRefundAppCommitment.getSignedTransaction([
                mySignatureOnUninstallCommitment,
                counterpartySignatureOnUninstallCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Update,
                signedUninstallCommitment,
                postUninstallRefundAppStateChannel.freeBalance.identityHash
            ]);
            yield yield __await([PERSIST_STATE_CHANNEL, [postUninstallRefundAppStateChannel]]);
        });
    },
    1: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { stateChannelsMap, message: { params, processID, customData }, network } = context;
            const counterpartySignatureOnConditionalTransaction = customData.signature;
            const { initiatorXpub, multisigAddress, recipient, amount, tokenAddress } = params;
            const preInstallRefundAppStateChannel = stateChannelsMap.get(multisigAddress);
            const initiatorAddress = preInstallRefundAppStateChannel.getFreeBalanceAddrOf(initiatorXpub);
            const postInstallRefundAppStateChannel = addRefundAppToStateChannel(preInstallRefundAppStateChannel, params, network);
            const refundApp = postInstallRefundAppStateChannel.mostRecentlyInstalledAppInstance();
            const conditionalTransactionData = constructConditionalTransactionForRefundApp(network, postInstallRefundAppStateChannel);
            signature_validator_1.assertIsValidSignature(initiatorAddress, conditionalTransactionData, counterpartySignatureOnConditionalTransaction);
            const mySignatureOnConditionalTransaction = yield yield __await([
                OP_SIGN,
                conditionalTransactionData
            ]);
            const signedConditionalTransaction = conditionalTransactionData.getSignedTransaction([
                mySignatureOnConditionalTransaction,
                counterpartySignatureOnConditionalTransaction
            ]);
            context.stateChannelsMap.set(postInstallRefundAppStateChannel.multisigAddress, postInstallRefundAppStateChannel);
            yield yield __await([
                WRITE_COMMITMENT,
                Install,
                signedConditionalTransaction,
                refundApp.identityHash
            ]);
            const freeBalanceUpdateData = new ethereum_1.SetStateCommitment(network, postInstallRefundAppStateChannel.freeBalance.identity, postInstallRefundAppStateChannel.freeBalance.hashOfLatestState, postInstallRefundAppStateChannel.freeBalance.versionNumber, postInstallRefundAppStateChannel.freeBalance.timeout);
            const mySignatureOnFreeBalanceStateUpdate = yield yield __await([
                OP_SIGN,
                freeBalanceUpdateData
            ]);
            const { customData: { signature: counterpartySignatureOnFreeBalanceStateUpdate, signature2: counterpartySignatureOnWithdrawalCommitment } } = yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    protocol: Withdraw,
                    toXpub: initiatorXpub,
                    customData: {
                        signature: mySignatureOnConditionalTransaction,
                        signature2: mySignatureOnFreeBalanceStateUpdate
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
            signature_validator_1.assertIsValidSignature(initiatorAddress, freeBalanceUpdateData, counterpartySignatureOnFreeBalanceStateUpdate);
            const signedFreeBalanceStateUpdate = freeBalanceUpdateData.getSignedTransaction([
                mySignatureOnFreeBalanceStateUpdate,
                counterpartySignatureOnFreeBalanceStateUpdate
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Update,
                signedFreeBalanceStateUpdate,
                postInstallRefundAppStateChannel.freeBalance.identityHash
            ]);
            const withdrawCommitment = constructWithdrawalCommitment(postInstallRefundAppStateChannel, recipient, amount, tokenAddress);
            signature_validator_1.assertIsValidSignature(initiatorAddress, withdrawCommitment, counterpartySignatureOnWithdrawalCommitment);
            const mySignatureOnWithdrawalCommitment = yield yield __await([
                OP_SIGN,
                withdrawCommitment
            ]);
            const signedWithdrawalCommitment = withdrawCommitment.getSignedTransaction([
                mySignatureOnWithdrawalCommitment,
                counterpartySignatureOnWithdrawalCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Withdraw,
                signedWithdrawalCommitment,
                multisigAddress
            ]);
            const postUninstallRefundAppStateChannel = postInstallRefundAppStateChannel.uninstallApp(refundApp.identityHash, {});
            context.stateChannelsMap.set(postUninstallRefundAppStateChannel.multisigAddress, postUninstallRefundAppStateChannel);
            const uninstallRefundAppCommitment = new ethereum_1.SetStateCommitment(network, postUninstallRefundAppStateChannel.freeBalance.identity, postUninstallRefundAppStateChannel.freeBalance.hashOfLatestState, postUninstallRefundAppStateChannel.freeBalance.versionNumber, postUninstallRefundAppStateChannel.freeBalance.timeout);
            const mySignatureOnUninstallCommitment = yield yield __await([
                OP_SIGN,
                uninstallRefundAppCommitment
            ]);
            const { customData: { signature: counterpartySignatureOnUninstallCommitment } } = yield yield __await([
                IO_SEND_AND_WAIT,
                {
                    processID,
                    protocol: Withdraw,
                    toXpub: initiatorXpub,
                    customData: {
                        signature: mySignatureOnWithdrawalCommitment,
                        signature2: mySignatureOnUninstallCommitment
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
            signature_validator_1.assertIsValidSignature(initiatorAddress, uninstallRefundAppCommitment, counterpartySignatureOnUninstallCommitment);
            const signedUninstallCommitment = uninstallRefundAppCommitment.getSignedTransaction([
                mySignatureOnUninstallCommitment,
                counterpartySignatureOnUninstallCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                Update,
                signedUninstallCommitment,
                postUninstallRefundAppStateChannel.freeBalance.identityHash
            ]);
            yield yield __await([PERSIST_STATE_CHANNEL, [postUninstallRefundAppStateChannel]]);
            yield yield __await([
                IO_SEND,
                {
                    processID,
                    protocol: Withdraw,
                    toXpub: initiatorXpub,
                    customData: {
                        dataPersisted: true
                    },
                    seq: signature_forwarder_1.UNASSIGNED_SEQ_NO
                }
            ]);
        });
    }
};
function addRefundAppToStateChannel(stateChannel, params, network) {
    const { recipient, amount, multisigAddress, initiatorXpub, tokenAddress } = params;
    const defaultTimeout = 1008;
    const refundAppInstance = new models_1.AppInstance(stateChannel.getNextSigningKeys(), defaultTimeout, {
        addr: network.CoinBalanceRefundApp,
        stateEncoding: types_1.coinBalanceRefundStateEncoding,
        actionEncoding: undefined
    }, false, stateChannel.numProposedApps, {
        recipient,
        multisig: multisigAddress,
        threshold: amount
    }, 0, defaultTimeout, types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER, undefined, undefined, { tokenAddress, limit: constants_1.MaxUint256 });
    return stateChannel.installApp(refundAppInstance, {
        [tokenAddress]: {
            [stateChannel.getFreeBalanceAddrOf(initiatorXpub)]: amount
        }
    });
}
function constructConditionalTransactionForRefundApp(network, stateChannel) {
    const appInstance = stateChannel.mostRecentlyInstalledAppInstance();
    return new ethereum_1.ConditionalTransaction(network, stateChannel.multisigAddress, stateChannel.multisigOwners, appInstance.identityHash, stateChannel.freeBalance.identityHash, network.SingleAssetTwoPartyCoinTransferInterpreter, utils_1.defaultAbiCoder.encode([types_1.singleAssetTwoPartyCoinTransferInterpreterParamsEncoding], [appInstance.singleAssetTwoPartyCoinTransferInterpreterParams]));
}
function constructWithdrawalCommitment(postInstallRefundAppStateChannel, recipient, amount, tokenAddress) {
    if (tokenAddress === constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
        return new ethereum_1.WithdrawETHCommitment(postInstallRefundAppStateChannel.multisigAddress, postInstallRefundAppStateChannel.multisigOwners, recipient, amount);
    }
    return new ethereum_1.WithdrawERC20Commitment(postInstallRefundAppStateChannel.multisigAddress, postInstallRefundAppStateChannel.multisigOwners, recipient, amount, tokenAddress);
}
//# sourceMappingURL=withdraw.js.map