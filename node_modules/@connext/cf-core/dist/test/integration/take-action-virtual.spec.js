"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const src_1 = require("../../src");
const setup_1 = require("./setup");
const tic_tac_toe_1 = require("./tic-tac-toe");
const utils_1 = require("./utils");
jest.setTimeout(15000);
const { TicTacToeApp } = global["networkContext"];
function confirmMessages(initiator, responder, expectedData) {
    const expected = {
        from: initiator.publicIdentifier,
        type: "UPDATE_STATE_EVENT",
        data: expectedData,
    };
    responder.once("UPDATE_STATE_EVENT", (msg) => {
        utils_1.assertNodeMessage(msg, expected);
    });
}
describe("Node method follows spec - takeAction virtual", () => {
    let nodeA;
    let nodeB;
    let nodeC;
    beforeAll(async () => {
        const context = await setup_1.setup(global, true);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        nodeC = context["C"].node;
    });
    describe("Node A and C install an AppInstance via Node B, Node A takes action, " +
        "Node C confirms receipt of state update", () => {
        it("sends takeAction with invalid appInstanceId", async () => {
            const takeActionReq = utils_1.constructTakeActionRpc("", tic_tac_toe_1.validAction);
            await expect(nodeA.rpcRouter.dispatch(takeActionReq)).rejects.toThrowError(src_1.NO_APP_INSTANCE_FOR_TAKE_ACTION);
        });
        it("can take action", async (done) => {
            const multisigAddressAB = await utils_1.createChannel(nodeA, nodeB);
            const multisigAddressBC = await utils_1.createChannel(nodeB, nodeC);
            await utils_1.collateralizeChannel(multisigAddressAB, nodeA, nodeB);
            await utils_1.collateralizeChannel(multisigAddressBC, nodeB, nodeC);
            const appInstanceId = await utils_1.installVirtualApp(nodeA, nodeB, nodeC, TicTacToeApp);
            const expectedNewState = {
                board: [[constants_1.One, constants_1.Zero, constants_1.Zero], [constants_1.Zero, constants_1.Zero, constants_1.Zero], [constants_1.Zero, constants_1.Zero, constants_1.Zero]],
                versionNumber: constants_1.One,
                winner: constants_1.Zero
            };
            nodeC.once("UPDATE_STATE_EVENT", async () => {
                const req = utils_1.constructGetStateRpc(appInstanceId);
                const { result: { result: { state: nodeCState } } } = await nodeC.rpcRouter.dispatch(req);
                expect(nodeCState).toEqual(expectedNewState);
                const { result: { result: { state: nodeAState } } } = await nodeA.rpcRouter.dispatch(req);
                expect(nodeAState).toEqual(expectedNewState);
                done();
            });
            confirmMessages(nodeA, nodeC, {
                newState: expectedNewState,
                appInstanceId,
                action: tic_tac_toe_1.validAction,
            });
            const takeActionReq = utils_1.constructTakeActionRpc(appInstanceId, tic_tac_toe_1.validAction);
            const { result: { result: { newState } } } = await nodeA.rpcRouter.dispatch(takeActionReq);
            expect(newState).toEqual(expectedNewState);
        });
    });
});
//# sourceMappingURL=take-action-virtual.spec.js.map