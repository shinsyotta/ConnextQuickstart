"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const loglevel_1 = __importDefault(require("loglevel"));
const typescript_memoize_1 = require("typescript-memoize");
const api_1 = require("./api");
const auto_nonce_wallet_1 = __importDefault(require("./auto-nonce-wallet"));
const deferred_1 = require("./deferred");
const machine_1 = require("./machine");
const free_balance_1 = require("./models/free-balance");
const private_keys_generator_1 = require("./private-keys-generator");
const process_queue_1 = __importDefault(require("./process-queue"));
const request_handler_1 = require("./request-handler");
const types_1 = require("./types");
const utils_2 = require("./utils");
const constants_1 = require("./constants");
const REASONABLE_NUM_BLOCKS_TO_WAIT = 1;
class Node {
    constructor(publicExtendedKey, privateKeyGetter, messagingService, storeService, nodeConfig, provider, networkContext, blocksNeededForConfirmation = REASONABLE_NUM_BLOCKS_TO_WAIT, lockService) {
        this.publicExtendedKey = publicExtendedKey;
        this.privateKeyGetter = privateKeyGetter;
        this.messagingService = messagingService;
        this.storeService = storeService;
        this.nodeConfig = nodeConfig;
        this.provider = provider;
        this.networkContext = networkContext;
        this.blocksNeededForConfirmation = blocksNeededForConfirmation;
        this.lockService = lockService;
        this.ioSendDeferrals = new Map();
        this.networkContext.provider = this.provider;
        this.incoming = new eventemitter3_1.default();
        this.outgoing = new eventemitter3_1.default();
        this.protocolRunner = this.buildProtocolRunner();
        loglevel_1.default.info(`Waiting for ${this.blocksNeededForConfirmation} block confirmations`);
    }
    static async create(messagingService, storeService, networkContext, nodeConfig, provider, lockService, publicExtendedKey, privateKeyGenerator, blocksNeededForConfirmation) {
        const [privateKeysGenerator, extendedPubKey] = await private_keys_generator_1.getPrivateKeysGeneratorAndXPubOrThrow(storeService, privateKeyGenerator, publicExtendedKey);
        const node = new Node(extendedPubKey, privateKeysGenerator, messagingService, storeService, nodeConfig, provider, networkContext, blocksNeededForConfirmation, lockService);
        return await node.asynchronouslySetupUsingRemoteServices();
    }
    async asynchronouslySetupUsingRemoteServices() {
        this.signer = new utils_1.SigningKey(await this.privateKeyGetter.getPrivateKey("0"));
        loglevel_1.default.info(`Node signer address: ${this.signer.address}`);
        loglevel_1.default.info(`Node public identifier: ${this.publicIdentifier}`);
        this.requestHandler = new request_handler_1.RequestHandler(this.publicIdentifier, this.incoming, this.outgoing, this.storeService, this.messagingService, this.protocolRunner, this.networkContext, this.provider, new auto_nonce_wallet_1.default(this.signer.privateKey, this.provider), `${this.nodeConfig.STORE_KEY_PREFIX}/${this.publicIdentifier}`, this.blocksNeededForConfirmation, new process_queue_1.default(this.lockService));
        this.registerMessagingConnection();
        this.rpcRouter = api_1.createRpcRouter(this.requestHandler);
        this.requestHandler.injectRouter(this.rpcRouter);
        return this;
    }
    get publicIdentifier() {
        return this.publicExtendedKey;
    }
    async signerAddress() {
        return await this.requestHandler.getSignerAddress();
    }
    get freeBalanceAddress() {
        return free_balance_1.getFreeBalanceAddress(this.publicIdentifier);
    }
    buildProtocolRunner() {
        const protocolRunner = new machine_1.ProtocolRunner(this.networkContext, this.provider);
        protocolRunner.register(machine_1.Opcode.OP_SIGN, async (args) => {
            if (args.length !== 1 && args.length !== 2) {
                throw Error("OP_SIGN middleware received wrong number of arguments.");
            }
            const [commitment, overrideKeyIndex] = args;
            const keyIndex = overrideKeyIndex || 0;
            const signingKey = new utils_1.SigningKey(await this.privateKeyGetter.getPrivateKey(keyIndex));
            return signingKey.signDigest(commitment.hashToSign());
        });
        protocolRunner.register(machine_1.Opcode.IO_SEND, async (args) => {
            const [data] = args;
            const fromXpub = this.publicIdentifier;
            const to = data.toXpub;
            await this.messagingService.send(to, {
                data,
                from: fromXpub,
                type: types_1.NODE_EVENTS.PROTOCOL_MESSAGE_EVENT
            });
        });
        protocolRunner.register(machine_1.Opcode.IO_SEND_AND_WAIT, async (args) => {
            const [data] = args;
            const to = data.toXpub;
            const deferral = new deferred_1.Deferred();
            this.ioSendDeferrals.set(data.processID, deferral);
            const counterpartyResponse = deferral.promise;
            await this.messagingService.send(to, {
                data,
                from: this.publicIdentifier,
                type: types_1.NODE_EVENTS.PROTOCOL_MESSAGE_EVENT
            });
            const msg = await Promise.race([
                counterpartyResponse,
                utils_2.timeout(constants_1.IO_SEND_AND_WAIT_TIMEOUT)
            ]);
            if (!msg || !("data" in msg)) {
                throw Error(`IO_SEND_AND_WAIT timed out after 90s waiting for counterparty reply in ${data.protocol}`);
            }
            this.ioSendDeferrals.delete(data.processID);
            return msg.data;
        });
        protocolRunner.register(machine_1.Opcode.WRITE_COMMITMENT, async (args) => {
            const { store } = this.requestHandler;
            const [protocol, commitment, ...key] = args;
            if (protocol === machine_1.Protocol.Withdraw) {
                const [multisigAddress] = key;
                await store.storeWithdrawalCommitment(multisigAddress, commitment);
            }
            else {
                await store.setCommitment([protocol, ...key], commitment);
            }
        });
        protocolRunner.register(machine_1.Opcode.PERSIST_STATE_CHANNEL, async (args) => {
            const { store } = this.requestHandler;
            const [stateChannels] = args;
            for (const stateChannel of stateChannels) {
                await store.saveStateChannel(stateChannel);
            }
        });
        return protocolRunner;
    }
    on(event, callback) {
        this.rpcRouter.subscribe(event, async (res) => callback(res));
    }
    off(event, callback) {
        this.rpcRouter.unsubscribe(event, callback ? async (res) => callback(res) : undefined);
    }
    once(event, callback) {
        this.rpcRouter.subscribeOnce(event, async (res) => callback(res));
    }
    emit(event, req) {
        this.rpcRouter.emit(event, req);
    }
    async call(method, req) {
        return this.requestHandler.callMethod(method, req);
    }
    registerMessagingConnection() {
        this.messagingService.onReceive(this.publicIdentifier, async (msg) => {
            await this.handleReceivedMessage(msg);
            this.rpcRouter.emit(msg.type, msg, "outgoing");
        });
    }
    async handleReceivedMessage(msg) {
        if (!Object.values(types_1.NODE_EVENTS).includes(msg.type)) {
            console.error(`Received message with unknown event type: ${msg.type}`);
        }
        const isProtocolMessage = (msg) => msg.type === types_1.NODE_EVENTS.PROTOCOL_MESSAGE_EVENT;
        const isExpectingResponse = (msg) => this.ioSendDeferrals.has(msg.data.processID);
        if (isProtocolMessage(msg) &&
            isExpectingResponse(msg)) {
            await this.handleIoSendDeferral(msg);
        }
        else if (this.requestHandler.isLegacyEvent(msg.type)) {
            await this.requestHandler.callEvent(msg.type, msg);
        }
        else {
            await this.rpcRouter.emit(msg.type, msg);
        }
    }
    async handleIoSendDeferral(msg) {
        const key = msg.data.processID;
        if (!this.ioSendDeferrals.has(key)) {
            throw Error("Node received message intended for machine but no handler was present");
        }
        const promise = this.ioSendDeferrals.get(key);
        try {
            promise.resolve(msg);
        }
        catch (error) {
            console.error(`Error while executing callback registered by IO_SEND_AND_WAIT middleware hook`, { error, msg });
        }
    }
}
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], Node.prototype, "publicIdentifier", null);
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Node.prototype, "signerAddress", null);
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [])
], Node.prototype, "freeBalanceAddress", null);
exports.Node = Node;
//# sourceMappingURL=node.js.map