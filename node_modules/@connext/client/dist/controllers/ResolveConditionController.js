"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const lib_1 = require("../lib");
const AbstractController_1 = require("./AbstractController");
class ResolveConditionController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.resolve = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Resolve condition called with parameters: ${lib_1.stringify(params)}`);
            const res = yield this.conditionResolvers[params.conditionType](params);
            return res;
        });
        this.resolveLinkedTransfer = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Resolving link: ${lib_1.stringify(params)}`);
            const { assetId, amount } = yield this.node.fetchLinkedTransfer(params.paymentId);
            const amountBN = utils_1.bigNumberify(amount);
            this.log.info(`Found link payment for ${amountBN.toString()} ${assetId}`);
            const freeBal = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBal[this.connext.freeBalanceAddress];
            const { paymentId, preImage } = params;
            yield this.node.resolveLinkedTransfer(paymentId, preImage);
            const postTransferBal = yield this.connext.getFreeBalance(assetId);
            const diff = postTransferBal[this.connext.freeBalanceAddress].sub(preTransferBal);
            if (!diff.eq(amountBN)) {
                this.log.error("Welp it appears the difference of the free balance before and after " +
                    "uninstalling is not what we expected......");
            }
            else if (postTransferBal[this.connext.freeBalanceAddress].lte(preTransferBal)) {
                this.log.info("Free balance after transfer is lte free balance " +
                    "before transfer..... That's not great..");
            }
            return {
                freeBalance: yield this.connext.getFreeBalance(assetId),
                paymentId,
            };
        });
        this.resolveLinkedTransferToRecipient = (params) => __awaiter(this, void 0, void 0, function* () {
            const { paymentId, preImage } = params;
            this.connext.emit("RECIEVE_TRANSFER_STARTED_EVENT", { paymentId });
            const { assetId, amount } = yield this.node.fetchLinkedTransfer(params.paymentId);
            const amountBN = utils_1.bigNumberify(amount);
            this.log.info(`Found link payment for ${amountBN.toString()} ${assetId}`);
            const freeBal = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBal[this.connext.freeBalanceAddress];
            try {
                yield this.node.resolveLinkedTransfer(paymentId, preImage);
            }
            catch (e) {
                this.log.error(`Failed to resolve linked transfer ${paymentId}: ${e.stack || e.message}`);
                this.connext.emit("RECIEVE_TRANSFER_FAILED_EVENT", { paymentId });
                throw e;
            }
            const postTransferBal = yield this.connext.getFreeBalance(assetId);
            const diff = postTransferBal[this.connext.freeBalanceAddress].sub(preTransferBal);
            if (!diff.eq(amountBN)) {
                this.log.error("Welp it appears the difference of the free balance before and after " +
                    "uninstalling is not what we expected......");
            }
            else if (postTransferBal[this.connext.freeBalanceAddress].lte(preTransferBal)) {
                this.log.warn("Free balance after transfer is lte free balance " +
                    "before transfer..... That's not great..");
            }
            this.connext.emit("RECIEVE_TRANSFER_FINISHED_EVENT", { paymentId });
            return {
                freeBalance: yield this.connext.getFreeBalance(assetId),
                paymentId,
            };
        });
        this.conditionResolvers = {
            LINKED_TRANSFER: this.resolveLinkedTransfer,
            LINKED_TRANSFER_TO_RECIPIENT: this.resolveLinkedTransferToRecipient,
        };
    }
}
exports.ResolveConditionController = ResolveConditionController;
//# sourceMappingURL=ResolveConditionController.js.map