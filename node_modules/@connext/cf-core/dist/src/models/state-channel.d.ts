import { SingleAssetTwoPartyIntermediaryAgreement, StateChannelJSON } from "@connext/types";
import { BigNumber } from "ethers/utils";
import { Store } from "../store";
import { SolidityValueType } from "../types";
import { AppInstanceProposal } from ".";
import { AppInstance } from "./app-instance";
import { CoinTransferMap, FreeBalanceClass, TokenIndexedCoinTransferMap } from "./free-balance";
export declare const HARD_CODED_ASSUMPTIONS: {
    freeBalanceDefaultTimeout: number;
};
export declare class StateChannel {
    readonly multisigAddress: string;
    readonly proxyFactoryAddress: string;
    readonly userNeuteredExtendedKeys: string[];
    readonly proposedAppInstances: ReadonlyMap<string, AppInstanceProposal>;
    readonly appInstances: ReadonlyMap<string, AppInstance>;
    readonly singleAssetTwoPartyIntermediaryAgreements: ReadonlyMap<string, SingleAssetTwoPartyIntermediaryAgreement>;
    private readonly freeBalanceAppInstance?;
    private readonly monotonicNumProposedApps;
    constructor(multisigAddress: string, proxyFactoryAddress: string, userNeuteredExtendedKeys: string[], proposedAppInstances?: ReadonlyMap<string, AppInstanceProposal>, appInstances?: ReadonlyMap<string, AppInstance>, singleAssetTwoPartyIntermediaryAgreements?: ReadonlyMap<string, SingleAssetTwoPartyIntermediaryAgreement>, freeBalanceAppInstance?: AppInstance | undefined, monotonicNumProposedApps?: number);
    readonly multisigOwners: string[];
    readonly numProposedApps: number;
    readonly numActiveApps: number;
    getAppInstance(appInstanceIdentityHash: string): AppInstance;
    hasAppInstance(appInstanceId: string): boolean;
    hasAppInstanceOfKind(address: string): boolean;
    mostRecentlyInstalledAppInstance(): AppInstance;
    mostRecentlyProposedAppInstance(): AppInstanceProposal;
    getAppInstanceOfKind(address: string): AppInstance;
    getAppInstancesOfKind(address: string): AppInstance[];
    hasBalanceRefundAppInstance(balanceRefundAppDefinitionAddress: string, tokenAddress: string): boolean;
    hasProposedBalanceRefundAppInstance(balanceRefundAppDefinitionAddress: string, tokenAddress: string): boolean;
    getBalanceRefundAppInstance(balanceRefundAppDefinitionAddress: string, tokenAddress?: string): AppInstance;
    isAppInstanceInstalled(appInstanceIdentityHash: string): boolean;
    getSigningKeysFor(addressIndex: number): string[];
    getNextSigningKeys(): string[];
    readonly hasFreeBalance: boolean;
    readonly freeBalance: AppInstance;
    getMultisigOwnerAddrOf(xpub: string): string;
    getFreeBalanceAddrOf(xpub: string): string;
    getFreeBalanceClass(): FreeBalanceClass;
    private build;
    incrementFreeBalance(increments: TokenIndexedCoinTransferMap): StateChannel;
    addActiveApp(activeApp: string): StateChannel;
    removeActiveApp(activeApp: string): StateChannel;
    addActiveAppAndIncrementFreeBalance(activeApp: string, tokenIndexedIncrements: TokenIndexedCoinTransferMap): StateChannel;
    removeActiveAppAndIncrementFreeBalance(activeApp: string, tokenIndexedIncrements: TokenIndexedCoinTransferMap): StateChannel;
    setFreeBalance(newFreeBalanceClass: FreeBalanceClass): StateChannel;
    static setupChannel(freeBalanceAppAddress: string, proxyFactoryAddress: string, multisigAddress: string, userNeuteredExtendedKeys: string[], freeBalanceTimeout?: number): StateChannel;
    static createEmptyChannel(multisigAddress: string, proxyFactoryAddress: string, userNeuteredExtendedKeys: string[]): StateChannel;
    addProposal(proposal: AppInstanceProposal): StateChannel;
    removeProposal(appInstanceId: string): StateChannel;
    addAppInstance(appInstance: AppInstance): StateChannel;
    removeAppInstance(appInstanceId: string): StateChannel;
    setState(appInstanceIdentityHash: string, state: SolidityValueType): StateChannel;
    addSingleAssetTwoPartyIntermediaryAgreement(targetIdentityHash: string, agreement: SingleAssetTwoPartyIntermediaryAgreement, decrements: CoinTransferMap, tokenAddress: string): StateChannel;
    removeSingleAssetTwoPartyIntermediaryAgreement(targetIdentityHash: string, increments: {
        [addr: string]: BigNumber;
    }, tokenAddress: string): StateChannel;
    installApp(appInstance: AppInstance, tokenIndexedDecrements: TokenIndexedCoinTransferMap): StateChannel;
    uninstallApp(appInstanceIdentityHash: string, tokenIndexedIncrements: TokenIndexedCoinTransferMap): StateChannel;
    getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(key: string): SingleAssetTwoPartyIntermediaryAgreement;
    toJson(): StateChannelJSON;
    static fromJson(json: StateChannelJSON): StateChannel;
    static getPeersAddressFromChannel(myIdentifier: string, store: Store, multisigAddress: string): Promise<string[]>;
    static getPeersAddressFromAppInstanceID(myIdentifier: string, store: Store, appInstanceId: string): Promise<string[]>;
}
//# sourceMappingURL=state-channel.d.ts.map