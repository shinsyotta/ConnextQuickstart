"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/utils");
const lib_1 = require("./lib");
const types_1 = require("./types");
class ChannelRouter {
    constructor(connection, config, store, authKey) {
        this._multisigAddress = undefined;
        this._signerAddress = undefined;
        this.on = (event, listener) => {
            this.connection.on(event, listener);
            return this.connection;
        };
        this.once = (event, listener) => {
            this.connection.once(event, listener);
            return this.connection;
        };
        this.signMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            switch (this.type) {
                case types_1.RpcType.CounterfactualNode:
                    if (!this.wallet) {
                        throw new Error(`Cannot sign without a wallet when using smart client`);
                    }
                    return yield this.wallet.signMessage(utils_1.arrayify(message));
                case types_1.RpcType.ChannelProvider:
                    return yield this._send("chan_node_auth", { message });
                default:
                    throw new Error(`Unrecognized RpcType: ${this.type}. (How'd you even get this far tho...)`);
            }
        });
        this.deposit = (amount, assetId, multisigAddress, notifyCounterparty = false) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.DEPOSIT, {
                amount,
                multisigAddress,
                notifyCounterparty,
                tokenAddress: types_1.makeChecksum(assetId),
            });
        });
        this.getStateChannel = () => __awaiter(this, void 0, void 0, function* () {
            return yield this._send("chan_getStateChannel", {
                multisigAddress: this.multisigAddress,
            });
        });
        this.getState = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_STATE, {
                appInstanceId,
            });
        });
        this.getAppInstances = (multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_APP_INSTANCES, {
                multisigAddress,
            });
        });
        this.getFreeBalance = (assetId, multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_FREE_BALANCE_STATE, {
                multisigAddress,
                tokenAddress: types_1.makeChecksum(assetId),
            });
        });
        this.getProposedAppInstances = (multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_PROPOSED_APP_INSTANCES, {
                multisigAddress,
            });
        });
        this.getProposedAppInstance = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_PROPOSED_APP_INSTANCES, {
                appInstanceId,
            });
        });
        this.getAppInstanceDetails = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_APP_INSTANCE_DETAILS, {
                appInstanceId,
            });
        });
        this.getAppState = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.GET_STATE, {
                appInstanceId,
            });
        });
        this.takeAction = (appInstanceId, action) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.TAKE_ACTION, {
                action,
                appInstanceId,
            });
        });
        this.updateState = (appInstanceId, newState) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.UPDATE_STATE, {
                appInstanceId,
                newState,
            });
        });
        this.proposeInstallApp = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.PROPOSE_INSTALL, params);
        });
        this.installVirtualApp = (appInstanceId, intermediaryIdentifier) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.INSTALL_VIRTUAL, {
                appInstanceId,
                intermediaryIdentifier,
            });
        });
        this.installApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.INSTALL, {
                appInstanceId,
            });
        });
        this.requestDepositRights = (assetId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.REQUEST_DEPOSIT_RIGHTS, {
                multisigAddress: this.multisigAddress,
                tokenAddress: assetId,
            });
        });
        this.uninstallApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.UNINSTALL, {
                appInstanceId,
            });
        });
        this.rescindDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.RESCIND_DEPOSIT_RIGHTS, {
                multisigAddress: this.multisigAddress,
                tokenAddress: params.assetId,
            });
        });
        this.uninstallVirtualApp = (appInstanceId, intermediary) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.UNINSTALL_VIRTUAL, {
                appInstanceId,
                intermediaryIdentifier: intermediary,
            });
        });
        this.rejectInstallApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.REJECT_INSTALL, { appInstanceId });
        });
        this.withdraw = (amount, assetId, recipient) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.WITHDRAW, {
                amount,
                multisigAddress: this.multisigAddress,
                recipient,
                tokenAddress: types_1.makeChecksum(assetId),
            });
        });
        this.withdrawCommitment = (amount, assetId, recipient) => __awaiter(this, void 0, void 0, function* () {
            return yield this._send(types_1.CFCoreTypes.RpcMethodName.WITHDRAW_COMMITMENT, {
                amount,
                multisigAddress: this.multisigAddress,
                recipient,
                tokenAddress: types_1.makeChecksumOrEthAddress(assetId),
            });
        });
        this.get = (path) => __awaiter(this, void 0, void 0, function* () {
            this.isApprovedGetSetPath(path);
            switch (this.type) {
                case types_1.RpcType.CounterfactualNode:
                    if (!this.store) {
                        throw new Error(`Should have a defined store ref when provider type is a counterfactual node.`);
                    }
                    return yield this.store.get(path);
                case types_1.RpcType.ChannelProvider:
                    return yield this.connection._send("chan_store_get", {
                        path,
                    });
                default:
                    throw new Error(`Unrecognized RpcType: ${this.type}. (How'd you even get this far tho...)`);
            }
        });
        this.set = (pairs, allowDelete) => __awaiter(this, void 0, void 0, function* () {
            pairs.forEach(({ path, value }) => {
                this.isApprovedGetSetPath(path);
            });
            switch (this.type) {
                case types_1.RpcType.CounterfactualNode:
                    if (!this.store) {
                        throw new Error(`Should have a defined store ref when provider type is a counterfactual node.`);
                    }
                    return yield this.store.set(pairs, allowDelete);
                case types_1.RpcType.ChannelProvider:
                    return yield this.connection._send("chan_store_set", {
                        allowDelete,
                        pairs,
                    });
                default:
                    throw new Error(`Unrecognized RpcType: ${this.type}. (How'd you even get this far tho...)`);
            }
        });
        this.restore = () => __awaiter(this, void 0, void 0, function* () {
            switch (this.type) {
                case types_1.RpcType.CounterfactualNode:
                    if (!this.store) {
                        throw new Error(`Should have a defined store ref when provider type is a counterfactual node.`);
                    }
                    return yield this.store.restore();
                case types_1.RpcType.ChannelProvider:
                    throw new Error(`Cannot restore store with channel provider instantiation. Please contact original wallet provider.`);
                default:
                    throw new Error(`Unrecognized RpcType: ${this.type}. (How'd you even get this far tho...)`);
            }
        });
        this.reset = () => __awaiter(this, void 0, void 0, function* () {
            switch (this.type) {
                case types_1.RpcType.CounterfactualNode:
                    if (!this.store) {
                        throw new Error(`Should have a defined store ref when provider type is a counterfactual node.`);
                    }
                    return yield this.store.reset();
                case types_1.RpcType.ChannelProvider:
                    throw new Error(`Cannot restore store with channel provider instantiation. Please contact original wallet provider.`);
                default:
                    throw new Error(`Unrecognized RpcType: ${this.type}. (How'd you even get this far tho...)`);
            }
        });
        this.type = config.type;
        this.store = store;
        this.wallet = authKey ? new ethers_1.Wallet(authKey) : null;
        this.connection = connection;
        this._config = config;
        this._multisigAddress = config.multisigAddress;
        this._signerAddress = config.signerAddress;
        this.approvedStorePaths = [
            lib_1.withdrawalKey(this.config.userPublicIdentifier),
        ];
    }
    get config() {
        return this._config;
    }
    get multisigAddress() {
        return this._multisigAddress;
    }
    set multisigAddress(multisigAddress) {
        this._multisigAddress = multisigAddress;
    }
    get signerAddress() {
        return this._signerAddress;
    }
    set signerAddress(signerAddress) {
        this._signerAddress = signerAddress;
    }
    isApprovedGetSetPath(path) {
        if (this.type === types_1.RpcType.CounterfactualNode) {
            return;
        }
        if (this.approvedStorePaths.indexOf(path) === -1) {
            throw new Error(`Not an approved store path to get/set: ${path}`);
        }
    }
    _send(methodName, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            switch (this.type) {
                case types_1.RpcType.CounterfactualNode:
                    const ret = yield this.connection.rpcRouter.dispatch({
                        id: Date.now(),
                        methodName,
                        parameters,
                    });
                    result = ret.result.result;
                    break;
                case types_1.RpcType.ChannelProvider:
                    result = yield this.connection._send(methodName, parameters);
                    break;
                default:
                    throw new Error(`Unknown rpc type: ${this.type}`);
            }
            return result;
        });
    }
}
exports.ChannelRouter = ChannelRouter;
//# sourceMappingURL=channelRouter.js.map