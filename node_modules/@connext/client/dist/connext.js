"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const messaging_1 = require("@connext/messaging");
const types_1 = require("@connext/types");
require("core-js/stable");
const eth_crypto_1 = __importDefault(require("eth-crypto"));
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const hdnode_1 = require("ethers/utils/hdnode");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
require("regenerator-runtime/runtime");
const channelRouter_1 = require("./channelRouter");
const ConditionalTransferController_1 = require("./controllers/ConditionalTransferController");
const DepositController_1 = require("./controllers/DepositController");
const RequestDepositRightsController_1 = require("./controllers/RequestDepositRightsController");
const ResolveConditionController_1 = require("./controllers/ResolveConditionController");
const SwapController_1 = require("./controllers/SwapController");
const TransferController_1 = require("./controllers/TransferController");
const WithdrawalController_1 = require("./controllers/WithdrawalController");
const lib_1 = require("./lib");
const listener_1 = require("./listener");
const node_1 = require("./node");
const types_2 = require("./types");
const addresses_1 = require("./validation/addresses");
const bn_1 = require("./validation/bn");
const MAX_WITHDRAWAL_RETRIES = 3;
exports.connect = (opts) => __awaiter(this, void 0, void 0, function* () {
    const { logLevel, ethProviderUrl, mnemonic, nodeUrl, store, channelProvider } = opts;
    const log = new lib_1.Logger("ConnextConnect", logLevel);
    let channelProviderConfig;
    let xpub;
    let keyGen;
    if (mnemonic) {
        const hdNode = hdnode_1.fromExtendedKey(hdnode_1.fromMnemonic(mnemonic).extendedKey).derivePath(types_1.CF_PATH);
        xpub = hdNode.neuter().extendedKey;
        keyGen = (index) => Promise.resolve(hdNode.derivePath(index).privateKey);
        channelProviderConfig = {
            freeBalanceAddress: lib_1.xpubToAddress(xpub),
            nodeUrl,
            signerAddress: lib_1.xpubToAddress(xpub),
            type: types_2.RpcType.CounterfactualNode,
            userPublicIdentifier: xpub,
        };
    }
    else if (channelProvider) {
        yield channelProvider.enable();
        channelProviderConfig = Object.assign({}, channelProvider.config, { type: types_2.RpcType.ChannelProvider });
    }
    else if (opts.xpub && opts.keyGen) {
        xpub = opts.xpub;
        keyGen = opts.keyGen;
        channelProviderConfig = {
            freeBalanceAddress: lib_1.xpubToAddress(xpub),
            nodeUrl,
            signerAddress: lib_1.xpubToAddress(xpub),
            type: types_2.RpcType.CounterfactualNode,
            userPublicIdentifier: xpub,
        };
    }
    else {
        throw new Error(`Client must be instantiated with xpub and keygen, or a channel provider if not using mnemonic`);
    }
    log.debug(`Using channel provider config: ${lib_1.stringify(channelProviderConfig)}`);
    const ethProvider = new ethers_1.providers.JsonRpcProvider(ethProviderUrl);
    const network = yield ethProvider.getNetwork();
    if (network.chainId === 4447) {
        network.name = "ganache";
        ethProvider.getSigner = (addressOrIndex) => {
            throw { code: "UNSUPPORTED_OPERATION" };
        };
    }
    log.debug(`Creating messaging service client (logLevel: ${logLevel})`);
    const messagingFactory = new messaging_1.MessagingServiceFactory({
        logLevel,
        messagingUrl: channelProviderConfig.nodeUrl,
    });
    const messaging = messagingFactory.createService("messaging");
    yield messaging.connect();
    const node = new node_1.NodeApiClient({ logLevel, messaging });
    const config = yield node.config();
    log.debug(`Node provided config: ${lib_1.stringify(config)}`);
    let channelRouter;
    switch (channelProviderConfig.type) {
        case types_2.RpcType.ChannelProvider:
            channelRouter = new channelRouter_1.ChannelRouter(channelProvider, channelProviderConfig);
            break;
        case types_2.RpcType.CounterfactualNode:
            const cfCore = yield lib_1.CFCore.create(messaging, store, config.contractAddresses, { STORE_KEY_PREFIX: types_2.ConnextClientStorePrefix }, ethProvider, { acquireLock: node.acquireLock.bind(node) }, xpub, keyGen);
            channelRouter = new channelRouter_1.ChannelRouter(cfCore, channelProviderConfig, store, yield keyGen("0"));
            break;
        default:
            throw new Error(`Unrecognized channel provider type: ${channelProviderConfig.type}`);
    }
    node.channelRouter = channelRouter;
    node.userPublicIdentifier = channelProviderConfig.userPublicIdentifier;
    node.nodePublicIdentifier = config.nodePublicIdentifier;
    const myChannel = yield node.getChannel();
    let multisigAddress;
    if (!myChannel) {
        log.debug("no channel detected, creating channel..");
        const creationEventData = yield new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            const timer = setTimeout(() => rej("Create channel event not fired within 30s"), 30000);
            channelRouter.once(types_2.CFCoreTypes.EventNames.CREATE_CHANNEL_EVENT, (data) => {
                clearTimeout(timer);
                res(data.data);
            });
            const creationData = yield node.createChannel();
            log.debug(`created channel, transaction: ${lib_1.stringify(creationData)}`);
        }));
        multisigAddress = creationEventData.multisigAddress;
    }
    else {
        multisigAddress = myChannel.multisigAddress;
    }
    log.debug(`multisigAddress: ${multisigAddress}`);
    channelRouter.multisigAddress = multisigAddress;
    const token = new ethers_1.Contract(config.contractAddresses.Token, human_standard_token_abi_1.default, ethProvider);
    const client = new ConnextClient(Object.assign({ appRegistry: yield node.appRegistry(), channelRouter,
        config,
        ethProvider,
        keyGen,
        messaging,
        multisigAddress,
        network,
        node,
        store,
        token }, opts));
    try {
        yield client.getFreeBalance();
    }
    catch (e) {
        if (e.message.includes(`StateChannel does not exist yet`)) {
            log.debug(`Restoring client state: ${e}`);
            yield client.restoreState();
        }
        else {
            throw e;
        }
    }
    log.debug("Registering subscriptions");
    yield client.registerSubscriptions();
    yield client.uninstallCoinBalanceIfNeeded(constants_1.AddressZero);
    yield client.uninstallCoinBalanceIfNeeded(config.contractAddresses.Token);
    log.debug("Resubmitting active withdrawals");
    yield client.resubmitActiveWithdrawal();
    log.debug("Reclaiming pending async transfers");
    yield client.reclaimPendingAsyncTransfers();
    log.debug("Done creating channel client");
    return client;
});
class ConnextClient {
    constructor(opts) {
        this.isAvailable = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const channelIsAvailable = () => __awaiter(this, void 0, void 0, function* () {
                    const chan = yield this.node.getChannel();
                    return chan && chan.available;
                });
                while (!(yield channelIsAvailable())) {
                    yield new Promise((res) => setTimeout(() => res(), 100));
                }
                resolve();
            }));
        });
        this.getBalanceRefundApp = (assetId = constants_1.AddressZero) => __awaiter(this, void 0, void 0, function* () {
            const apps = yield this.getAppInstances(this.multisigAddress);
            const filtered = apps.filter((app) => app.appInterface.addr === this.config.contractAddresses.CoinBalanceRefundApp &&
                app.latestState["tokenAddress"] === assetId);
            return filtered.length === 0 ? undefined : filtered[0];
        });
        this.registerSubscriptions = () => __awaiter(this, void 0, void 0, function* () {
            yield this.listener.register();
        });
        this.restart = () => __awaiter(this, void 0, void 0, function* () {
            let channelRouter;
            switch (this.routerType) {
                case types_2.RpcType.ChannelProvider:
                    channelRouter = new channelRouter_1.ChannelRouter(this.opts.channelProvider, this.channelRouter.config);
                    break;
                case types_2.RpcType.CounterfactualNode:
                    const cfCore = yield lib_1.CFCore.create(this.messaging, this.store, this.config.contractAddresses, { STORE_KEY_PREFIX: types_2.ConnextClientStorePrefix }, this.ethProvider, { acquireLock: this.node.acquireLock.bind(this.node) }, this.publicIdentifier, this.keyGen);
                    channelRouter = new channelRouter_1.ChannelRouter(cfCore, this.channelRouter.config, this.store, yield this.keyGen("0"));
                    break;
                default:
                    throw new Error(`Unrecognized channel provider type: ${this.routerType}`);
            }
            channelRouter.multisigAddress = this.multisigAddress;
            this.node.channelRouter = channelRouter;
            this.channelRouter = channelRouter;
            this.listener = new listener_1.ConnextListener(channelRouter, this);
            yield this.isAvailable();
        });
        this.getChannel = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getChannel();
        });
        this.requestCollateral = (tokenAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.requestCollateral(tokenAddress);
        });
        this.setRecipientAndEncryptedPreImageForLinkedTransfer = (recipient, encryptedPreImage, linkedHash) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.setRecipientAndEncryptedPreImageForLinkedTransfer(recipient, encryptedPreImage, linkedHash);
        });
        this.channelProviderConfig = () => __awaiter(this, void 0, void 0, function* () {
            return this.channelRouter.config;
        });
        this.getLinkedTransfer = (paymentId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.fetchLinkedTransfer(paymentId);
        });
        this.getAppRegistry = (appDetails) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.appRegistry(appDetails);
        });
        this.createChannel = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.createChannel();
        });
        this.subscribeToSwapRates = (from, to, callback) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.subscribeToSwapRates(from, to, callback);
        });
        this.getLatestSwapRate = (from, to) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getLatestSwapRate(from, to);
        });
        this.unsubscribeToSwapRates = (from, to) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.unsubscribeFromSwapRates(from, to);
        });
        this.addPaymentProfile = (profile) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.addPaymentProfile(profile);
        });
        this.getPaymentProfile = (assetId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getPaymentProfile(assetId);
        });
        this.getTransferHistory = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getTransferHistory();
        });
        this.deposit = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.depositController.deposit(params);
        });
        this.requestDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.requestDepositRightsController.requestDepositRights(params);
        });
        this.rescindDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelRouter.rescindDepositRights(params);
        });
        this.checkDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            const refundApp = yield this.getBalanceRefundApp(params.assetId);
            const multisigBalance = !refundApp.latestState["tokenAddress"] &&
                refundApp.latestState["tokenAddress"] !== constants_1.AddressZero
                ? yield this.ethProvider.getBalance(this.multisigAddress)
                : yield new ethers_1.Contract(refundApp.latestState["tokenAddress"], human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.multisigAddress);
            return refundApp
                ? {
                    assetId: refundApp.latestState["tokenAddress"],
                    multisigBalance: multisigBalance.toString(),
                    recipient: refundApp.latestState["recipient"],
                    threshold: refundApp.latestState["threshold"],
                }
                : undefined;
        });
        this.swap = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.swapController.swap(params);
        });
        this.transfer = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.conditionalTransferController.conditionalTransfer({
                amount: params.amount,
                assetId: params.assetId,
                conditionType: "LINKED_TRANSFER_TO_RECIPIENT",
                meta: params.meta,
                paymentId: utils_1.hexlify(utils_1.randomBytes(32)),
                preImage: utils_1.hexlify(utils_1.randomBytes(32)),
                recipient: params.recipient,
            });
        });
        this.withdraw = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.withdrawalController.withdraw(params);
        });
        this.resolveCondition = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.resolveConditionController.resolve(params);
        });
        this.conditionalTransfer = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.conditionalTransferController.conditionalTransfer(params);
        });
        this.getLatestNodeSubmittedWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const value = yield this.channelRouter.get(lib_1.withdrawalKey(this.publicIdentifier));
            if (!value || value === "undefined") {
                return undefined;
            }
            const noRetry = value.retry === undefined || value.retry === null;
            if (!value.tx || noRetry) {
                const msg = `Can not find tx or retry in store under key ${lib_1.withdrawalKey(this.publicIdentifier)}`;
                this.log.error(msg);
                throw new Error(msg);
            }
            return value;
        });
        this.watchForUserWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const maxBlocks = 15;
            const startingBlock = yield this.ethProvider.getBlockNumber();
            try {
                yield new Promise((resolve, reject) => {
                    this.ethProvider.on("block", (blockNumber) => __awaiter(this, void 0, void 0, function* () {
                        const found = yield this.checkForUserWithdrawal(blockNumber);
                        if (found) {
                            yield this.channelRouter.set([
                                { path: lib_1.withdrawalKey(this.publicIdentifier), value: undefined },
                            ]);
                            this.ethProvider.removeAllListeners("block");
                            resolve();
                        }
                        if (blockNumber - startingBlock >= maxBlocks) {
                            this.ethProvider.removeAllListeners("block");
                            reject(`More than ${maxBlocks} have passed: ${blockNumber - startingBlock}`);
                        }
                    }));
                });
            }
            catch (e) {
                if (e.includes(`More than ${maxBlocks} have passed`)) {
                    this.log.debug(`Retrying node submission`);
                    yield this.retryNodeSubmittedWithdrawal();
                }
            }
        });
        this.restoreState = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.store || this.routerType === types_2.RpcType.ChannelProvider) {
                throw new Error(`Cannot restore state with channel provider`);
            }
            this.channelRouter.reset();
            const path = `${types_2.ConnextClientStorePrefix}/${this.publicIdentifier}/channel/${this.multisigAddress}`;
            let state;
            try {
                state = yield this.channelRouter.restore();
                if (!state || !state.path) {
                    throw new Error(`No matching paths found in store backup's state`);
                }
                this.log.info(`Found state to restore from store's backup: ${lib_1.stringify(state.path)}`);
                state = state.path;
            }
            catch (e) {
                state = yield this.node.restoreState(this.publicIdentifier);
                if (!state) {
                    throw new Error(`No matching states found by node for ${this.publicIdentifier}`);
                }
                this.log.info(`Found state to restore from node: ${lib_1.stringify(state)}`);
            }
            yield this.channelRouter.set([{ path, value: state }]);
            yield this.restart();
        });
        this.on = (event, callback) => {
            return this.listener.on(event, callback);
        };
        this.once = (event, callback) => {
            return this.listener.once(event, callback);
        };
        this.emit = (event, data) => {
            return this.listener.emit(event, data);
        };
        this.getState = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelRouter.getState(this.multisigAddress);
        });
        this.providerDeposit = (amount, assetId, notifyCounterparty = false) => __awaiter(this, void 0, void 0, function* () {
            const depositAddr = lib_1.xpubToAddress(this.publicIdentifier);
            let bal;
            if (assetId === constants_1.AddressZero) {
                bal = yield this.ethProvider.getBalance(depositAddr);
            }
            else {
                const token = new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider);
                bal = yield token.balanceOf(depositAddr);
            }
            const err = [
                bn_1.notPositive(amount),
                addresses_1.invalidAddress(assetId),
                bn_1.notLessThanOrEqualTo(amount, bal),
            ].filter(bn_1.falsy)[0];
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelRouter.deposit(amount, assetId, this.multisigAddress, notifyCounterparty);
        });
        this.getAppInstances = (multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            return (yield this.channelRouter.getAppInstances(multisigAddress)).appInstances;
        });
        this.getFreeBalance = (assetId = constants_1.AddressZero) => __awaiter(this, void 0, void 0, function* () {
            if (typeof assetId !== "string") {
                throw new Error(`Asset id must be a string: ${lib_1.stringify(assetId)}`);
            }
            const normalizedAssetId = types_2.makeChecksum(assetId);
            try {
                return yield this.channelRouter.getFreeBalance(assetId, this.multisigAddress);
            }
            catch (e) {
                const error = `No free balance exists for the specified token: ${normalizedAssetId}`;
                if (e.message.includes(error)) {
                    const obj = {};
                    obj[lib_1.xpubToAddress(this.nodePublicIdentifier)] = new utils_1.BigNumber(0);
                    obj[this.freeBalanceAddress] = new utils_1.BigNumber(0);
                    return obj;
                }
                throw e;
            }
        });
        this.getProposedAppInstances = (multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelRouter.getProposedAppInstances(multisigAddress);
        });
        this.getProposedAppInstance = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelRouter.getProposedAppInstance(appInstanceId);
        });
        this.getAppInstanceDetails = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.warn(err);
                return undefined;
            }
            return yield this.channelRouter.getAppInstanceDetails(appInstanceId);
        });
        this.getAppState = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.warn(err);
                return undefined;
            }
            return yield this.channelRouter.getAppState(appInstanceId);
        });
        this.takeAction = (appInstanceId, action) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            const state = yield this.getAppState(appInstanceId);
            if (state.state.finalized) {
                throw new Error("Cannot take action on an app with a finalized state.");
            }
            return yield this.channelRouter.takeAction(appInstanceId, action);
        });
        this.updateState = (appInstanceId, newState) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            const state = yield this.getAppState(appInstanceId);
            if (state.state.finalized) {
                throw new Error("Cannot take action on an app with a finalized state.");
            }
            return yield this.channelRouter.updateState(appInstanceId, newState);
        });
        this.proposeInstallApp = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelRouter.proposeInstallApp(params);
        });
        this.installVirtualApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const alreadyInstalled = yield this.appInstalled(appInstanceId);
            if (alreadyInstalled) {
                throw new Error(alreadyInstalled);
            }
            return yield this.channelRouter.installVirtualApp(appInstanceId, this.nodePublicIdentifier);
        });
        this.installApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const alreadyInstalled = yield this.appInstalled(appInstanceId);
            if (alreadyInstalled) {
                throw new Error(alreadyInstalled);
            }
            return yield this.channelRouter.installApp(appInstanceId);
        });
        this.uninstallApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelRouter.uninstallApp(appInstanceId);
        });
        this.uninstallVirtualApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelRouter.uninstallVirtualApp(appInstanceId, this.nodePublicIdentifier);
        });
        this.rejectInstallApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelRouter.rejectInstallApp(appInstanceId);
        });
        this.providerWithdraw = (assetId, amount, recipient) => __awaiter(this, void 0, void 0, function* () {
            const freeBalance = yield this.getFreeBalance(assetId);
            const preWithdrawalBal = freeBalance[this.freeBalanceAddress];
            const err = [
                bn_1.notLessThanOrEqualTo(amount, preWithdrawalBal),
                assetId ? addresses_1.invalidAddress(assetId) : null,
                recipient ? addresses_1.invalidAddress(recipient) : null,
            ].filter(bn_1.falsy)[0];
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelRouter.withdraw(amount, assetId, recipient);
        });
        this.withdrawCommitment = (amount, assetId, recipient) => __awaiter(this, void 0, void 0, function* () {
            const freeBalance = yield this.getFreeBalance(assetId);
            const preWithdrawalBal = freeBalance[this.freeBalanceAddress];
            const err = [
                bn_1.notLessThanOrEqualTo(amount, preWithdrawalBal),
                assetId ? addresses_1.invalidAddress(assetId) : null,
                recipient ? addresses_1.invalidAddress(recipient) : null,
            ].filter(bn_1.falsy)[0];
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelRouter.withdrawCommitment(amount, types_2.makeChecksumOrEthAddress(assetId), recipient);
        });
        this.verifyAppSequenceNumber = () => __awaiter(this, void 0, void 0, function* () {
            const { data: sc } = yield this.channelRouter.getStateChannel();
            let appSequenceNumber;
            try {
                appSequenceNumber = (yield sc.mostRecentlyInstalledAppInstance()).appSeqNo;
            }
            catch (e) {
                if (e.message.includes("There are no installed AppInstances in this StateChannel")) {
                    appSequenceNumber = 0;
                }
                else {
                    throw e;
                }
            }
            return yield this.node.verifyAppSequenceNumber(appSequenceNumber);
        });
        this.reclaimPendingAsyncTransfers = () => __awaiter(this, void 0, void 0, function* () {
            const pendingTransfers = yield this.node.getPendingAsyncTransfers();
            for (const transfer of pendingTransfers) {
                const { encryptedPreImage, paymentId } = transfer;
                yield this.reclaimPendingAsyncTransfer(paymentId, encryptedPreImage);
            }
        });
        this.reclaimPendingAsyncTransfer = (paymentId, encryptedPreImage) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Reclaiming transfer ${paymentId}`);
            let privateKey;
            if (this.opts.mnemonic) {
                privateKey = hdnode_1.fromMnemonic(this.opts.mnemonic)
                    .derivePath(types_1.CF_PATH)
                    .derivePath("0").privateKey;
            }
            else if (this.keyGen) {
                privateKey = yield this.keyGen("0");
            }
            else {
                throw new Error(`No way to decode transfer, this should never happen!`);
            }
            const cipher = eth_crypto_1.default.cipher.parse(encryptedPreImage);
            const preImage = yield eth_crypto_1.default.decryptWithPrivateKey(privateKey, cipher);
            this.log.debug(`Decrypted message and recovered preImage: ${preImage}`);
            const response = yield this.resolveCondition({
                conditionType: "LINKED_TRANSFER_TO_RECIPIENT",
                paymentId,
                preImage,
            });
            this.log.info(`Reclaimed transfer ${lib_1.stringify(response)}`);
            return response;
        });
        this.getRegisteredAppDetails = (appName) => {
            const appInfo = this.appRegistry.filter((app) => {
                return app.name === appName && app.network === this.network.name;
            });
            if (!appInfo || appInfo.length === 0) {
                throw new Error(`Could not find ${appName} app details on ${this.network.name} network`);
            }
            if (appInfo.length > 1) {
                throw new Error(`Found multiple ${appName} app details on ${this.network.name} network`);
            }
            return appInfo[0];
        };
        this.matchTx = (givenTransaction, expected) => {
            return (givenTransaction &&
                givenTransaction.to === expected.to &&
                utils_1.bigNumberify(givenTransaction.value).eq(expected.value) &&
                givenTransaction.data === expected.data);
        };
        this.uninstallCoinBalanceIfNeeded = (assetId = constants_1.AddressZero) => __awaiter(this, void 0, void 0, function* () {
            const coinRefund = yield this.getBalanceRefundApp(assetId);
            if (!coinRefund) {
                this.log.debug("No coin balance refund app found");
                return undefined;
            }
            const latestState = coinRefund.latestState;
            const threshold = utils_1.bigNumberify(latestState["threshold"]);
            const isTokenDeposit = latestState["tokenAddress"] && latestState["tokenAddress"] !== constants_1.AddressZero;
            const isClientDeposit = latestState["recipient"] === this.freeBalanceAddress;
            const multisigBalance = !isTokenDeposit
                ? yield this.ethProvider.getBalance(this.multisigAddress)
                : yield new ethers_1.Contract(latestState["tokenAddress"], human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.multisigAddress);
            if (multisigBalance.lt(threshold)) {
                throw new Error(`Something is wrong! multisig balance is less than the threshold of the installed coin balance refund app.`);
            }
            const uninstallRefund = () => __awaiter(this, void 0, void 0, function* () {
                this.log.debug("Deposit has been executed, uninstalling refund app");
                yield this.uninstallApp(coinRefund.identityHash);
                this.log.debug("Successfully uninstalled");
            });
            if (multisigBalance.eq(threshold)) {
                this.log.warn(`Coin balance refund app found installed, but no deposit successfully executed. Leaving app installed and waiting for deposit of ${latestState["tokenAddress"]} from ${isClientDeposit ? `client` : `node`}`);
                if (isClientDeposit) {
                    if (isTokenDeposit) {
                        new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider).once("Transfer", (sender, recipient, amount) => __awaiter(this, void 0, void 0, function* () {
                            if (recipient === this.multisigAddress && amount.gt(0)) {
                                this.log.info(`Multisig transfer was for our channel, uninstalling refund app`);
                                yield uninstallRefund();
                            }
                        }));
                    }
                    else {
                        this.ethProvider.once(this.multisigAddress, () => __awaiter(this, void 0, void 0, function* () { return yield uninstallRefund(); }));
                    }
                }
                return;
            }
            yield uninstallRefund();
        });
        this.resubmitActiveWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const withdrawal = yield this.channelRouter.get(lib_1.withdrawalKey(this.publicIdentifier));
            if (!withdrawal || withdrawal === "undefined") {
                return;
            }
            if (withdrawal.retry >= MAX_WITHDRAWAL_RETRIES) {
                const msg = `Cannot connect client, hub failed to submit latest withdrawal ${MAX_WITHDRAWAL_RETRIES} times.`;
                this.log.error(msg);
                throw new Error(msg);
            }
            const tx = yield this.node.getLatestWithdrawal();
            if (this.matchTx(tx, withdrawal.tx)) {
                yield this.channelRouter.set([
                    {
                        path: lib_1.withdrawalKey(this.publicIdentifier),
                        value: undefined,
                    },
                ]);
                return;
            }
            this.log.debug(`Found active withdrawal with ${withdrawal.retry} retries, waiting for withdrawal to be caught`);
            yield this.retryNodeSubmittedWithdrawal();
        });
        this.retryNodeSubmittedWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const val = yield this.getLatestNodeSubmittedWithdrawal();
            if (!val) {
                this.log.error(`No transaction found to retry`);
                return;
            }
            let { retry } = val;
            const { tx } = val;
            retry += 1;
            yield this.channelRouter.set([
                {
                    path: lib_1.withdrawalKey(this.publicIdentifier),
                    value: { tx, retry },
                },
            ]);
            if (retry >= MAX_WITHDRAWAL_RETRIES) {
                const msg = `Tried to have node submit withdrawal ${MAX_WITHDRAWAL_RETRIES} times and it did not work, try submitting from wallet.`;
                this.log.error(msg);
                throw new Error(msg);
            }
            yield this.node.withdraw(tx);
            yield this.watchForUserWithdrawal();
        });
        this.appNotInstalled = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const apps = yield this.getAppInstances(this.multisigAddress);
            const app = apps.filter((app) => app.identityHash === appInstanceId);
            if (!app || app.length === 0) {
                return (`Could not find installed app with id: ${appInstanceId}. ` +
                    `Installed apps: ${lib_1.stringify(apps)}.`);
            }
            if (app.length > 1) {
                return (`CRITICAL ERROR: found multiple apps with the same id. ` +
                    `Installed apps: ${lib_1.stringify(apps)}.`);
            }
            return undefined;
        });
        this.appInstalled = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const apps = yield this.getAppInstances(this.multisigAddress);
            const app = apps.filter((app) => app.identityHash === appInstanceId);
            if (app.length > 0) {
                return (`App with id ${appInstanceId} is already installed. ` +
                    `Installed apps: ${lib_1.stringify(apps)}.`);
            }
            return undefined;
        });
        this.checkForUserWithdrawal = (inBlock) => __awaiter(this, void 0, void 0, function* () {
            const val = yield this.getLatestNodeSubmittedWithdrawal();
            if (!val) {
                this.log.error(`No transaction found in store.`);
                return false;
            }
            const { tx } = val;
            const txsTo = yield this.ethProvider.getTransactionCount(tx.to, inBlock);
            if (txsTo === 0) {
                return false;
            }
            const block = yield this.ethProvider.getBlock(inBlock);
            const { transactions } = block;
            if (transactions.length === 0) {
                return false;
            }
            for (const transactionHash of transactions) {
                const transaction = yield this.ethProvider.getTransaction(transactionHash);
                if (this.matchTx(transaction, tx)) {
                    return true;
                }
            }
            return false;
        });
        this.opts = opts;
        this.appRegistry = opts.appRegistry;
        this.channelRouter = opts.channelRouter;
        this.config = opts.config;
        this.ethProvider = opts.ethProvider;
        this.keyGen = opts.keyGen;
        this.messaging = opts.messaging;
        this.network = opts.network;
        this.node = opts.node;
        this.token = opts.token;
        this.store = opts.store;
        this.freeBalanceAddress = this.channelRouter.config.freeBalanceAddress;
        this.signerAddress = this.channelRouter.config.signerAddress;
        this.routerType = this.channelRouter.config.type;
        this.publicIdentifier = this.channelRouter.config.userPublicIdentifier;
        this.multisigAddress = this.opts.multisigAddress;
        this.nodePublicIdentifier = this.opts.config.nodePublicIdentifier;
        this.log = new lib_1.Logger("ConnextClient", opts.logLevel);
        this.listener = new listener_1.ConnextListener(opts.channelRouter, this);
        this.depositController = new DepositController_1.DepositController("DepositController", this);
        this.transferController = new TransferController_1.TransferController("TransferController", this);
        this.swapController = new SwapController_1.SwapController("SwapController", this);
        this.withdrawalController = new WithdrawalController_1.WithdrawalController("WithdrawalController", this);
        this.resolveConditionController = new ResolveConditionController_1.ResolveConditionController("ResolveConditionController", this);
        this.conditionalTransferController = new ConditionalTransferController_1.ConditionalTransferController("ConditionalTransferController", this);
        this.requestDepositRightsController = new RequestDepositRightsController_1.RequestDepositRightsController("RequestDepositRightsController", this);
    }
}
exports.ConnextClient = ConnextClient;
//# sourceMappingURL=connext.js.map