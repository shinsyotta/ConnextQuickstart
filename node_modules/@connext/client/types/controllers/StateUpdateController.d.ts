import { ChannelState, SyncResult, UpdateRequestTypes } from '../types';
import { AbstractController } from './AbstractController';
declare type StateUpdateHandlers = {
    [Type in keyof UpdateRequestTypes]: (this: StateUpdateController, prev: ChannelState, update: UpdateRequestTypes[Type]) => Promise<string | undefined | void>;
};
export declare class StateUpdateController extends AbstractController {
    private unsubscribe;
    start(): Promise<any>;
    stop(): Promise<void>;
    /**
     * Watch a value on the store, calling `onChange` callback each time it
     * changes.
     *
     * If the value changes while `onChange` is running, it will be called again
     * after it completes.
     */
    private watchStore;
    private _queuedActions;
    /**
     * Used by state update handlers to queue an action to be run after
     * `handleStateUpdates` has completed successfully.
     */
    private queueAction;
    private flushQueuedActions;
    private syncOneItemFromStore;
    handleSyncItem(item: SyncResult): Promise<any>;
    /**
     * Theses handlers will be called for updates being sent from the hub.
     *
     * They should perform any update-reason-specific validation (for example,
     * the `Payment` handler should allow any payment where the recipient is
     * 'user' (ie, if the hub is sending us money), but if the recipient is
     * the hub (ie, we're paying the hub), it should double check that the state
     * has already been signed (otherwise the hub could send us an unsigned
     * payment from user-> hub).
     */
    updateHandlers: StateUpdateHandlers;
    private assertValidSigs;
}
export {};
