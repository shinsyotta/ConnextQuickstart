"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const lib_1 = require("../lib");
const types_1 = require("../types");
const addresses_1 = require("./addresses");
const hexStrings_1 = require("./hexStrings");
const validator_1 = require("./validator");
exports.validateSwapApp = (params, proposedByIdentifier, registeredInfo, connext) => __awaiter(this, void 0, void 0, function* () {
    const baseValidation = yield baseAppValidation(params, proposedByIdentifier, registeredInfo, connext);
    if (baseValidation) {
        return baseValidation;
    }
    const { coinTransfers } = types_1.convert.SwapAppState("bignumber", params.initialState);
    if (coinTransfers.length !== 0) {
        return invalidAppMessage(`Incorrect number of coin transfers in initial app state`, params);
    }
    const coinTransferErrs = validateCoinTransfers(coinTransfers[0]);
    if (coinTransferErrs)
        return invalidAppMessage(coinTransferErrs, params);
    return undefined;
});
exports.validateSimpleTransferApp = (params, proposedByIdentifier, registeredInfo, connext) => __awaiter(this, void 0, void 0, function* () {
    const baseValidation = yield baseAppValidation(params, proposedByIdentifier, registeredInfo, connext);
    if (baseValidation) {
        return baseValidation;
    }
    const { responderDeposit, initiatorDeposit, initialState } = params;
    if (!responderDeposit.isZero()) {
        return `Responder (payee) must have a zero balance in proposed app. Proposed app: ${lib_1.stringify(params)}`;
    }
    if (initiatorDeposit.isZero()) {
        return `Initiator (payor) must have nonzero balance in proposed app. Proposed app: ${lib_1.stringify(params)}`;
    }
    const { coinTransfers } = types_1.convert.SimpleTransferAppState("bignumber", initialState);
    const coinTransferErrs = validateCoinTransfers(coinTransfers);
    if (coinTransferErrs)
        return invalidAppMessage(coinTransferErrs, params);
    return undefined;
});
exports.validateLinkedTransferApp = (params, proposedByIdentifier, registeredInfo, connext) => __awaiter(this, void 0, void 0, function* () {
    const baseValidation = yield baseAppValidation(params, proposedByIdentifier, registeredInfo, connext);
    if (baseValidation) {
        return baseValidation;
    }
    const { responderDeposit, initialState, initiatorDeposit, initiatorDepositTokenAddress } = params;
    if (!responderDeposit.isZero()) {
        return invalidAppMessage(`Responder (payee) must have a zero balance in proposed app`, params);
    }
    if (initiatorDeposit.isZero()) {
        return invalidAppMessage(`Initiator (payor) must have nonzero balance in proposed app`, params);
    }
    const { coinTransfers, amount, assetId, linkedHash, paymentId, preImage, } = types_1.convert.LinkedTransferAppState("bignumber", initialState);
    const coinTransferErrs = validateCoinTransfers(coinTransfers);
    if (coinTransferErrs)
        return invalidAppMessage(coinTransferErrs, params);
    const nonzeroCoinTransfer = coinTransfers.filter((transfer) => {
        return !transfer.amount.isZero();
    });
    if (nonzeroCoinTransfer.length > 1) {
        return invalidAppMessage(`Not installing an app with two nonzero coin transfer entries`, params);
    }
    if (!nonzeroCoinTransfer[0].amount.eq(initiatorDeposit)) {
        return invalidAppMessage(`Responder deposit does not match amount in coin transfers`, params);
    }
    if (!amount.eq(initiatorDeposit)) {
        return invalidAppMessage(`Responder deposit does not match amount in initial state`, params);
    }
    if (assetId !== initiatorDepositTokenAddress) {
        return invalidAppMessage(`Initiator deposit token address does not match the assetId of the initial state`, params);
    }
    if (hexStrings_1.invalid32ByteHexString(paymentId) ||
        hexStrings_1.invalid32ByteHexString(preImage) ||
        hexStrings_1.invalid32ByteHexString(linkedHash)) {
        return invalidAppMessage(`Invalid 32 byte hex string detected in paymentId, preImage, or linkedHash`, params);
    }
    return undefined;
});
const baseAppValidation = (params, proposedByIdentifier, registeredInfo, connext) => __awaiter(this, void 0, void 0, function* () {
    const log = new lib_1.Logger("baseAppValidation", connext.log.logLevel);
    log.info(`Validating app: ${lib_1.stringify(params)}`);
    if (params.appDefinition !== registeredInfo.appDefinitionAddress) {
        return invalidAppMessage(`Incorrect app definition detected`, params);
    }
    params.abiEncodings.actionEncoding = params.abiEncodings.actionEncoding
        ? params.abiEncodings.actionEncoding
        : null;
    registeredInfo.actionEncoding = registeredInfo.actionEncoding
        ? registeredInfo.actionEncoding
        : null;
    if (params.abiEncodings.actionEncoding !== registeredInfo.actionEncoding) {
        return invalidAppMessage(`Incorrect action encoding detected`, params);
    }
    if (params.abiEncodings.stateEncoding !== registeredInfo.stateEncoding) {
        return invalidAppMessage(`Incorrect state encoding detected`, params);
    }
    if (utils_1.bigNumberify(params.initiatorDeposit).lt(0) || utils_1.bigNumberify(params.responderDeposit).lt(0)) {
        return invalidAppMessage(`Refusing to install app with negative deposits`, params);
    }
    if (addresses_1.invalidAddress(params.initiatorDepositTokenAddress) ||
        addresses_1.invalidAddress(params.responderDepositTokenAddress)) {
        return invalidAppMessage(`Refusing to install app with negative deposits`, params);
    }
    const isRefund = params.appDefinition === connext.config.contractAddresses["CoinBalanceRefundApp"];
    if (!isRefund &&
        utils_1.bigNumberify(params.initiatorDeposit).isZero() &&
        utils_1.bigNumberify(params.responderDeposit).isZero()) {
        return invalidAppMessage(`Refusing to install app with two zero value deposits`, params);
    }
    if (proposedByIdentifier === connext.nodePublicIdentifier && !registeredInfo.allowNodeInstall) {
        return invalidAppMessage(`Node is not allowed to install this app`, params);
    }
    const responderAssetBalance = yield connext.getFreeBalance(utils_1.getAddress(params.responderDepositTokenAddress));
    const userFreeBalance = responderAssetBalance[lib_1.xpubToAddress(connext.publicIdentifier)];
    if (userFreeBalance.lt(params.responderDeposit)) {
        return invalidAppMessage(`Insufficient free balance for requested asset,
      freeBalance: ${userFreeBalance.toString()}
      required: ${params.responderDeposit}`, params);
    }
    const initiatorAssetBalance = yield connext.getFreeBalance(utils_1.getAddress(params.initiatorDepositTokenAddress));
    const nodeFreeBalance = initiatorAssetBalance[lib_1.xpubToAddress(connext.nodePublicIdentifier)];
    if (nodeFreeBalance.lt(params.initiatorDeposit)) {
        return invalidAppMessage(`Insufficient free balance for requested asset,
      freeBalance: ${nodeFreeBalance.toString()}
      required: ${params.initiatorDeposit}`, params);
    }
    return undefined;
});
const invalidAppMessage = (prefix, params) => {
    return `${prefix}. Proposed app: ${lib_1.stringify(params)}`;
};
const validateCoinTransfers = (coinTransfers) => {
    const errs = validator_1.validator(coinTransfers.map((coinTransfer) => {
        if (coinTransfer.amount.lt(constants_1.Zero)) {
            return `Will not install swap app with negative coin transfer amounts`;
        }
        if (addresses_1.invalidAddress(coinTransfer.to)) {
            return `Will not install app with invalid coin transfer addresses`;
        }
        return undefined;
    }));
    if (errs.length > 0) {
        return errs.toString();
    }
    return undefined;
};
exports.appProposalValidation = {
    CoinBalanceRefundApp: baseAppValidation,
    SimpleLinkedTransferApp: exports.validateLinkedTransferApp,
    SimpleTransferApp: exports.validateSimpleTransferApp,
    SimpleTwoPartySwapApp: exports.validateSwapApp,
};
//# sourceMappingURL=appProposals.js.map