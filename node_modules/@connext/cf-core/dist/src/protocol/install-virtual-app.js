"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const ethereum_1 = require("../ethereum");
const enums_1 = require("../machine/enums");
const xkeys_1 = require("../machine/xkeys");
const models_1 = require("../models");
const types_1 = require("../types");
const signature_forwarder_1 = require("./utils/signature-forwarder");
const signature_validator_1 = require("./utils/signature-validator");
const store_1 = require("../store");
exports.encodeSingleAssetTwoPartyIntermediaryAgreementParams = params => utils_1.defaultAbiCoder.encode([types_1.virtualAppAgreementEncoding], [params]);
const protocol = enums_1.Protocol.InstallVirtualApp;
const { OP_SIGN, WRITE_COMMITMENT, IO_SEND, IO_SEND_AND_WAIT, PERSIST_STATE_CHANNEL } = enums_1.Opcode;
exports.INSTALL_VIRTUAL_APP_PROTOCOL = {
    0: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { message: { params, processID }, stateChannelsMap, network, provider, } = context;
            const { intermediaryXpub, responderXpub } = params;
            const [stateChannelWithInitiatingAndIntermediary, stateChannelWithResponding, stateChannelWithIntermediary, virtualAppInstance, timeLockedPassThroughAppInstance] = yield __await(getUpdatedStateChannelAndVirtualAppObjectsForInitiating(params, stateChannelsMap, network, provider));
            const intermediaryAddress = stateChannelWithIntermediary.getMultisigOwnerAddrOf(intermediaryXpub);
            const responderAddress = stateChannelWithResponding.getMultisigOwnerAddrOf(responderXpub);
            const presignedMultisigTxForAliceIngridVirtualAppAgreement = new ethereum_1.ConditionalTransaction(network, stateChannelWithIntermediary.multisigAddress, stateChannelWithIntermediary.multisigOwners, timeLockedPassThroughAppInstance.identityHash, stateChannelWithIntermediary.freeBalance.identityHash, network.TwoPartyFixedOutcomeFromVirtualAppInterpreter, exports.encodeSingleAssetTwoPartyIntermediaryAgreementParams(stateChannelWithIntermediary.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(virtualAppInstance.identityHash)));
            const initiatorSignatureOnAliceIngridVirtualAppAgreement = yield yield __await([
                OP_SIGN,
                presignedMultisigTxForAliceIngridVirtualAppAgreement
            ]);
            const m1 = {
                params,
                protocol,
                processID,
                toXpub: intermediaryXpub,
                seq: 1,
                customData: {
                    signature: initiatorSignatureOnAliceIngridVirtualAppAgreement,
                    signature2: virtualAppInstance.identityHash,
                    signature3: timeLockedPassThroughAppInstance.state["defaultOutcome"]
                }
            };
            const m4 = (yield yield __await([IO_SEND_AND_WAIT, m1]));
            const { customData: { signature: intermediarySignatureOnAliceIngridVirtualAppAgreement, signature2: intermediarySignatureOnAliceIngridFreeBalanceAppActivation } } = m4;
            signature_validator_1.assertIsValidSignature(intermediaryAddress, presignedMultisigTxForAliceIngridVirtualAppAgreement, intermediarySignatureOnAliceIngridVirtualAppAgreement);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.InstallVirtualApp,
                presignedMultisigTxForAliceIngridVirtualAppAgreement.getSignedTransaction([
                    initiatorSignatureOnAliceIngridVirtualAppAgreement,
                    intermediarySignatureOnAliceIngridVirtualAppAgreement
                ]),
                virtualAppInstance.identityHash
            ]);
            const freeBalanceAliceIngridVirtualAppAgreementActivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithIntermediary.freeBalance.identity, stateChannelWithIntermediary.freeBalance.hashOfLatestState, stateChannelWithIntermediary.freeBalance.versionNumber, stateChannelWithIntermediary.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(intermediaryAddress, freeBalanceAliceIngridVirtualAppAgreementActivationCommitment, intermediarySignatureOnAliceIngridFreeBalanceAppActivation);
            const initiatorSignatureOnAliceIngridFreeBalanceAppActivation = yield yield __await([
                OP_SIGN,
                freeBalanceAliceIngridVirtualAppAgreementActivationCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                freeBalanceAliceIngridVirtualAppAgreementActivationCommitment.getSignedTransaction([
                    initiatorSignatureOnAliceIngridFreeBalanceAppActivation,
                    intermediarySignatureOnAliceIngridFreeBalanceAppActivation
                ]),
                stateChannelWithIntermediary.freeBalance.identityHash
            ]);
            const virtualAppSetStateCommitment = new ethereum_1.SetStateCommitment(network, virtualAppInstance.identity, virtualAppInstance.hashOfLatestState, virtualAppInstance.versionNumber, virtualAppInstance.defaultTimeout);
            const timeLockedPassThroughSetStateCommitment = new ethereum_1.SetStateCommitment(network, timeLockedPassThroughAppInstance.identity, timeLockedPassThroughAppInstance.hashOfLatestState, timeLockedPassThroughAppInstance.versionNumber, timeLockedPassThroughAppInstance.defaultTimeout);
            const initiatorSignatureOnTimeLockedPassThroughSetStateCommitment = yield yield __await([
                OP_SIGN,
                timeLockedPassThroughSetStateCommitment
            ]);
            const initiatorSignatureOnVirtualAppSetStateCommitment = yield yield __await([
                OP_SIGN,
                virtualAppSetStateCommitment
            ]);
            const m5 = {
                protocol,
                processID,
                toXpub: intermediaryXpub,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                customData: {
                    signature: initiatorSignatureOnAliceIngridFreeBalanceAppActivation,
                    signature2: initiatorSignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature3: initiatorSignatureOnVirtualAppSetStateCommitment
                }
            };
            const m8 = (yield yield __await([IO_SEND_AND_WAIT, m5]));
            const { customData: { signature: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment, signature2: responderSignatureOnTimeLockedPassThroughSetStateCommitment, signature3: responderSignatureOnVirtualAppSetStateCommitment } } = m8;
            signature_validator_1.assertIsValidSignature(intermediaryAddress, timeLockedPassThroughSetStateCommitment, intermediarySignatureOnTimeLockedPassThroughSetStateCommitment);
            signature_validator_1.assertIsValidSignature(responderAddress, timeLockedPassThroughSetStateCommitment, responderSignatureOnTimeLockedPassThroughSetStateCommitment);
            signature_validator_1.assertIsValidSignature(responderAddress, virtualAppSetStateCommitment, responderSignatureOnVirtualAppSetStateCommitment);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                timeLockedPassThroughSetStateCommitment.getSignedTransaction([
                    initiatorSignatureOnTimeLockedPassThroughSetStateCommitment,
                    responderSignatureOnTimeLockedPassThroughSetStateCommitment,
                    intermediarySignatureOnTimeLockedPassThroughSetStateCommitment
                ]),
                timeLockedPassThroughAppInstance.identityHash
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                virtualAppSetStateCommitment.getSignedTransaction([
                    initiatorSignatureOnVirtualAppSetStateCommitment,
                    responderSignatureOnVirtualAppSetStateCommitment
                ]),
                virtualAppInstance.identityHash
            ]);
            yield yield __await([
                PERSIST_STATE_CHANNEL,
                [
                    stateChannelWithIntermediary,
                    stateChannelWithResponding,
                    stateChannelWithInitiatingAndIntermediary
                ]
            ]);
            context.stateChannelsMap.set(stateChannelWithIntermediary.multisigAddress, stateChannelWithIntermediary);
            context.stateChannelsMap.set(stateChannelWithResponding.multisigAddress, stateChannelWithResponding);
            context.stateChannelsMap.set(stateChannelWithInitiatingAndIntermediary.multisigAddress, stateChannelWithInitiatingAndIntermediary);
        });
    },
    1: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { message: m1, stateChannelsMap, network } = context;
            const { params, processID, customData: { signature: initiatorSignatureOnAliceIngridVirtualAppAgreement, signature2: virtualAppInstanceIdentityHash, signature3: virtualAppInstanceDefaultOutcome } } = m1;
            const { initiatorXpub, responderXpub } = params;
            const [stateChannelBetweenVirtualAppUsers, stateChannelWithInitiating, stateChannelWithResponding, timeLockedPassThroughAppInstance] = yield __await(getUpdatedStateChannelAndVirtualAppObjectsForIntermediary(params, stateChannelsMap, virtualAppInstanceIdentityHash, virtualAppInstanceDefaultOutcome, network));
            const initiatorAddress = stateChannelWithInitiating.getMultisigOwnerAddrOf(initiatorXpub);
            const responderAddress = stateChannelWithResponding.getMultisigOwnerAddrOf(responderXpub);
            const presignedMultisigTxForAliceIngridVirtualAppAgreement = new ethereum_1.ConditionalTransaction(network, stateChannelWithInitiating.multisigAddress, stateChannelWithInitiating.multisigOwners, timeLockedPassThroughAppInstance.identityHash, stateChannelWithInitiating.freeBalance.identityHash, network.TwoPartyFixedOutcomeFromVirtualAppInterpreter, exports.encodeSingleAssetTwoPartyIntermediaryAgreementParams(stateChannelWithInitiating.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(timeLockedPassThroughAppInstance.state["targetAppIdentityHash"])));
            signature_validator_1.assertIsValidSignature(initiatorAddress, presignedMultisigTxForAliceIngridVirtualAppAgreement, initiatorSignatureOnAliceIngridVirtualAppAgreement);
            const presignedMultisigTxForIngridBobVirtualAppAgreement = new ethereum_1.ConditionalTransaction(network, stateChannelWithResponding.multisigAddress, stateChannelWithResponding.multisigOwners, timeLockedPassThroughAppInstance.identityHash, stateChannelWithResponding.freeBalance.identityHash, network.TwoPartyFixedOutcomeFromVirtualAppInterpreter, exports.encodeSingleAssetTwoPartyIntermediaryAgreementParams(stateChannelWithResponding.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(timeLockedPassThroughAppInstance.state["targetAppIdentityHash"])));
            const intermediarySignatureOnIngridBobVirtualAppAgreement = yield yield __await([
                OP_SIGN,
                presignedMultisigTxForIngridBobVirtualAppAgreement
            ]);
            const m2 = {
                params,
                protocol,
                processID,
                seq: 2,
                toXpub: responderXpub,
                customData: {
                    signature: intermediarySignatureOnIngridBobVirtualAppAgreement
                }
            };
            const m3 = (yield yield __await([IO_SEND_AND_WAIT, m2]));
            const { customData: { signature: responderSignatureOnIngridBobVirtualAppAgreement, signature2: responderSignatureOnIngridBobFreeBalanceAppActivation } } = m3;
            signature_validator_1.assertIsValidSignature(responderAddress, presignedMultisigTxForIngridBobVirtualAppAgreement, responderSignatureOnIngridBobVirtualAppAgreement);
            const freeBalanceIngridBobVirtualAppAgreementActivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithResponding.freeBalance.identity, stateChannelWithResponding.freeBalance.hashOfLatestState, stateChannelWithResponding.freeBalance.versionNumber, stateChannelWithResponding.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(responderAddress, freeBalanceIngridBobVirtualAppAgreementActivationCommitment, responderSignatureOnIngridBobFreeBalanceAppActivation);
            const freeBalanceAliceIngridVirtualAppAgreementActivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithInitiating.freeBalance.identity, stateChannelWithInitiating.freeBalance.hashOfLatestState, stateChannelWithInitiating.freeBalance.versionNumber, stateChannelWithInitiating.freeBalance.timeout);
            const intermediarySignatureOnAliceIngridFreeBalanceAppActivation = yield yield __await([
                OP_SIGN,
                freeBalanceAliceIngridVirtualAppAgreementActivationCommitment
            ]);
            const intermediarySignatureOnAliceIngridVirtualAppAgreement = yield yield __await([
                OP_SIGN,
                presignedMultisigTxForAliceIngridVirtualAppAgreement
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.InstallVirtualApp,
                presignedMultisigTxForAliceIngridVirtualAppAgreement.getSignedTransaction([
                    initiatorSignatureOnAliceIngridVirtualAppAgreement,
                    intermediarySignatureOnAliceIngridVirtualAppAgreement
                ]),
                timeLockedPassThroughAppInstance.identityHash
            ]);
            const m4 = {
                protocol,
                processID,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: initiatorXpub,
                customData: {
                    signature: intermediarySignatureOnAliceIngridVirtualAppAgreement,
                    signature2: intermediarySignatureOnAliceIngridFreeBalanceAppActivation
                }
            };
            const m5 = (yield yield __await([IO_SEND_AND_WAIT, m4]));
            const { customData: { signature: initiatorSignatureOnAliceIngridFreeBalanceAppActivation, signature2: initiatorSignatureOnTimeLockedPassThroughSetStateCommitment, signature3: initiatorSignatureOnVirtualAppSetStateCommitment } } = m5;
            signature_validator_1.assertIsValidSignature(initiatorAddress, freeBalanceAliceIngridVirtualAppAgreementActivationCommitment, initiatorSignatureOnAliceIngridFreeBalanceAppActivation);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                freeBalanceIngridBobVirtualAppAgreementActivationCommitment.getSignedTransaction([
                    initiatorSignatureOnAliceIngridFreeBalanceAppActivation,
                    intermediarySignatureOnAliceIngridFreeBalanceAppActivation
                ]),
                stateChannelWithResponding.freeBalance.identityHash
            ]);
            const timeLockedPassThroughSetStateCommitment = new ethereum_1.SetStateCommitment(network, timeLockedPassThroughAppInstance.identity, timeLockedPassThroughAppInstance.hashOfLatestState, timeLockedPassThroughAppInstance.versionNumber, timeLockedPassThroughAppInstance.defaultTimeout);
            signature_validator_1.assertIsValidSignature(initiatorAddress, timeLockedPassThroughSetStateCommitment, initiatorSignatureOnTimeLockedPassThroughSetStateCommitment);
            const intermediarySignatureOnIngridBobFreeBalanceAppActivation = yield yield __await([
                OP_SIGN,
                freeBalanceIngridBobVirtualAppAgreementActivationCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                freeBalanceIngridBobVirtualAppAgreementActivationCommitment.getSignedTransaction([
                    responderSignatureOnIngridBobFreeBalanceAppActivation,
                    intermediarySignatureOnIngridBobFreeBalanceAppActivation
                ]),
                stateChannelWithResponding.freeBalance.identityHash
            ]);
            const intermediarySignatureOnTimeLockedPassThroughSetStateCommitment = yield yield __await([
                OP_SIGN,
                timeLockedPassThroughSetStateCommitment
            ]);
            const m6 = {
                protocol,
                processID,
                toXpub: responderXpub,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                customData: {
                    signature: intermediarySignatureOnIngridBobFreeBalanceAppActivation,
                    signature2: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature3: initiatorSignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature4: initiatorSignatureOnVirtualAppSetStateCommitment
                }
            };
            const m7 = (yield yield __await([IO_SEND_AND_WAIT, m6]));
            const { customData: { signature: responderSignatureOnTimeLockedPassThroughSetStateCommitment, signature2: responderSignatureOnVirtualAppSetStateCommitment } } = m7;
            signature_validator_1.assertIsValidSignature(responderAddress, timeLockedPassThroughSetStateCommitment, responderSignatureOnTimeLockedPassThroughSetStateCommitment);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                timeLockedPassThroughSetStateCommitment.getSignedTransaction([
                    initiatorSignatureOnTimeLockedPassThroughSetStateCommitment,
                    responderSignatureOnTimeLockedPassThroughSetStateCommitment,
                    intermediarySignatureOnTimeLockedPassThroughSetStateCommitment
                ]),
                timeLockedPassThroughAppInstance.identityHash
            ]);
            const m8 = {
                protocol,
                processID,
                toXpub: initiatorXpub,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                customData: {
                    signature: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature2: responderSignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature3: responderSignatureOnVirtualAppSetStateCommitment
                }
            };
            yield yield __await([IO_SEND, m8]);
            yield yield __await([
                PERSIST_STATE_CHANNEL,
                [
                    stateChannelBetweenVirtualAppUsers,
                    stateChannelWithResponding,
                    stateChannelWithInitiating
                ]
            ]);
            context.stateChannelsMap.set(stateChannelBetweenVirtualAppUsers.multisigAddress, stateChannelBetweenVirtualAppUsers);
            context.stateChannelsMap.set(stateChannelWithInitiating.multisigAddress, stateChannelWithInitiating);
            context.stateChannelsMap.set(stateChannelWithResponding.multisigAddress, stateChannelWithResponding);
        });
    },
    2: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { message: m2, stateChannelsMap, network, provider } = context;
            const { params, processID, customData: { signature: intermediarySignatureOnIngridBobVirtualAppAgreement } } = m2;
            const { intermediaryXpub, initiatorXpub } = params;
            const [stateChannelWithRespondingAndIntermediary, stateChannelWithInitiating, stateChannelWithIntermediary, virtualAppInstance, timeLockedPassThroughAppInstance] = yield __await(getUpdatedStateChannelAndVirtualAppObjectsForResponding(params, stateChannelsMap, network, provider));
            const intermediaryAddress = stateChannelWithIntermediary.getMultisigOwnerAddrOf(intermediaryXpub);
            const initiatorAddress = stateChannelWithInitiating.getMultisigOwnerAddrOf(initiatorXpub);
            const presignedMultisigTxForIngridBobVirtualAppAgreement = new ethereum_1.ConditionalTransaction(network, stateChannelWithIntermediary.multisigAddress, stateChannelWithIntermediary.multisigOwners, timeLockedPassThroughAppInstance.identityHash, stateChannelWithIntermediary.freeBalance.identityHash, network.TwoPartyFixedOutcomeFromVirtualAppInterpreter, exports.encodeSingleAssetTwoPartyIntermediaryAgreementParams(stateChannelWithIntermediary.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(virtualAppInstance.identityHash)));
            signature_validator_1.assertIsValidSignature(intermediaryAddress, presignedMultisigTxForIngridBobVirtualAppAgreement, intermediarySignatureOnIngridBobVirtualAppAgreement);
            const responderSignatureOnIngridBobVirtualAppAgreement = yield yield __await([
                OP_SIGN,
                presignedMultisigTxForIngridBobVirtualAppAgreement
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.InstallVirtualApp,
                presignedMultisigTxForIngridBobVirtualAppAgreement.getSignedTransaction([
                    responderSignatureOnIngridBobVirtualAppAgreement,
                    intermediarySignatureOnIngridBobVirtualAppAgreement
                ]),
                virtualAppInstance.identityHash
            ]);
            const freeBalanceIngridBobVirtualAppAgreementActivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithIntermediary.freeBalance.identity, stateChannelWithIntermediary.freeBalance.hashOfLatestState, stateChannelWithIntermediary.freeBalance.versionNumber, stateChannelWithIntermediary.freeBalance.timeout);
            const responderSignatureOnIngridBobFreeBalanceAppActivation = yield yield __await([
                OP_SIGN,
                freeBalanceIngridBobVirtualAppAgreementActivationCommitment
            ]);
            const m3 = {
                protocol,
                processID,
                toXpub: intermediaryXpub,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                customData: {
                    signature: responderSignatureOnIngridBobVirtualAppAgreement,
                    signature2: responderSignatureOnIngridBobFreeBalanceAppActivation
                }
            };
            const m6 = (yield yield __await([IO_SEND_AND_WAIT, m3]));
            const { customData: { signature: intermediarySignatureOnIngridBobFreeBalanceAppActivation, signature2: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment, signature3: initiatorSignatureOnTimeLockedPassThroughSetStateCommitment, signature4: initiatorSignatureOnVirtualAppSetStateCommitment } } = m6;
            signature_validator_1.assertIsValidSignature(intermediaryAddress, freeBalanceIngridBobVirtualAppAgreementActivationCommitment, intermediarySignatureOnIngridBobFreeBalanceAppActivation);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                freeBalanceIngridBobVirtualAppAgreementActivationCommitment.getSignedTransaction([
                    intermediarySignatureOnIngridBobFreeBalanceAppActivation,
                    responderSignatureOnIngridBobFreeBalanceAppActivation
                ]),
                stateChannelWithIntermediary.freeBalance.identityHash
            ]);
            const virtualAppSetStateCommitment = new ethereum_1.SetStateCommitment(network, virtualAppInstance.identity, virtualAppInstance.hashOfLatestState, virtualAppInstance.versionNumber, virtualAppInstance.defaultTimeout);
            const timeLockedPassThroughSetStateCommitment = new ethereum_1.SetStateCommitment(network, timeLockedPassThroughAppInstance.identity, timeLockedPassThroughAppInstance.hashOfLatestState, timeLockedPassThroughAppInstance.versionNumber, timeLockedPassThroughAppInstance.defaultTimeout);
            signature_validator_1.assertIsValidSignature(intermediaryAddress, timeLockedPassThroughSetStateCommitment, intermediarySignatureOnTimeLockedPassThroughSetStateCommitment);
            signature_validator_1.assertIsValidSignature(initiatorAddress, timeLockedPassThroughSetStateCommitment, initiatorSignatureOnTimeLockedPassThroughSetStateCommitment);
            signature_validator_1.assertIsValidSignature(initiatorAddress, virtualAppSetStateCommitment, initiatorSignatureOnVirtualAppSetStateCommitment);
            const responderSignatureOnTimeLockedPassThroughSetStateCommitment = yield yield __await([
                OP_SIGN,
                timeLockedPassThroughSetStateCommitment
            ]);
            const responderSignatureOnVirtualAppSetStateCommitment = yield yield __await([
                OP_SIGN,
                virtualAppSetStateCommitment
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                timeLockedPassThroughSetStateCommitment.getSignedTransaction([
                    initiatorSignatureOnTimeLockedPassThroughSetStateCommitment,
                    responderSignatureOnTimeLockedPassThroughSetStateCommitment,
                    intermediarySignatureOnTimeLockedPassThroughSetStateCommitment
                ]),
                timeLockedPassThroughAppInstance.identityHash
            ]);
            yield yield __await([
                WRITE_COMMITMENT,
                enums_1.Protocol.Update,
                virtualAppSetStateCommitment.getSignedTransaction([
                    initiatorSignatureOnVirtualAppSetStateCommitment,
                    responderSignatureOnVirtualAppSetStateCommitment
                ]),
                virtualAppInstance.identityHash
            ]);
            const m7 = {
                protocol,
                processID,
                toXpub: intermediaryXpub,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                customData: {
                    signature: responderSignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature2: responderSignatureOnVirtualAppSetStateCommitment
                }
            };
            yield yield __await([IO_SEND, m7]);
            yield yield __await([
                PERSIST_STATE_CHANNEL,
                [
                    stateChannelWithIntermediary,
                    stateChannelWithRespondingAndIntermediary,
                    stateChannelWithInitiating
                ]
            ]);
            context.stateChannelsMap.set(stateChannelWithIntermediary.multisigAddress, stateChannelWithIntermediary);
            context.stateChannelsMap.set(stateChannelWithInitiating.multisigAddress, stateChannelWithInitiating);
            context.stateChannelsMap.set(stateChannelWithRespondingAndIntermediary.multisigAddress, stateChannelWithRespondingAndIntermediary);
        });
    }
};
function computeInterpreterParameters(outcomeType, initiatingAddress, respondingAddress, initiatingBalanceDecrement, respondingBalanceDecrement, tokenAddress) {
    const multiAssetMultiPartyCoinTransferInterpreterParams = undefined;
    let twoPartyOutcomeInterpreterParams = undefined;
    let singleAssetTwoPartyCoinTransferInterpreterParams = undefined;
    if (outcomeType === undefined) {
        throw Error("This really should have been caught earlier");
    }
    switch (outcomeType) {
        case types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME: {
            twoPartyOutcomeInterpreterParams = {
                tokenAddress,
                playerAddrs: [initiatingAddress, respondingAddress],
                amount: utils_1.bigNumberify(initiatingBalanceDecrement).add(respondingBalanceDecrement)
            };
            break;
        }
        case types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER: {
            singleAssetTwoPartyCoinTransferInterpreterParams = {
                tokenAddress,
                limit: utils_1.bigNumberify(initiatingBalanceDecrement).add(respondingBalanceDecrement)
            };
            break;
        }
        default: {
            throw Error(`Not supported, and weird outcome type: ${outcomeType}`);
        }
    }
    return {
        multiAssetMultiPartyCoinTransferInterpreterParams,
        twoPartyOutcomeInterpreterParams,
        singleAssetTwoPartyCoinTransferInterpreterParams
    };
}
function constructVirtualAppInstance(params) {
    const { initiatorXpub, responderXpub, defaultTimeout, appInterface, initialState, outcomeType, initiatorBalanceDecrement, responderBalanceDecrement, tokenAddress, appSeqNo } = params;
    const initiatorAddress = xkeys_1.xkeyKthAddress(initiatorXpub, appSeqNo);
    const responderAddress = xkeys_1.xkeyKthAddress(responderXpub, appSeqNo);
    const { multiAssetMultiPartyCoinTransferInterpreterParams, twoPartyOutcomeInterpreterParams, singleAssetTwoPartyCoinTransferInterpreterParams } = computeInterpreterParameters(outcomeType, initiatorAddress, responderAddress, initiatorBalanceDecrement, responderBalanceDecrement, tokenAddress);
    return new models_1.AppInstance(xkeys_1.sortAddresses([initiatorAddress, responderAddress]), defaultTimeout, appInterface, true, appSeqNo, initialState, 0, defaultTimeout, outcomeType, twoPartyOutcomeInterpreterParams, multiAssetMultiPartyCoinTransferInterpreterParams, singleAssetTwoPartyCoinTransferInterpreterParams);
}
function constructTimeLockedPassThroughAppInstance(threePartyStateChannel, virtualAppInstanceIdentityHash, virtualAppDefaultOutcome, network, params) {
    const { intermediaryXpub, initiatorXpub, responderXpub, initiatorBalanceDecrement, responderBalanceDecrement, outcomeType, tokenAddress } = params;
    const seqNo = threePartyStateChannel.numProposedApps;
    const intermediaryAddress = xkeys_1.xkeyKthAddress(intermediaryXpub, seqNo);
    const initiatorAddress = xkeys_1.xkeyKthAddress(initiatorXpub, seqNo);
    const responderAddress = xkeys_1.xkeyKthAddress(responderXpub, seqNo);
    const HARD_CODED_CHALLENGE_TIMEOUT = 100;
    const { multiAssetMultiPartyCoinTransferInterpreterParams, twoPartyOutcomeInterpreterParams, singleAssetTwoPartyCoinTransferInterpreterParams } = computeInterpreterParameters(outcomeType, initiatorAddress, responderAddress, initiatorBalanceDecrement, responderBalanceDecrement, tokenAddress);
    return new models_1.AppInstance(xkeys_1.sortAddresses([initiatorAddress, responderAddress, intermediaryAddress]), HARD_CODED_CHALLENGE_TIMEOUT, {
        stateEncoding: `tuple(address challengeRegistryAddress, bytes32 targetAppIdentityHash, uint256 switchesOutcomeAt, bytes defaultOutcome)`,
        actionEncoding: undefined,
        addr: network.TimeLockedPassThrough
    }, true, seqNo, {
        challengeRegistryAddress: network.ChallengeRegistry,
        targetAppIdentityHash: virtualAppInstanceIdentityHash,
        switchesOutcomeAt: constants_1.MaxUint256,
        defaultOutcome: virtualAppDefaultOutcome
    }, 0, HARD_CODED_CHALLENGE_TIMEOUT, outcomeType, twoPartyOutcomeInterpreterParams, multiAssetMultiPartyCoinTransferInterpreterParams, singleAssetTwoPartyCoinTransferInterpreterParams);
}
async function getOrCreateStateChannelWithUsers(stateChannelsMap, userXpubs, network) {
    const multisigAddress = await store_1.Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, userXpubs, network.ProxyFactory, network.MinimumViableMultisig, network.provider);
    return (stateChannelsMap.get(multisigAddress) ||
        models_1.StateChannel.createEmptyChannel(multisigAddress, network.ProxyFactory, userXpubs));
}
async function getUpdatedStateChannelAndVirtualAppObjectsForInitiating(params, stateChannelsMap, network, provider) {
    const { initiatorBalanceDecrement, responderBalanceDecrement, tokenAddress, initiatorXpub, intermediaryXpub, responderXpub } = params;
    const stateChannelWithAllThreeParties = await getOrCreateStateChannelWithUsers(stateChannelsMap, [initiatorXpub, responderXpub, intermediaryXpub], network);
    const stateChannelWithResponding = await getOrCreateStateChannelWithUsers(stateChannelsMap, [initiatorXpub, responderXpub], network);
    const virtualAppInstance = constructVirtualAppInstance(params);
    const timeLockedPassThroughAppInstance = await constructTimeLockedPassThroughAppInstance(stateChannelWithAllThreeParties, virtualAppInstance.identityHash, await virtualAppInstance.computeOutcomeWithCurrentState(provider), network, params);
    const initiatorAddress = xkeys_1.xkeyKthAddress(initiatorXpub, 0);
    const intermediaryAddress = xkeys_1.xkeyKthAddress(intermediaryXpub, 0);
    const multisigAddressWithIntermediary = await store_1.Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, [initiatorXpub, intermediaryXpub], network.ProxyFactory, network.MinimumViableMultisig);
    const stateChannelWithIntermediary = stateChannelsMap.get(multisigAddressWithIntermediary);
    if (!stateChannelWithIntermediary) {
        throw Error("Cannot run InstallVirtualAppProtocol without existing channel with intermediary");
    }
    const newStateChannelWithIntermediary = stateChannelWithIntermediary.addSingleAssetTwoPartyIntermediaryAgreement(virtualAppInstance.identityHash, {
        tokenAddress,
        timeLockedPassThroughIdentityHash: timeLockedPassThroughAppInstance.identityHash,
        capitalProvided: utils_1.bigNumberify(initiatorBalanceDecrement)
            .add(responderBalanceDecrement)
            .toHexString(),
        capitalProvider: intermediaryAddress,
        virtualAppUser: initiatorAddress
    }, {
        [initiatorAddress]: initiatorBalanceDecrement,
        [intermediaryAddress]: responderBalanceDecrement
    }, tokenAddress);
    return [
        stateChannelWithAllThreeParties.addAppInstance(timeLockedPassThroughAppInstance),
        stateChannelWithResponding.addAppInstance(virtualAppInstance),
        newStateChannelWithIntermediary,
        virtualAppInstance,
        timeLockedPassThroughAppInstance
    ];
}
async function getUpdatedStateChannelAndVirtualAppObjectsForIntermediary(params, stateChannelsMap, virtualAppInstanceIdentityHash, virtualAppInstanceDefaultOutcome, network) {
    const { initiatorBalanceDecrement, responderBalanceDecrement, initiatorXpub, intermediaryXpub, responderXpub, tokenAddress } = params;
    const stateChannelWithAllThreeParties = await getOrCreateStateChannelWithUsers(stateChannelsMap, [initiatorXpub, responderXpub, intermediaryXpub], network);
    const timeLockedPassThroughAppInstance = await constructTimeLockedPassThroughAppInstance(stateChannelWithAllThreeParties, virtualAppInstanceIdentityHash, virtualAppInstanceDefaultOutcome, network, params);
    const multisigAddressWithIntermediary = await store_1.Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, [initiatorXpub, intermediaryXpub], network.ProxyFactory, network.MinimumViableMultisig);
    const channelWithInitiating = stateChannelsMap.get(multisigAddressWithIntermediary);
    if (!channelWithInitiating) {
        throw Error("Cannot mediate InstallVirtualAppProtocol without mediation channel to initiator");
    }
    const multisigAddressWithResponding = await store_1.Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, [responderXpub, intermediaryXpub], network.ProxyFactory, network.MinimumViableMultisig);
    const channelWithResponding = stateChannelsMap.get(multisigAddressWithResponding);
    if (!channelWithResponding) {
        throw Error("Cannot mediate InstallVirtualAppProtocol without mediation channel to responder");
    }
    const initiatorAddress = xkeys_1.xkeyKthAddress(initiatorXpub, 0);
    const intermediaryAddress = xkeys_1.xkeyKthAddress(intermediaryXpub, 0);
    const responderAddress = xkeys_1.xkeyKthAddress(responderXpub, 0);
    return [
        stateChannelWithAllThreeParties.addAppInstance(timeLockedPassThroughAppInstance),
        channelWithInitiating.addSingleAssetTwoPartyIntermediaryAgreement(virtualAppInstanceIdentityHash, {
            tokenAddress,
            timeLockedPassThroughIdentityHash: timeLockedPassThroughAppInstance.identityHash,
            capitalProvided: utils_1.bigNumberify(initiatorBalanceDecrement)
                .add(responderBalanceDecrement)
                .toHexString(),
            capitalProvider: intermediaryAddress,
            virtualAppUser: initiatorAddress
        }, {
            [initiatorAddress]: initiatorBalanceDecrement,
            [intermediaryAddress]: responderBalanceDecrement
        }, tokenAddress),
        channelWithResponding.addSingleAssetTwoPartyIntermediaryAgreement(virtualAppInstanceIdentityHash, {
            tokenAddress,
            timeLockedPassThroughIdentityHash: timeLockedPassThroughAppInstance.identityHash,
            capitalProvided: utils_1.bigNumberify(initiatorBalanceDecrement)
                .add(responderBalanceDecrement)
                .toHexString(),
            capitalProvider: intermediaryAddress,
            virtualAppUser: responderAddress
        }, {
            [intermediaryAddress]: initiatorBalanceDecrement,
            [responderAddress]: responderBalanceDecrement
        }, tokenAddress),
        timeLockedPassThroughAppInstance
    ];
}
async function getUpdatedStateChannelAndVirtualAppObjectsForResponding(params, stateChannelsMap, network, provider) {
    const { initiatorBalanceDecrement, responderBalanceDecrement, initiatorXpub, intermediaryXpub, responderXpub, tokenAddress } = params;
    const stateChannelWithAllThreeParties = await getOrCreateStateChannelWithUsers(stateChannelsMap, [initiatorXpub, responderXpub, intermediaryXpub], network);
    const stateChannelWithInitiating = await getOrCreateStateChannelWithUsers(stateChannelsMap, [initiatorXpub, responderXpub], network);
    const virtualAppInstance = constructVirtualAppInstance(params);
    const timeLockedPassThroughAppInstance = await constructTimeLockedPassThroughAppInstance(stateChannelWithAllThreeParties, virtualAppInstance.identityHash, await virtualAppInstance.computeOutcomeWithCurrentState(provider), network, params);
    const multisigAddressWithIntermediary = await store_1.Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, [responderXpub, intermediaryXpub], network.ProxyFactory, network.MinimumViableMultisig);
    const stateChannelWithIntermediary = stateChannelsMap.get(multisigAddressWithIntermediary);
    if (!stateChannelWithIntermediary) {
        throw Error("Cannot run InstallVirtualAppProtocol without existing channel with intermediary");
    }
    const intermediaryAddress = xkeys_1.xkeyKthAddress(intermediaryXpub, 0);
    const responderAddress = xkeys_1.xkeyKthAddress(responderXpub, 0);
    return [
        stateChannelWithAllThreeParties.addAppInstance(timeLockedPassThroughAppInstance),
        stateChannelWithInitiating.addAppInstance(virtualAppInstance),
        stateChannelWithIntermediary.addSingleAssetTwoPartyIntermediaryAgreement(virtualAppInstance.identityHash, {
            tokenAddress,
            timeLockedPassThroughIdentityHash: timeLockedPassThroughAppInstance.identityHash,
            capitalProvided: utils_1.bigNumberify(initiatorBalanceDecrement)
                .add(responderBalanceDecrement)
                .toHexString(),
            capitalProvider: intermediaryAddress,
            virtualAppUser: responderAddress
        }, {
            [intermediaryAddress]: initiatorBalanceDecrement,
            [responderAddress]: responderBalanceDecrement
        }, tokenAddress),
        virtualAppInstance,
        timeLockedPassThroughAppInstance
    ];
}
//# sourceMappingURL=install-virtual-app.js.map