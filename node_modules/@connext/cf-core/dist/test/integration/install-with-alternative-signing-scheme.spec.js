"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const loglevel_1 = __importDefault(require("loglevel"));
const src_1 = require("../../src");
const constants_2 = require("../../src/constants");
const types_1 = require("../../src/types");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const memory_lock_service_1 = __importDefault(require("../services/memory-lock-service"));
const memory_messaging_service_1 = require("../services/memory-messaging-service");
const memory_store_service_1 = require("../services/memory-store-service");
const test_constants_jest_1 = require("../test-constants.jest");
const utils_1 = require("./utils");
expect.extend({ toBeLt: bignumber_jest_matcher_1.toBeLt });
loglevel_1.default.disableAll();
describe("Uses a provided signing key generation function to sign channel state updates", () => {
    let multisigAddress;
    jest.setTimeout(10000);
    let nodeA;
    let nodeB;
    describe("Node A gets app install proposal, sends to node B, B approves it, installs it, " +
        "sends acks back to A, A installs it, both nodes have the same app instance", () => {
        beforeEach(async () => {
            const provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
            const messagingService = new memory_messaging_service_1.MemoryMessagingService();
            const nodeConfig = { STORE_KEY_PREFIX: "test" };
            const lockService = new memory_lock_service_1.default();
            const storeServiceA = new memory_store_service_1.MemoryStoreServiceFactory().createStoreService();
            const [privateKeyGeneratorA, xpubA] = src_1.generatePrivateKeyGeneratorAndXPubPair(test_constants_jest_1.A_EXTENDED_PRIVATE_KEY);
            nodeA = await src_1.Node.create(messagingService, storeServiceA, global["networkContext"], nodeConfig, provider, lockService, xpubA, privateKeyGeneratorA);
            const storeServiceB = new memory_store_service_1.MemoryStoreServiceFactory().createStoreService();
            const [privateKeyGeneratorB, xpubB] = src_1.generatePrivateKeyGeneratorAndXPubPair(test_constants_jest_1.B_EXTENDED_PRIVATE_KEY);
            nodeB = await src_1.Node.create(messagingService, storeServiceB, global["networkContext"], nodeConfig, provider, lockService, xpubB, privateKeyGeneratorB);
            multisigAddress = await utils_1.createChannel(nodeA, nodeB);
        });
        it("install app with ETH", async (done) => {
            await utils_1.collateralizeChannel(multisigAddress, nodeA, nodeB);
            let preInstallETHBalanceNodeA;
            let postInstallETHBalanceNodeA;
            let preInstallETHBalanceNodeB;
            let postInstallETHBalanceNodeB;
            nodeB.on(types_1.NODE_EVENTS.PROPOSE_INSTALL, async (msg) => {
                [
                    preInstallETHBalanceNodeA,
                    preInstallETHBalanceNodeB
                ] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
                utils_1.makeInstallCall(nodeB, msg.data.appInstanceId);
            });
            nodeA.on(types_1.NODE_EVENTS.INSTALL, async () => {
                const [appInstanceNodeA] = await utils_1.getInstalledAppInstances(nodeA);
                const [appInstanceNodeB] = await utils_1.getInstalledAppInstances(nodeB);
                expect(appInstanceNodeA).toBeDefined();
                expect(appInstanceNodeA).toEqual(appInstanceNodeB);
                [
                    postInstallETHBalanceNodeA,
                    postInstallETHBalanceNodeB
                ] = await utils_1.getBalances(nodeA, nodeB, multisigAddress, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
                expect(postInstallETHBalanceNodeA).toBeLt(preInstallETHBalanceNodeA);
                expect(postInstallETHBalanceNodeB).toBeLt(preInstallETHBalanceNodeB);
                done();
            });
            nodeA.rpcRouter.dispatch(await utils_1.makeProposeCall(nodeB, global["networkContext"]
                .TicTacToeApp, undefined, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS));
        });
    });
});
//# sourceMappingURL=install-with-alternative-signing-scheme.spec.js.map