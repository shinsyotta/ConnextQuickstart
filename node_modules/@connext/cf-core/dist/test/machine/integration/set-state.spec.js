"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const constants_2 = require("../../../src/constants");
const ethereum_1 = require("../../../src/ethereum");
const machine_1 = require("../../../src/machine");
const models_1 = require("../../../src/models");
const free_balance_1 = require("../../../src/models/free-balance");
const contracts_1 = require("../../contracts");
const bignumber_jest_matcher_1 = require("./bignumber-jest-matcher");
const connect_ganache_1 = require("./connect-ganache");
const random_signing_keys_1 = require("./random-signing-keys");
const SETSTATE_COMMITMENT_GAS = 6e9;
let wallet;
let network;
let appRegistry;
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
beforeAll(async () => {
    [{}, wallet, {}] = await connect_ganache_1.connectToGanache();
    network = global["networkContext"];
    appRegistry = new ethers_1.Contract(network.ChallengeRegistry, contracts_1.ChallengeRegistry.abi, wallet);
});
describe("set state on free balance", () => {
    it("should have the correct versionNumber", async (done) => {
        const xprvs = random_signing_keys_1.getRandomExtendedPrvKeys(2);
        const multisigOwnerKeys = machine_1.xkeysToSortedKthSigningKeys(xprvs, 0);
        const stateChannel = models_1.StateChannel.setupChannel(network.IdentityApp, constants_1.AddressZero, xprvs.map(random_signing_keys_1.extendedPrvKeyToExtendedPubKey)).setFreeBalance(free_balance_1.FreeBalanceClass.createWithFundedTokenAmounts(multisigOwnerKeys.map(key => key.address), constants_1.WeiPerEther, [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]));
        const freeBalanceETH = stateChannel.freeBalance;
        const setStateCommitment = new ethereum_1.SetStateCommitment(network, freeBalanceETH.identity, freeBalanceETH.hashOfLatestState, freeBalanceETH.versionNumber, freeBalanceETH.timeout);
        const setStateTx = setStateCommitment.getSignedTransaction([
            multisigOwnerKeys[0].signDigest(setStateCommitment.hashToSign()),
            multisigOwnerKeys[1].signDigest(setStateCommitment.hashToSign())
        ]);
        await wallet.sendTransaction(Object.assign({}, setStateTx, { gasLimit: SETSTATE_COMMITMENT_GAS }));
        const contractAppState = await appRegistry.appChallenges(freeBalanceETH.identityHash);
        expect(contractAppState.versionNumber).toBeEq(setStateCommitment.appVersionNumber);
        done();
    });
});
//# sourceMappingURL=set-state.spec.js.map