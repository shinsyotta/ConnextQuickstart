"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const utils_1 = require("ethers/utils");
const src_1 = require("../../src");
const constants_2 = require("../../src/constants");
const contracts_1 = require("../contracts");
const machine_1 = require("../../src/machine");
const linked_transfer_1 = require("./linked-transfer");
const simple_transfer_1 = require("./simple-transfer");
const tic_tac_toe_1 = require("./tic-tac-toe");
const unidirectional_transfer_1 = require("./unidirectional-transfer");
const utils_2 = require("../../src/utils");
const { CoinBalanceRefundApp, TicTacToeApp, SimpleTransferApp, UnidirectionalLinkedTransferApp, UnidirectionalTransferApp } = global["networkContext"];
async function requestDepositRights(node, multisigAddress, tokenAddress = constants_1.AddressZero) {
    return await node.rpcRouter.dispatch(constructRequestDepositRightsRpcCall(multisigAddress, tokenAddress));
}
exports.requestDepositRights = requestDepositRights;
function constructRequestDepositRightsRpcCall(multisigAddress, tokenAddress = constants_1.AddressZero) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.REQUEST_DEPOSIT_RIGHTS,
        parameters: {
            multisigAddress,
            tokenAddress
        }
    };
}
exports.constructRequestDepositRightsRpcCall = constructRequestDepositRightsRpcCall;
async function rescindDepositRights(node, multisigAddress, tokenAddress = constants_1.AddressZero) {
    return await node.rpcRouter.dispatch(constructRescindDepositRightsRpcCall(multisigAddress, tokenAddress));
}
exports.rescindDepositRights = rescindDepositRights;
function constructRescindDepositRightsRpcCall(multisigAddress, tokenAddress = constants_1.AddressZero) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.RESCIND_DEPOSIT_RIGHTS,
        parameters: {
            multisigAddress,
            tokenAddress
        }
    };
}
exports.constructRescindDepositRightsRpcCall = constructRescindDepositRightsRpcCall;
function assertNodeMessage(msg, expected, shouldExist = []) {
    shouldExist.forEach(key => {
        let subset = Object.assign({}, msg);
        key.split(".").forEach(k => {
            expect(subset[k]).toBeDefined();
            subset = subset[k];
        });
    });
    expect(utils_2.deBigNumberifyJson(msg)).toMatchObject(utils_2.deBigNumberifyJson(expected));
}
exports.assertNodeMessage = assertNodeMessage;
function assertProposeMessage(senderId, msg, params) {
    const { multisigAddress, initiatorXpub, responderXpub: proposedToIdentifier } = params, emittedParams = __rest(params, ["multisigAddress", "initiatorXpub", "responderXpub"]);
    assertNodeMessage(msg, {
        from: senderId,
        type: src_1.NODE_EVENTS.PROPOSE_INSTALL,
        data: {
            params: Object.assign({}, emittedParams, { proposedToIdentifier })
        }
    }, ["data.appInstanceId"]);
}
exports.assertProposeMessage = assertProposeMessage;
function assertInstallMessage(senderId, msg, appInstanceId) {
    assertNodeMessage(msg, {
        from: senderId,
        type: src_1.NODE_EVENTS.INSTALL,
        data: {
            params: {
                appInstanceId
            }
        }
    });
}
exports.assertInstallMessage = assertInstallMessage;
async function getMultisigCreationAddress(node, xpubs) {
    const { result: { result: { multisigAddress } } } = await node.rpcRouter.dispatch(constructChannelCreationRpc(xpubs));
    return multisigAddress;
}
exports.getMultisigCreationAddress = getMultisigCreationAddress;
function constructChannelCreationRpc(owners) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.CREATE_CHANNEL,
        parameters: {
            owners
        }
    };
}
exports.constructChannelCreationRpc = constructChannelCreationRpc;
async function getChannelAddresses(node) {
    const { result: { result: { multisigAddresses } } } = await node.rpcRouter.dispatch({
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_CHANNEL_ADDRESSES,
        parameters: {}
    });
    return new Set(multisigAddresses);
}
exports.getChannelAddresses = getChannelAddresses;
async function getAppInstance(node, appInstanceId) {
    const { result: { result: { appInstance } } } = await node.rpcRouter.dispatch({
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_APP_INSTANCE_DETAILS,
        parameters: {
            appInstanceId
        }
    });
    return appInstance;
}
exports.getAppInstance = getAppInstance;
async function getAppInstanceProposal(node, appInstanceId) {
    const candidates = (await getProposedAppInstances(node)).filter(proposal => proposal.identityHash === appInstanceId);
    if (candidates.length === 0) {
        throw new Error("Could not find proposal");
    }
    if (candidates.length > 1) {
        throw new Error("Failed to match exactly one proposed app instance");
    }
    return candidates[0];
}
exports.getAppInstanceProposal = getAppInstanceProposal;
async function getFreeBalanceState(node, multisigAddress, tokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const { result: { result } } = await node.rpcRouter.dispatch({
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_FREE_BALANCE_STATE,
        parameters: {
            multisigAddress,
            tokenAddress
        }
    });
    return result;
}
exports.getFreeBalanceState = getFreeBalanceState;
async function getTokenIndexedFreeBalanceStates(node, multisigAddress) {
    const { result: { result } } = await node.rpcRouter.dispatch({
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_TOKEN_INDEXED_FREE_BALANCE_STATES,
        parameters: {
            multisigAddress
        }
    });
    return result;
}
exports.getTokenIndexedFreeBalanceStates = getTokenIndexedFreeBalanceStates;
async function getInstalledAppInstances(node) {
    const rpc = {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_APP_INSTANCES,
        parameters: {}
    };
    const response = (await node.rpcRouter.dispatch(rpc));
    const result = response.result.result;
    return result.appInstances;
}
exports.getInstalledAppInstances = getInstalledAppInstances;
async function getProposedAppInstances(node) {
    const rpc = {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_PROPOSED_APP_INSTANCES,
        parameters: {}
    };
    const response = (await node.rpcRouter.dispatch(rpc));
    const result = response.result
        .result;
    return result.appInstances;
}
exports.getProposedAppInstances = getProposedAppInstances;
async function getProposeCoinBalanceRefundAppParams(multisigAddress, balanceRefundRecipientIdentifer, proposedToIdentifier, tokenAddress = constants_1.AddressZero) {
    const provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
    let threshold;
    if (tokenAddress === constants_1.AddressZero) {
        threshold = await provider.getBalance(multisigAddress);
    }
    else {
        const contract = new ethers_1.Contract(tokenAddress, contracts_1.DolphinCoin.abi, provider);
        threshold = await contract.balanceOf(multisigAddress);
    }
    return {
        abiEncodings: {
            actionEncoding: undefined,
            stateEncoding: `tuple(address recipient, address multisig, uint256 threshold, address tokenAddress)`
        },
        appDefinition: CoinBalanceRefundApp,
        initialState: {
            multisig: multisigAddress,
            recipient: machine_1.xkeyKthAddress(balanceRefundRecipientIdentifer, 0),
            threshold,
            tokenAddress
        },
        initiatorDeposit: constants_1.Zero,
        initiatorDepositTokenAddress: tokenAddress,
        outcomeType: types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER,
        proposedToIdentifier,
        responderDeposit: constants_1.Zero,
        responderDepositTokenAddress: tokenAddress,
        timeout: constants_1.Zero
    };
}
exports.getProposeCoinBalanceRefundAppParams = getProposeCoinBalanceRefundAppParams;
async function deposit(node, multisigAddress, amount = constants_1.One, proposedToNode, tokenAddress) {
    const proposeParams = await getProposeCoinBalanceRefundAppParams(multisigAddress, node.publicIdentifier, proposedToNode.publicIdentifier, tokenAddress);
    await new Promise(async (resolve) => {
        proposedToNode.once(src_1.NODE_EVENTS.PROPOSE_INSTALL, (msg) => {
            resolve();
        });
        node.rpcRouter.dispatch({
            id: Date.now(),
            methodName: types_1.Node.RpcMethodName.PROPOSE_INSTALL,
            parameters: proposeParams
        });
    });
    const depositReq = constructDepositRpc(multisigAddress, amount, tokenAddress);
    return new Promise(async (resolve) => {
        node.once(src_1.NODE_EVENTS.DEPOSIT_CONFIRMED, (msg) => {
            assertNodeMessage(msg, {
                from: node.publicIdentifier,
                type: src_1.NODE_EVENTS.DEPOSIT_CONFIRMED,
                data: {
                    multisigAddress,
                    amount,
                    tokenAddress: tokenAddress || constants_1.AddressZero
                }
            });
            resolve();
        });
        node.once(src_1.NODE_EVENTS.DEPOSIT_STARTED, (msg) => {
            assertNodeMessage(msg, {
                from: node.publicIdentifier,
                type: src_1.NODE_EVENTS.DEPOSIT_STARTED,
                data: {
                    value: amount
                }
            }, ["data.txHash"]);
        });
        await node.rpcRouter.dispatch(depositReq);
    });
}
exports.deposit = deposit;
async function deployStateDepositHolder(node, multisigAddress) {
    const response = await node.rpcRouter.dispatch({
        methodName: types_1.Node.RpcMethodName.DEPLOY_STATE_DEPOSIT_HOLDER,
        parameters: {
            multisigAddress
        }
    });
    const result = response.result
        .result;
    return result.transactionHash;
}
exports.deployStateDepositHolder = deployStateDepositHolder;
function constructDepositRpc(multisigAddress, amount, tokenAddress) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.DEPOSIT,
        parameters: {
            multisigAddress,
            amount,
            tokenAddress
        }
    };
}
exports.constructDepositRpc = constructDepositRpc;
function constructWithdrawCommitmentRpc(multisigAddress, amount, tokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, recipient) {
    const withdrawCommitmentReq = constructWithdrawRpc(multisigAddress, amount, tokenAddress, recipient);
    withdrawCommitmentReq.methodName =
        types_1.Node.RpcMethodName.WITHDRAW_COMMITMENT;
    return withdrawCommitmentReq;
}
exports.constructWithdrawCommitmentRpc = constructWithdrawCommitmentRpc;
function constructWithdrawRpc(multisigAddress, amount, tokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, recipient) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.WITHDRAW,
        parameters: {
            tokenAddress,
            multisigAddress,
            amount,
            recipient
        }
    };
}
exports.constructWithdrawRpc = constructWithdrawRpc;
function constructInstallRpc(appInstanceId) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.INSTALL,
        parameters: {
            appInstanceId
        }
    };
}
exports.constructInstallRpc = constructInstallRpc;
function constructRejectInstallRpc(appInstanceId) {
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.REJECT_INSTALL,
        parameters: {
            appInstanceId
        }
    };
}
exports.constructRejectInstallRpc = constructRejectInstallRpc;
function constructAppProposalRpc(proposedToIdentifier, appDefinition, abiEncodings, initialState, initiatorDeposit = constants_1.Zero, initiatorDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, responderDeposit = constants_1.Zero, responderDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const { outcomeType } = getAppContext(appDefinition, initialState);
    return {
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.PROPOSE_INSTALL,
        parameters: {
            proposedToIdentifier,
            initiatorDeposit,
            initiatorDepositTokenAddress,
            responderDeposit,
            responderDepositTokenAddress,
            appDefinition,
            initialState,
            abiEncodings,
            outcomeType,
            timeout: constants_1.One
        }
    };
}
exports.constructAppProposalRpc = constructAppProposalRpc;
function constructInstallVirtualRpc(appInstanceId, intermediaryIdentifier) {
    return {
        parameters: {
            appInstanceId,
            intermediaryIdentifier
        },
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.INSTALL_VIRTUAL
    };
}
exports.constructInstallVirtualRpc = constructInstallVirtualRpc;
function constructVirtualProposalRpc(proposedToIdentifier, appDefinition, abiEncodings, initialState = {}, initiatorDeposit = constants_1.Zero, initiatorDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, responderDeposit = constants_1.Zero, responderDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const installProposalParams = constructAppProposalRpc(proposedToIdentifier, appDefinition, abiEncodings, initialState, initiatorDeposit, initiatorDepositTokenAddress, responderDeposit, responderDepositTokenAddress).parameters;
    return {
        parameters: installProposalParams,
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.PROPOSE_INSTALL
    };
}
exports.constructVirtualProposalRpc = constructVirtualProposalRpc;
function confirmProposedAppInstance(methodParams, appInstanceProposal, nonInitiatingNode = false) {
    const proposalParams = methodParams;
    expect(proposalParams.abiEncodings).toEqual(appInstanceProposal.abiEncodings);
    expect(proposalParams.appDefinition).toEqual(appInstanceProposal.appDefinition);
    if (nonInitiatingNode) {
        expect(proposalParams.initiatorDeposit).toEqual(utils_1.bigNumberify(appInstanceProposal.responderDeposit));
        expect(proposalParams.responderDeposit).toEqual(utils_1.bigNumberify(appInstanceProposal.initiatorDeposit));
    }
    else {
        expect(proposalParams.initiatorDeposit).toEqual(utils_1.bigNumberify(appInstanceProposal.initiatorDeposit));
        expect(proposalParams.responderDeposit).toEqual(utils_1.bigNumberify(appInstanceProposal.responderDeposit));
    }
    expect(proposalParams.timeout).toEqual(utils_1.bigNumberify(appInstanceProposal.timeout));
}
exports.confirmProposedAppInstance = confirmProposedAppInstance;
function constructGetStateRpc(appInstanceId) {
    return {
        parameters: {
            appInstanceId
        },
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_STATE
    };
}
exports.constructGetStateRpc = constructGetStateRpc;
function constructTakeActionRpc(appInstanceId, action) {
    return {
        parameters: {
            appInstanceId,
            action
        },
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.TAKE_ACTION
    };
}
exports.constructTakeActionRpc = constructTakeActionRpc;
function constructGetAppsRpc() {
    return {
        parameters: {},
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.GET_APP_INSTANCES
    };
}
exports.constructGetAppsRpc = constructGetAppsRpc;
function constructUninstallRpc(appInstanceId) {
    return {
        parameters: {
            appInstanceId
        },
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.UNINSTALL
    };
}
exports.constructUninstallRpc = constructUninstallRpc;
function constructUninstallVirtualRpc(appInstanceId, intermediaryIdentifier) {
    return {
        parameters: {
            appInstanceId,
            intermediaryIdentifier
        },
        id: Date.now(),
        methodName: types_1.Node.RpcMethodName.UNINSTALL_VIRTUAL
    };
}
exports.constructUninstallVirtualRpc = constructUninstallVirtualRpc;
async function collateralizeChannel(multisigAddress, node1, node2, amount = constants_1.One, tokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    await deposit(node1, multisigAddress, amount, node2, tokenAddress);
    await deposit(node2, multisigAddress, amount, node1, tokenAddress);
}
exports.collateralizeChannel = collateralizeChannel;
async function createChannel(nodeA, nodeB) {
    return new Promise(async (resolve) => {
        const sortedOwners = machine_1.xkeysToSortedKthAddresses([nodeA.publicIdentifier, nodeB.publicIdentifier], 0);
        nodeB.once(src_1.NODE_EVENTS.CREATE_CHANNEL, async (msg) => {
            assertNodeMessage(msg, {
                from: nodeA.publicIdentifier,
                type: src_1.NODE_EVENTS.CREATE_CHANNEL,
                data: {
                    owners: sortedOwners,
                    counterpartyXpub: nodeA.publicIdentifier
                }
            }, ["data.multisigAddress"]);
            expect(await getInstalledAppInstances(nodeB)).toEqual([]);
            resolve(msg.data.multisigAddress);
        });
        nodeA.once(src_1.NODE_EVENTS.CREATE_CHANNEL, (msg) => {
            assertNodeMessage(msg, {
                from: nodeA.publicIdentifier,
                type: src_1.NODE_EVENTS.CREATE_CHANNEL,
                data: {
                    owners: sortedOwners,
                    counterpartyXpub: nodeB.publicIdentifier
                }
            }, ["data.multisigAddress"]);
        });
        await getMultisigCreationAddress(nodeA, [
            nodeA.publicIdentifier,
            nodeB.publicIdentifier
        ]);
        expect(await getInstalledAppInstances(nodeA)).toEqual([]);
    });
}
exports.createChannel = createChannel;
async function installApp(nodeA, nodeB, appDefinition, initialState, initiatorDeposit = constants_1.Zero, initiatorDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, responderDeposit = constants_1.Zero, responderDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const appContext = getAppContext(appDefinition, initialState);
    const installationProposalRpc = constructAppProposalRpc(nodeB.publicIdentifier, appContext.appDefinition, appContext.abiEncodings, appContext.initialState, initiatorDeposit, initiatorDepositTokenAddress, responderDeposit, responderDepositTokenAddress);
    const proposedParams = installationProposalRpc.parameters;
    return new Promise(async (resolve) => {
        nodeB.once(src_1.NODE_EVENTS.PROPOSE_INSTALL, async (msg) => {
            assertProposeMessage(nodeA.publicIdentifier, msg, proposedParams);
            const { data: { appInstanceId } } = msg;
            confirmProposedAppInstance(installationProposalRpc.parameters, await getAppInstanceProposal(nodeA, appInstanceId));
            nodeA.once(src_1.NODE_EVENTS.INSTALL, async (msg) => {
                if (msg.data.params.appInstanceId === appInstanceId) {
                    assertInstallMessage(nodeB.publicIdentifier, msg, appInstanceId);
                    const appInstanceNodeA = await getAppInstance(nodeA, appInstanceId);
                    const appInstanceNodeB = await getAppInstance(nodeB, appInstanceId);
                    expect(appInstanceNodeA).toEqual(appInstanceNodeB);
                    resolve([appInstanceId, proposedParams]);
                }
            });
            await nodeB.rpcRouter.dispatch(constructInstallRpc(msg.data.appInstanceId));
        });
        const response = await nodeA.rpcRouter.dispatch(installationProposalRpc);
        const { appInstanceId } = response.result
            .result;
        return appInstanceId;
    });
}
exports.installApp = installApp;
async function installVirtualApp(nodeA, nodeB, nodeC, appDefinition, initialState, assetId, initiatorDeposit, responderDeposit) {
    nodeC.on(src_1.NODE_EVENTS.PROPOSE_INSTALL, async (msg) => {
        const { appInstanceId, params } = await proposal;
        const { data: { appInstanceId: eventAppInstanceId } } = msg;
        if (eventAppInstanceId === appInstanceId) {
            assertProposeMessage(nodeA.publicIdentifier, msg, params);
            await nodeC.rpcRouter.dispatch(constructInstallVirtualRpc(appInstanceId, nodeB.publicIdentifier));
        }
    });
    const proposal = makeVirtualProposal(nodeA, nodeC, appDefinition, initialState, assetId, initiatorDeposit, responderDeposit);
    return new Promise((resolve) => nodeA.on(src_1.NODE_EVENTS.INSTALL_VIRTUAL, async (msg) => {
        const { appInstanceId } = await proposal;
        if (msg.data.params.appInstanceId === appInstanceId) {
            assertNodeMessage(msg, {
                from: nodeC.publicIdentifier,
                type: src_1.NODE_EVENTS.INSTALL_VIRTUAL,
                data: { params: { appInstanceId } }
            });
            resolve(appInstanceId);
        }
    }));
}
exports.installVirtualApp = installVirtualApp;
async function confirmChannelCreation(nodeA, nodeB, ownersFreeBalanceAddress, data) {
    const openChannelsNodeA = await getChannelAddresses(nodeA);
    const openChannelsNodeB = await getChannelAddresses(nodeB);
    expect(openChannelsNodeA.has(data.multisigAddress)).toBeTruthy();
    expect(openChannelsNodeB.has(data.multisigAddress)).toBeTruthy();
    expect(data.owners.sort()).toEqual(ownersFreeBalanceAddress.sort());
}
exports.confirmChannelCreation = confirmChannelCreation;
async function confirmAppInstanceInstallation(proposedParams, appInstance) {
    expect(appInstance.appInterface.addr).toEqual(proposedParams.appDefinition);
    expect(appInstance.appInterface.stateEncoding).toEqual(proposedParams.abiEncodings.stateEncoding);
    expect(appInstance.appInterface.actionEncoding).toEqual(proposedParams.abiEncodings.actionEncoding);
    expect(appInstance.defaultTimeout).toEqual(proposedParams.timeout.toNumber());
    expect(appInstance.latestState).toEqual(proposedParams.initialState);
}
exports.confirmAppInstanceInstallation = confirmAppInstanceInstallation;
async function getState(nodeA, appInstanceId) {
    const getStateReq = constructGetStateRpc(appInstanceId);
    const getStateResult = await nodeA.rpcRouter.dispatch(getStateReq);
    return getStateResult.result.result.state;
}
exports.getState = getState;
async function makeVirtualProposal(nodeA, nodeC, appDefinition, initialState, assetId, initiatorDeposit, responderDeposit) {
    const appContext = getAppContext(appDefinition, initialState);
    const virtualProposalRpc = constructVirtualProposalRpc(nodeC.publicIdentifier, appContext.appDefinition, appContext.abiEncodings, appContext.initialState, initiatorDeposit || constants_1.One, assetId || constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, responderDeposit || constants_1.Zero, assetId || constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
    const params = virtualProposalRpc.parameters;
    const { result: { result: { appInstanceId } } } = await nodeA.rpcRouter.dispatch({
        parameters: params,
        methodName: types_1.Node.RpcMethodName.PROPOSE_INSTALL,
        id: Date.now()
    });
    return { appInstanceId, params };
}
exports.makeVirtualProposal = makeVirtualProposal;
async function installTTTVirtual(node, appInstanceId, intermediaryIdentifier) {
    return await node.rpcRouter.dispatch(constructInstallVirtualRpc(appInstanceId, intermediaryIdentifier));
}
exports.installTTTVirtual = installTTTVirtual;
async function makeInstallCall(node, appInstanceId) {
    return await node.rpcRouter.dispatch(constructInstallRpc(appInstanceId));
}
exports.makeInstallCall = makeInstallCall;
async function makeVirtualProposeCall(nodeA, nodeC, appDefinition, initialState) {
    const appContext = getAppContext(appDefinition, initialState);
    const virtualProposalRpc = constructVirtualProposalRpc(nodeC.publicIdentifier, appContext.appDefinition, appContext.abiEncodings, appContext.initialState);
    const response = await nodeA.rpcRouter.dispatch(virtualProposalRpc);
    return {
        appInstanceId: response.result
            .appInstanceId,
        params: virtualProposalRpc.parameters
    };
}
exports.makeVirtualProposeCall = makeVirtualProposeCall;
function makeProposeCall(nodeB, appDefinition, initialState, initiatorDeposit = constants_1.Zero, initiatorDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, responderDeposit = constants_1.Zero, responderDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const appContext = getAppContext(appDefinition, initialState);
    return constructAppProposalRpc(nodeB.publicIdentifier, appContext.appDefinition, appContext.abiEncodings, appContext.initialState, initiatorDeposit, initiatorDepositTokenAddress, responderDeposit, responderDepositTokenAddress);
}
exports.makeProposeCall = makeProposeCall;
async function makeAndSendProposeCall(nodeA, nodeB, appDefinition, initialState, initiatorDeposit = constants_1.Zero, initiatorDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, responderDeposit = constants_1.Zero, responderDepositTokenAddress = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const installationProposalRpc = makeProposeCall(nodeB, appDefinition, initialState, initiatorDeposit, initiatorDepositTokenAddress, responderDeposit, responderDepositTokenAddress);
    const { result: { result: { appInstanceId } } } = await nodeA.rpcRouter.dispatch(installationProposalRpc);
    return {
        appInstanceId,
        params: installationProposalRpc.parameters
    };
}
exports.makeAndSendProposeCall = makeAndSendProposeCall;
async function transferERC20Tokens(toAddress, tokenAddress = global["networkContext"]["DolphinCoin"], contractABI = contracts_1.DolphinCoin.abi, amount = constants_1.One) {
    const deployerAccount = new ethers_1.Wallet(global["fundedPrivateKey"], new providers_1.JsonRpcProvider(global["ganacheURL"]));
    const contract = new ethers_1.Contract(tokenAddress, contractABI, deployerAccount);
    const balanceBefore = await contract.functions.balanceOf(toAddress);
    await contract.functions.transfer(toAddress, amount);
    const balanceAfter = await contract.functions.balanceOf(toAddress);
    expect(balanceAfter.sub(balanceBefore)).toEqual(amount);
    return balanceAfter;
}
exports.transferERC20Tokens = transferERC20Tokens;
function getAppContext(appDefinition, initialState, senderAddress, receiverAddress) {
    const checkForAddresses = () => {
        const missingAddr = !senderAddress || !receiverAddress;
        if (missingAddr && !initialState) {
            throw new Error("Must have sender and redeemer addresses to generate initial state for either transfer app context");
        }
    };
    switch (appDefinition) {
        case TicTacToeApp:
            return {
                appDefinition,
                abiEncodings: tic_tac_toe_1.tttAbiEncodings,
                initialState: initialState || tic_tac_toe_1.initialEmptyTTTState(),
                outcomeType: types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME
            };
        case UnidirectionalTransferApp:
            checkForAddresses();
            return {
                appDefinition,
                initialState: initialState ||
                    unidirectional_transfer_1.initialTransferState(senderAddress, receiverAddress),
                abiEncodings: unidirectional_transfer_1.transferAbiEncodings,
                outcomeType: types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER
            };
        case UnidirectionalLinkedTransferApp:
            checkForAddresses();
            const { state } = linked_transfer_1.initialLinkedState(senderAddress, receiverAddress);
            return {
                appDefinition,
                initialState: initialState || state,
                abiEncodings: linked_transfer_1.linkedAbiEncodings,
                outcomeType: types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER
            };
        case SimpleTransferApp:
            checkForAddresses();
            return {
                appDefinition,
                initialState: initialState ||
                    simple_transfer_1.initialSimpleTransferState(senderAddress, receiverAddress),
                abiEncodings: simple_transfer_1.simpleTransferAbiEncodings,
                outcomeType: types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER
            };
        default:
            throw new Error(`Proposing the specified app is not supported: ${appDefinition}`);
    }
}
exports.getAppContext = getAppContext;
async function uninstallVirtualApp(node, counterparty, intermediaryPubId, appId) {
    const rpc = constructUninstallVirtualRpc(appId, intermediaryPubId);
    return new Promise(async (resolve) => {
        counterparty.once(src_1.NODE_EVENTS.UNINSTALL_VIRTUAL, (msg) => {
            resolve(msg.data.appInstanceId);
        });
        await node.rpcRouter.dispatch(rpc);
    });
}
exports.uninstallVirtualApp = uninstallVirtualApp;
async function takeAppAction(node, appId, action) {
    const res = await node.rpcRouter.dispatch(constructTakeActionRpc(appId, action));
    return res.result.result;
}
exports.takeAppAction = takeAppAction;
async function uninstallApp(node, counterparty, appId) {
    return new Promise(async (resolve) => {
        counterparty.once(src_1.NODE_EVENTS.UNINSTALL, (msg) => {
            resolve(msg.data.appInstanceId);
        });
        await node.rpcRouter.dispatch(constructUninstallRpc(appId));
    });
}
exports.uninstallApp = uninstallApp;
async function getApps(node) {
    return (await node.rpcRouter.dispatch(constructGetAppsRpc())).result.result
        .appInstances;
}
exports.getApps = getApps;
async function getBalances(nodeA, nodeB, multisigAddress, tokenAddress) {
    let tokenFreeBalanceState = await getFreeBalanceState(nodeA, multisigAddress, tokenAddress);
    const tokenBalanceNodeA = tokenFreeBalanceState[machine_1.xkeyKthAddress(nodeA.publicIdentifier, 0)];
    tokenFreeBalanceState = await getFreeBalanceState(nodeB, multisigAddress, tokenAddress);
    const tokenBalanceNodeB = tokenFreeBalanceState[machine_1.xkeyKthAddress(nodeB.publicIdentifier, 0)];
    return [tokenBalanceNodeA, tokenBalanceNodeB];
}
exports.getBalances = getBalances;
//# sourceMappingURL=utils.js.map