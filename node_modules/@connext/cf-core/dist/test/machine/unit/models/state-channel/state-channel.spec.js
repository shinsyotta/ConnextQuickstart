"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const models_1 = require("../../../../../src/models");
const random_signing_keys_1 = require("../../../integration/random-signing-keys");
const mocks_1 = require("../../../mocks");
describe("StateChannel", () => {
    it("should be able to instantiate", () => {
        const multisigAddress = utils_1.getAddress(utils_1.hexlify(utils_1.randomBytes(20)));
        const xpubs = random_signing_keys_1.getRandomExtendedPubKeys(2);
        const { ProxyFactory } = mocks_1.generateRandomNetworkContext();
        const sc = new models_1.StateChannel(multisigAddress, ProxyFactory, xpubs);
        expect(sc).not.toBe(null);
        expect(sc).not.toBe(undefined);
        expect(sc.multisigAddress).toBe(multisigAddress);
        expect(sc.userNeuteredExtendedKeys).toBe(xpubs);
        expect(sc.numActiveApps).toBe(0);
        expect(sc.numProposedApps).toBe(0);
    });
    describe("should be able to write a channel to a json", () => {
        const multisigAddress = utils_1.getAddress(utils_1.hexlify(utils_1.randomBytes(20)));
        const xpubs = random_signing_keys_1.getRandomExtendedPubKeys(2);
        let sc;
        let json;
        const { IdentityApp, ProxyFactory } = mocks_1.generateRandomNetworkContext();
        beforeAll(() => {
            sc = models_1.StateChannel.setupChannel(IdentityApp, ProxyFactory, multisigAddress, xpubs);
            json = sc.toJson();
        });
        it("it should have app instance arrays", () => {
            expect(json.appInstances).toEqual([]);
        });
        it("should have proposed app instance array", () => {
            expect(json.proposedAppInstances).toEqual([]);
        });
        it("should have a free balance app instance", () => {
            expect(json.freeBalanceAppInstance).toBeDefined();
        });
        it("should not change the user xpubs", () => {
            expect(json.userNeuteredExtendedKeys).toEqual(xpubs);
        });
        it("should not change the multisig address", () => {
            expect(json.multisigAddress).toEqual(multisigAddress);
        });
        it("should have a singleAssetTwoPartyIntermediaryAgreements array", () => {
            expect(json.singleAssetTwoPartyIntermediaryAgreements).toEqual([]);
        });
        it("should have the correct proxy factory address", () => {
            expect(json.proxyFactoryAddress).toEqual(sc.proxyFactoryAddress);
            expect(sc.proxyFactoryAddress).toEqual(ProxyFactory);
        });
    });
    describe("should be able to rehydrate from json", () => {
        const multisigAddress = utils_1.getAddress(utils_1.hexlify(utils_1.randomBytes(20)));
        const xpubs = random_signing_keys_1.getRandomExtendedPubKeys(2);
        const { IdentityApp, ProxyFactory } = mocks_1.generateRandomNetworkContext();
        let sc;
        let json;
        let rehydrated;
        beforeAll(() => {
            sc = models_1.StateChannel.setupChannel(IdentityApp, ProxyFactory, multisigAddress, xpubs);
            json = sc.toJson();
            rehydrated = models_1.StateChannel.fromJson(json);
        });
        it("should work", () => {
            expect(rehydrated).toEqual(sc);
        });
        it("should have app instance maps", () => {
            expect(rehydrated.appInstances).toEqual(sc.appInstances);
        });
        it("should have proposed app instance maps", () => {
            expect(rehydrated.proposedAppInstances).toEqual(sc.proposedAppInstances);
        });
        it("should have a free balance app instance", () => {
            expect(rehydrated.freeBalance).toEqual(sc.freeBalance);
        });
        it("should not change the user xpubs", () => {
            expect(rehydrated.userNeuteredExtendedKeys).toEqual(sc.userNeuteredExtendedKeys);
        });
        it("should not change the multisig address", () => {
            expect(rehydrated.multisigAddress).toEqual(sc.multisigAddress);
        });
        it("should have a singleAssetTwoPartyIntermediaryAgreements array", () => {
            expect(rehydrated.singleAssetTwoPartyIntermediaryAgreements).toEqual(sc.singleAssetTwoPartyIntermediaryAgreements);
        });
    });
});
//# sourceMappingURL=state-channel.spec.js.map