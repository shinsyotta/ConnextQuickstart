import { ethers as eth } from 'ethers';
import { ConnextInternal, IConnextChannelInternalOptions } from '../Connext';
import { IChannelManager } from '../contract/ChannelManager';
import { IHubAPIClient } from '../Hub';
import { Logger } from '../lib';
import { ConnextState } from '../state';
import { ArgsTypes, ChannelManagerChannelDetails, ChannelRow, ChannelState, ChannelStateUpdate, ChannelUpdateReason, CustodialBalanceRow, CustodialWithdrawalRow, EmailRequest, ExchangeRates, HubConfig, LogDescription, Omit, Payment, PaymentProfileConfig, PurchasePayment, PurchasePaymentHubResponse, PurchasePaymentRow, PurchaseRowWithPayments, SignedDepositRequestProposal, Sync, SyncResult, ThreadHistoryItem, ThreadRow, ThreadState, ThreadStateUpdate, Transaction, UnsignedChannelState, UnsignedThreadState, UpdateRequest, WithdrawalParameters } from '../types';
export declare const address: string;
export declare const mnemonic: string;
export declare const privateKey: string;
export declare const ethUrl: string;
export declare class MockConnextInternal extends ConnextInternal {
    mockContract: MockChannelManager;
    mockHub: MockHub;
    constructor(opts?: Partial<IConnextChannelInternalOptions>);
    signChannelState(state: UnsignedChannelState): Promise<ChannelState>;
    signThreadState(state: UnsignedThreadState): Promise<ThreadState>;
    signDepositRequestProposal(args: Omit<SignedDepositRequestProposal, 'sigUser'>): Promise<SignedDepositRequestProposal>;
    getContractEvents(eventName: string, fromBlock: number): Promise<LogDescription[]>;
}
export declare class MockChannelManager implements IChannelManager {
    abi: any;
    contractMethodCalls: any[];
    gasMultiple: number;
    rawAbi: any;
    assertCalled(method: keyof MockChannelManager, ...args: any[]): any;
    userAuthorizedUpdate(state: ChannelState): Promise<any>;
    getPastEvents(eventName: string, user: string[], fromBlock: number): Promise<any>;
    getChannelDetails(user: string): Promise<ChannelManagerChannelDetails>;
    startExit(state: ChannelState): Promise<Transaction>;
    startExitWithUpdate(state: ChannelState): Promise<Transaction>;
    emptyChannelWithChallenge(state: ChannelState): Promise<Transaction>;
    emptyChannel(state: ChannelState): Promise<Transaction>;
    startExitThread(state: ChannelState, threadState: ThreadState, proof: any): Promise<Transaction>;
    startExitThreadWithUpdate(state: ChannelState, threadInitialState: ThreadState, threadUpdateState: ThreadState, proof: any): Promise<Transaction>;
    challengeThread(state: ChannelState, threadState: ThreadState): Promise<Transaction>;
    emptyThread(state: ChannelState, threadState: ThreadState, proof: any): Promise<Transaction>;
    nukeThreads(state: ChannelState): Promise<Transaction>;
}
export declare class MockHub implements IHubAPIClient {
    receivedUpdateRequests: UpdateRequest[];
    log: Logger;
    constructor(logLevel?: number);
    sendEmail(email: EmailRequest): Promise<{
        message: string;
        id: string;
    }>;
    config(): Promise<HubConfig>;
    requestCustodialWithdrawal(): Promise<CustodialWithdrawalRow | undefined>;
    getProfileConfig(): Promise<PaymentProfileConfig | undefined>;
    startProfileSession(): Promise<void>;
    getCustodialBalance(): Promise<CustodialBalanceRow | undefined>;
    getChannelByUser(recipient: string): Promise<ChannelRow>;
    recipientNeedsCollateral(): Promise<string | undefined>;
    redeem(secret: string): Promise<PurchasePaymentHubResponse & {
        amount: Payment;
    }>;
    getChannel(): Promise<ChannelRow>;
    getActiveThreads(): Promise<ThreadState[]>;
    getLastThreadUpdateId(): Promise<number>;
    getAllThreads(): Promise<ThreadState[]>;
    getChannelStateAtNonce(): Promise<ChannelStateUpdate>;
    getThreadInitialStates(): Promise<ThreadState[]>;
    getIncomingThreads(): Promise<ThreadRow[]>;
    getThreadByParties(): Promise<ThreadRow>;
    getPaymentHistory(): Promise<Array<PurchasePaymentRow<string, string>>>;
    getPaymentById(): Promise<PurchaseRowWithPayments<object, string>>;
    sync(txCountGlobal: number, lastThreadUpdateId: number): Promise<Sync>;
    buy<PurchaseMetaType = any, PaymentMetaType = any>(meta: PurchaseMetaType, payments: Array<PurchasePayment<PaymentMetaType>>): Promise<PurchasePaymentHubResponse>;
    requestDeposit(deposit: SignedDepositRequestProposal, txCount: number, lastThreadUpdateId: number): Promise<Sync>;
    requestWithdrawal(params: WithdrawalParameters, txCountGlobal: number): Promise<Sync>;
    requestExchange(weiToSell: string, tokensToSell: string, txCountGlobal: number): Promise<Sync>;
    getExchangeRates(): Promise<ExchangeRates>;
    requestCollateral(txCountGlobal: number): Promise<Sync>;
    updateHub(updates: UpdateRequest[], lastThreadUpdateId: number): Promise<{
        error: undefined;
        updates: Sync;
    }>;
    updateThread(update: ThreadStateUpdate): Promise<ThreadStateUpdate>;
    getLatestChannelStateAndUpdate(): Promise<any>;
    getLatestStateNoPendingOps(): Promise<ChannelState | undefined>;
    assertReceivedUpdate(expected: PartialUpdateRequest): any;
}
interface PartialUpdateRequest {
    reason: ChannelUpdateReason;
    args: Partial<ArgsTypes>;
    txCount?: number;
    sigUser?: number | boolean;
    sigHub?: number | boolean;
}
export declare class MockStore {
    _initialState: ConnextState;
    createStore: any;
    setInitialConnextState: (state: ConnextState) => any;
    setExchangeRate: (rates: ExchangeRates) => any;
    setSyncResultsFromHub: (syncResultsFromHub: SyncResult<string>[]) => any;
    setChannel: (overrides?: Partial<import(".").SuccinctChannelState<string | number | eth.utils.BigNumber> & UnsignedChannelState<string | number | eth.utils.BigNumber> & {
        sigUser: string;
        sigHub: string;
    }> | Partial<import(".").SuccinctChannelState<string | number | eth.utils.BigNumber> & UnsignedChannelState<string | number | eth.utils.BigNumber> & {
        sigUser?: string | undefined;
        sigHub: string;
    }> | Partial<import(".").SuccinctChannelState<string | number | eth.utils.BigNumber> & UnsignedChannelState<string | number | eth.utils.BigNumber> & {
        sigUser: string;
        sigHub?: string | undefined;
    }>) => any;
    setHubAddress: (hubAddress?: string) => any;
    setLatestPending: (invalidTxCount: number, overrides?: any) => any;
    setChannelUpdate: (update: UpdateRequest<string, ArgsTypes<string>>) => any;
    addThread: (overrides: Partial<import(".").SuccinctThreadState<string | number | eth.utils.BigNumber> & UnsignedThreadState<string | number | eth.utils.BigNumber> & {
        sigA: string;
    }>) => any;
    updateThread: (threadHistoryItem: ThreadHistoryItem, payment: Payment<eth.utils.BigNumber>) => any;
    setThreadHistory: (threadHistory: ThreadHistoryItem[]) => any;
    setLastThreadUpdateId: (lastThreadUpdateId: number) => any;
    setSyncControllerState: (syncResults: SyncResult<string>[]) => any;
}
/**
 * Patch a function.
 *
 * Will set `host[attr]` to a function which will call `func`, providing the
 * old function as the frist argument.
 *
 * For example, to patch `console.log` so all log lines would be prefixed with
 * '[LOG]':
 *
 *  patch(console, 'log', (old, ...args) => {
 *    old.call(this, '[LOG] ', ...args)
 *  })
 */
export declare const patch: <T, Attr_1 extends keyof T>(host: T, attr: Attr_1, func: any) => any;
export {};
