"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const free_balance_1 = require("../../models/free-balance");
const types_1 = require("../../types");
const utils_2 = require("../../utils");
async function computeTokenIndexedFreeBalanceIncrements(appInstance, provider, encodedOutcomeOverride = "", blockNumberToUseIfNecessary) {
    const { outcomeType } = appInstance;
    const encodedOutcome = encodedOutcomeOverride ||
        (await appInstance.computeOutcomeWithCurrentState(provider));
    if (appInstance.state["threshold"] !== undefined) {
        return handleRefundAppOutcomeSpecialCase(encodedOutcome, appInstance, provider, blockNumberToUseIfNecessary);
    }
    switch (outcomeType) {
        case types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME: {
            return handleTwoPartyFixedOutcome(encodedOutcome, appInstance.twoPartyOutcomeInterpreterParams);
        }
        case types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER: {
            return handleSingleAssetTwoPartyCoinTransfer(encodedOutcome, appInstance.singleAssetTwoPartyCoinTransferInterpreterParams);
        }
        case types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER: {
            return handleMultiAssetMultiPartyCoinTransfer(encodedOutcome, appInstance.multiAssetMultiPartyCoinTransferInterpreterParams);
        }
        default: {
            throw Error("computeTokenIndexedFreeBalanceIncrements received an AppInstance with unknown OutcomeType");
        }
    }
}
exports.computeTokenIndexedFreeBalanceIncrements = computeTokenIndexedFreeBalanceIncrements;
async function handleRefundAppOutcomeSpecialCase(encodedOutcome, appInstance, provider, blockNumberToUseIfNecessary) {
    let mutableOutcome = encodedOutcome;
    let attempts = 1;
    while (attempts <= 10) {
        const [{ to, amount }] = decodeRefundAppState(mutableOutcome);
        const currentBlockNumber = await provider.getBlockNumber();
        const blockNumberSpecifiedAndElapsed = blockNumberToUseIfNecessary &&
            currentBlockNumber >= blockNumberToUseIfNecessary;
        if (amount.gt(0) || blockNumberSpecifiedAndElapsed) {
            return {
                [appInstance.state.tokenAddress]: {
                    [to]: amount
                }
            };
        }
        attempts += 1;
        await utils_2.wait(1000 * attempts);
        mutableOutcome = await appInstance.computeOutcomeWithCurrentState(provider);
    }
    throw Error("When attempting to check for a deposit having been made to the multisig, did not find any non-zero deposits.");
}
function handleTwoPartyFixedOutcome(encodedOutcome, interpreterParams) {
    const { amount, playerAddrs, tokenAddress } = interpreterParams;
    switch (decodeTwoPartyFixedOutcome(encodedOutcome)) {
        case types_1.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE:
            return {
                [tokenAddress]: {
                    [playerAddrs[0]]: amount
                }
            };
        case types_1.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO:
            return {
                [tokenAddress]: {
                    [playerAddrs[1]]: amount
                }
            };
        case types_1.TwoPartyFixedOutcome.SPLIT_AND_SEND_TO_BOTH_ADDRS:
        default:
            return {
                [tokenAddress]: {
                    [playerAddrs[0]]: amount.div(2),
                    [playerAddrs[1]]: amount.sub(amount.div(2))
                }
            };
    }
}
function handleMultiAssetMultiPartyCoinTransfer(encodedOutcome, interpreterParams) {
    const decodedTransfers = decodeMultiAssetMultiPartyCoinTransfer(encodedOutcome);
    return interpreterParams.tokenAddresses.reduce((acc, tokenAddress, index) => (Object.assign({}, acc, { [tokenAddress]: free_balance_1.convertCoinTransfersToCoinTransfersMap(decodedTransfers[index]) })), {});
}
function handleSingleAssetTwoPartyCoinTransfer(encodedOutcome, interpreterParams) {
    const { tokenAddress } = interpreterParams;
    const [{ to: to1, amount: amount1 }, { to: to2, amount: amount2 }] = decodeSingleAssetTwoPartyCoinTransfer(encodedOutcome);
    return {
        [tokenAddress]: {
            [to1]: amount1,
            [to2]: amount2
        }
    };
}
function decodeRefundAppState(encodedOutcome) {
    const [[{ to, amount }]] = utils_1.defaultAbiCoder.decode(["tuple(address to, uint256 amount)[2]"], encodedOutcome);
    return [{ to, amount }];
}
function decodeTwoPartyFixedOutcome(encodedOutcome) {
    const [twoPartyFixedOutcome] = utils_1.defaultAbiCoder.decode(["uint256"], encodedOutcome);
    return twoPartyFixedOutcome.toNumber();
}
function decodeSingleAssetTwoPartyCoinTransfer(encodedOutcome) {
    const [[[to1, amount1], [to2, amount2]]] = utils_1.defaultAbiCoder.decode(["tuple(address to, uint256 amount)[2]"], encodedOutcome);
    return [
        { to: to1, amount: amount1 },
        { to: to2, amount: amount2 }
    ];
}
function decodeMultiAssetMultiPartyCoinTransfer(encodedOutcome) {
    const [coinTransferListOfLists] = utils_1.defaultAbiCoder.decode([types_1.multiAssetMultiPartyCoinTransferEncoding], encodedOutcome);
    return coinTransferListOfLists.map(coinTransferList => coinTransferList.map(({ to, amount }) => ({ to, amount })));
}
//# sourceMappingURL=get-outcome-increments.js.map