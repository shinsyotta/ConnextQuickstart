"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../../src/constants");
const ethereum_1 = require("../../../src/ethereum");
const xkeys_1 = require("../../../src/machine/xkeys");
const models_1 = require("../../../src/models");
const free_balance_1 = require("../../../src/models/free-balance");
const install_virtual_app_1 = require("../../../src/protocol/install-virtual-app");
const contracts_1 = require("../../contracts");
const utils_2 = require("../../integration/utils");
const bignumber_jest_matcher_1 = require("./bignumber-jest-matcher");
const connect_ganache_1 = require("./connect-ganache");
const random_signing_keys_1 = require("./random-signing-keys");
const CREATE_PROXY_AND_SETUP_GAS = 1e6;
const SETSTATE_COMMITMENT_GAS = 1e6;
let provider;
let wallet;
let network;
let appRegistry;
let erc20ContractAddress;
let erc20Contract;
let multisigOwnerKeys;
let xpubs;
const capitalProvider = ethers_1.Wallet.createRandom().address;
const virtualAppUser = ethers_1.Wallet.createRandom().address;
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
let twoPartyFixedOutcomeAppDefinition;
let proxyFactory;
beforeAll(async () => {
    jest.setTimeout(10000);
    [provider, wallet, {}] = await connect_ganache_1.connectToGanache();
    network = global["networkContext"];
    appRegistry = new ethers_1.Contract(network.ChallengeRegistry, contracts_1.ChallengeRegistry.abi, wallet);
    erc20ContractAddress = network.DolphinCoin;
    erc20Contract = new ethers_1.Contract(erc20ContractAddress, contracts_1.DolphinCoin.abi, new providers_1.JsonRpcProvider(global["ganacheURL"]));
    twoPartyFixedOutcomeAppDefinition = await new ethers_1.ContractFactory(contracts_1.TwoPartyFixedOutcomeApp.abi, contracts_1.TwoPartyFixedOutcomeApp.evm.bytecode, wallet).deploy();
    proxyFactory = new ethers_1.Contract(network.ProxyFactory, contracts_1.ProxyFactory.abi, wallet);
});
describe("Scenario: Install virtual app with and put on-chain", () => {
    let globalChannelNonce = 0;
    let createProxy;
    let fundWithETH;
    let fundWithDolphinCoin;
    let setupChannel;
    let createTargetAppInstance;
    let setStatesAndOutcomes;
    beforeEach(async () => {
        const xprvs = random_signing_keys_1.getRandomExtendedPrvKeys(2);
        multisigOwnerKeys = xkeys_1.xkeysToSortedKthSigningKeys(xprvs, 0);
        xpubs = xprvs.map(random_signing_keys_1.extendedPrvKeyToExtendedPubKey);
        globalChannelNonce += 1;
        createProxy = async function () {
            await proxyFactory.functions.createProxyWithNonce(network.MinimumViableMultisig, new utils_1.Interface(contracts_1.MinimumViableMultisig.abi).functions.setup.encode([
                multisigOwnerKeys.map(x => x.address)
            ]), 0, { gasLimit: CREATE_PROXY_AND_SETUP_GAS });
        };
        fundWithETH = async function (wallet, proxyAddress, amount) {
            await wallet.sendTransaction({
                to: proxyAddress,
                value: amount
            });
        };
        fundWithDolphinCoin = async function (proxyAddress, amount) {
            await utils_2.transferERC20Tokens(proxyAddress, erc20ContractAddress, erc20Contract.abi, amount);
        };
        setupChannel = async function (proxyAddress, tokenAmounts, tokenAddress) {
            return models_1.StateChannel.setupChannel(network.IdentityApp, proxyFactory.address, proxyAddress, xpubs).setFreeBalance(free_balance_1.FreeBalanceClass.createWithFundedTokenAmounts(multisigOwnerKeys.map(key => key.address), tokenAmounts, [tokenAddress]));
        };
        createTargetAppInstance = function () {
            return new models_1.AppInstance(multisigOwnerKeys.map(x => x.address), 0, {
                addr: twoPartyFixedOutcomeAppDefinition.address,
                stateEncoding: "uint256",
                actionEncoding: undefined
            }, true, globalChannelNonce, 2, 1, 0, types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME, {
                playerAddrs: [constants_1.AddressZero, constants_1.AddressZero],
                amount: constants_1.Zero,
                tokenAddress: constants_1.AddressZero
            }, undefined, undefined);
        };
        setStatesAndOutcomes = async function (targetAppInstance, stateChannel) {
            const setStateCommitment = new ethereum_1.SetStateCommitment(network, targetAppInstance.identity, targetAppInstance.hashOfLatestState, targetAppInstance.versionNumber, targetAppInstance.timeout);
            const setStateTx = setStateCommitment.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(setStateCommitment.hashToSign()),
                multisigOwnerKeys[1].signDigest(setStateCommitment.hashToSign())
            ]);
            await wallet.sendTransaction(Object.assign({}, setStateTx, { gasLimit: SETSTATE_COMMITMENT_GAS }));
            const setStateCommitmentForFreeBalance = new ethereum_1.SetStateCommitment(network, stateChannel.freeBalance.identity, stateChannel.freeBalance.hashOfLatestState, stateChannel.freeBalance.versionNumber, 0);
            await wallet.sendTransaction(Object.assign({}, setStateCommitmentForFreeBalance.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(setStateCommitmentForFreeBalance.hashToSign()),
                multisigOwnerKeys[1].signDigest(setStateCommitmentForFreeBalance.hashToSign())
            ]), { gasLimit: SETSTATE_COMMITMENT_GAS }));
            await appRegistry.functions.setOutcome(targetAppInstance.identity, targetAppInstance.encodedLatestState);
            await appRegistry.functions.setOutcome(stateChannel.freeBalance.identity, stateChannel.freeBalance.encodedLatestState);
        };
    });
    it("returns the ERC20", async (done) => {
        proxyFactory.once("ProxyCreation", async (proxyAddress) => {
            await fundWithDolphinCoin(proxyAddress, utils_1.parseEther("10"));
            let stateChannel = await setupChannel(proxyAddress, utils_1.parseEther("5"), erc20ContractAddress);
            const targetAppInstance = createTargetAppInstance();
            const agreement = {
                capitalProvider,
                virtualAppUser,
                capitalProvided: utils_1.parseEther("10").toHexString(),
                tokenAddress: erc20Contract.address,
                timeLockedPassThroughIdentityHash: constants_1.HashZero
            };
            stateChannel = stateChannel.addSingleAssetTwoPartyIntermediaryAgreement(targetAppInstance.identityHash, agreement, {
                [multisigOwnerKeys[0].address]: utils_1.parseEther("5"),
                [multisigOwnerKeys[1].address]: utils_1.parseEther("5")
            }, erc20Contract.address);
            await setStatesAndOutcomes(targetAppInstance, stateChannel);
            const commitment = new ethereum_1.ConditionalTransaction(network, proxyAddress, multisigOwnerKeys.map(x => x.address), targetAppInstance.identityHash, stateChannel.freeBalance.identityHash, network.TwoPartyFixedOutcomeFromVirtualAppInterpreter, install_virtual_app_1.encodeSingleAssetTwoPartyIntermediaryAgreementParams(agreement));
            await wallet.sendTransaction(Object.assign({}, commitment.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(commitment.hashToSign()),
                multisigOwnerKeys[1].signDigest(commitment.hashToSign())
            ]), { gasLimit: 6e9 }));
            expect(await erc20Contract.functions.balanceOf(capitalProvider)).toBeEq(utils_1.parseEther("5"));
            expect(await erc20Contract.functions.balanceOf(virtualAppUser)).toBeEq(utils_1.parseEther("5"));
            done();
        });
        await createProxy();
    });
    it("returns the ETH ", async (done) => {
        proxyFactory.once("ProxyCreation", async (proxyAddress) => {
            await fundWithETH(wallet, proxyAddress, utils_1.parseEther("10"));
            let stateChannel = await setupChannel(proxyAddress, utils_1.parseEther("5"), constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
            const targetAppInstance = createTargetAppInstance();
            const agreement = {
                capitalProvider,
                virtualAppUser,
                capitalProvided: utils_1.parseEther("10").toHexString(),
                tokenAddress: constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS,
                timeLockedPassThroughIdentityHash: constants_1.HashZero
            };
            stateChannel = stateChannel.addSingleAssetTwoPartyIntermediaryAgreement(targetAppInstance.identityHash, agreement, {
                [multisigOwnerKeys[0].address]: utils_1.parseEther("5"),
                [multisigOwnerKeys[1].address]: utils_1.parseEther("5")
            }, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
            await setStatesAndOutcomes(targetAppInstance, stateChannel);
            const commitment = new ethereum_1.ConditionalTransaction(network, proxyAddress, multisigOwnerKeys.map(x => x.address), targetAppInstance.identityHash, stateChannel.freeBalance.identityHash, network.TwoPartyFixedOutcomeFromVirtualAppInterpreter, install_virtual_app_1.encodeSingleAssetTwoPartyIntermediaryAgreementParams(agreement));
            await wallet.sendTransaction(Object.assign({}, commitment.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(commitment.hashToSign()),
                multisigOwnerKeys[1].signDigest(commitment.hashToSign())
            ]), { gasLimit: 6e9 }));
            expect(await provider.getBalance(capitalProvider)).toBeEq(utils_1.parseEther("5"));
            expect(await provider.getBalance(virtualAppUser)).toBeEq(utils_1.parseEther("5"));
            done();
        });
        await createProxy();
    });
});
//# sourceMappingURL=install-virtual.spec.js.map