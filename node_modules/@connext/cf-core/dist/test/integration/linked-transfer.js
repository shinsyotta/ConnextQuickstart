"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../src/constants");
const singleAssetTwoPartyCoinTransferEncoding = `
tuple(address to, uint256 amount)[2]
`;
exports.linkedAbiEncodings = {
    stateEncoding: `
    tuple(
      uint8 stage,
      ${singleAssetTwoPartyCoinTransferEncoding} transfers,
      bytes32 linkedHash,
      uint256 turnNum,
      bool finalized
    )`,
    actionEncoding: `
    tuple(
      uint256 amount,
      address assetId,
      bytes32 paymentId,
      bytes32 preImage
    )`
};
function validAction(amount = 1, assetId = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    return {
        assetId,
        amount: utils_1.bigNumberify(amount),
        paymentId: utils_1.hexlify(utils_1.randomBytes(32)),
        preImage: utils_1.hexlify(utils_1.randomBytes(32))
    };
}
exports.validAction = validAction;
function createLinkedHash(action) {
    return utils_1.solidityKeccak256(["uint256", "address", "bytes32", "bytes32"], [action.amount, action.assetId, action.paymentId, action.preImage]);
}
function initialLinkedState(senderAddr, redeemerAddr, amount = 1, assetId = constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
    const action = validAction(amount, assetId);
    const linkedHash = createLinkedHash(action);
    return {
        action,
        state: {
            linkedHash,
            stage: 0,
            finalized: false,
            turnNum: constants_1.Zero,
            transfers: [
                {
                    amount: utils_1.bigNumberify(amount),
                    to: senderAddr
                },
                {
                    amount: constants_1.Zero,
                    to: redeemerAddr
                }
            ]
        }
    };
}
exports.initialLinkedState = initialLinkedState;
//# sourceMappingURL=linked-transfer.js.map