import { BaseProvider } from "ethers/providers";
import { RequestHandler } from "./request-handler";
import RpcRouter from "./rpc-router";
import { NetworkContext, Node as NodeTypes } from "./types";
export interface NodeConfig {
    STORE_KEY_PREFIX: string;
}
export declare class Node {
    private readonly publicExtendedKey;
    private readonly privateKeyGetter;
    private readonly messagingService;
    private readonly storeService;
    private readonly nodeConfig;
    private readonly provider;
    readonly networkContext: NetworkContext;
    readonly blocksNeededForConfirmation: number;
    private readonly lockService?;
    private readonly incoming;
    private readonly outgoing;
    private readonly protocolRunner;
    private readonly ioSendDeferrals;
    private signer;
    protected requestHandler: RequestHandler;
    rpcRouter: RpcRouter;
    static create(messagingService: NodeTypes.IMessagingService, storeService: NodeTypes.IStoreService, networkContext: NetworkContext, nodeConfig: NodeConfig, provider: BaseProvider, lockService?: NodeTypes.ILockService, publicExtendedKey?: string, privateKeyGenerator?: NodeTypes.IPrivateKeyGenerator, blocksNeededForConfirmation?: number): Promise<Node>;
    private constructor();
    private asynchronouslySetupUsingRemoteServices;
    readonly publicIdentifier: string;
    signerAddress(): Promise<string>;
    readonly freeBalanceAddress: string;
    private buildProtocolRunner;
    on(event: string, callback: (res: any) => void): void;
    off(event: string, callback?: (res: any) => void): void;
    once(event: string, callback: (res: any) => void): void;
    emit(event: string, req: NodeTypes.MethodRequest): void;
    call(method: NodeTypes.MethodName, req: NodeTypes.MethodRequest): Promise<NodeTypes.MethodResponse>;
    private registerMessagingConnection;
    private handleReceivedMessage;
    private handleIoSendDeferral;
}
//# sourceMappingURL=node.d.ts.map