"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../constants");
const free_balance_app_1 = require("../ethereum/utils/free-balance-app");
const xkeys_1 = require("../machine/xkeys");
const types_1 = require("../types");
const utils_2 = require("../utils");
const app_instance_1 = require("./app-instance");
const HARD_CODED_ASSUMPTIONS = {
    freeBalanceInitialStateTimeout: 172800,
    appSequenceNumberForFreeBalance: 0,
};
class FreeBalanceClass {
    constructor(activeAppsMap, balancesIndexedByToken) {
        this.activeAppsMap = activeAppsMap;
        this.balancesIndexedByToken = balancesIndexedByToken;
    }
    toFreeBalanceState() {
        return {
            activeAppsMap: this.activeAppsMap,
            balancesIndexedByToken: this.balancesIndexedByToken
        };
    }
    toTokenIndexedCoinTransferMap() {
        const ret = {};
        for (const tokenAddress of Object.keys(this.balancesIndexedByToken)) {
            ret[tokenAddress] = convertCoinTransfersToCoinTransfersMap(this.balancesIndexedByToken[tokenAddress]);
        }
        return ret;
    }
    toAppInstance(oldAppInstance) {
        return oldAppInstance.setState(serializeFreeBalanceState(this.toFreeBalanceState()));
    }
    static createWithFundedTokenAmounts(addresses, amount, tokenAddresses) {
        return new FreeBalanceClass({}, tokenAddresses.reduce((balancesIndexedByToken, tokenAddress) => (Object.assign({}, balancesIndexedByToken, { [tokenAddress]: addresses.map(to => ({ to, amount })) })), {}));
    }
    static fromAppInstance(appInstance) {
        const freeBalanceState = deserializeFreeBalanceState(appInstance.state);
        return new FreeBalanceClass(freeBalanceState.activeAppsMap, freeBalanceState.balancesIndexedByToken);
    }
    getBalance(tokenAddress, beneficiary) {
        try {
            return convertCoinTransfersToCoinTransfersMap(this.balancesIndexedByToken[tokenAddress])[beneficiary];
        }
        catch (_a) {
            return constants_1.Zero;
        }
    }
    withTokenAddress(tokenAddress) {
        let balances = {};
        balances = convertCoinTransfersToCoinTransfersMap(this.balancesIndexedByToken[tokenAddress]);
        if (Object.keys(balances).length === 0) {
            const addresses = Object.keys(convertCoinTransfersToCoinTransfersMap(this.balancesIndexedByToken[constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]));
            for (const address of addresses) {
                balances[address] = constants_1.Zero;
            }
        }
        return balances;
    }
    removeActiveApp(activeApp) {
        delete this.activeAppsMap[activeApp];
        return this;
    }
    addActiveApp(activeApp) {
        this.activeAppsMap[activeApp] = true;
        return this;
    }
    prettyPrint() {
        const balances = this.balancesIndexedByToken;
        const ret = {};
        for (const tokenAddress of Object.keys(balances)) {
            const ret2 = {};
            for (const coinTransfer of balances[tokenAddress]) {
                ret2[coinTransfer.to] = coinTransfer.amount;
            }
            ret[tokenAddress] = ret2;
        }
        console.table(ret);
    }
    increment(increments) {
        for (const tokenAddress of Object.keys(increments)) {
            const t1 = convertCoinTransfersToCoinTransfersMap(this.balancesIndexedByToken[tokenAddress]);
            const t2 = free_balance_app_1.merge(t1, increments[tokenAddress]);
            for (const val of Object.values(t2)) {
                if (val.lt(constants_1.Zero)) {
                    throw Error(`FreeBalanceClass::increment ended up with a negative balance when
            merging ${utils_2.prettyPrintObject(t1)} and ${utils_2.prettyPrintObject(increments[tokenAddress])}`);
                }
            }
            this.balancesIndexedByToken[tokenAddress] = convertCoinTransfersMapToCoinTransfers(t2);
        }
        return this;
    }
}
exports.FreeBalanceClass = FreeBalanceClass;
function createFreeBalance(userNeuteredExtendedKeys, coinBucketAddress, freeBalanceTimeout) {
    const sortedTopLevelKeys = xkeys_1.xkeysToSortedKthAddresses(userNeuteredExtendedKeys, 0);
    const initialState = {
        activeAppsMap: {},
        balancesIndexedByToken: {
            [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]: [
                { to: sortedTopLevelKeys[0], amount: constants_1.Zero },
                { to: sortedTopLevelKeys[1], amount: constants_1.Zero }
            ]
        }
    };
    return new app_instance_1.AppInstance(sortedTopLevelKeys, freeBalanceTimeout, free_balance_app_1.getFreeBalanceAppInterface(coinBucketAddress), false, HARD_CODED_ASSUMPTIONS.appSequenceNumberForFreeBalance, serializeFreeBalanceState(initialState), 0, HARD_CODED_ASSUMPTIONS.freeBalanceInitialStateTimeout, types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER);
}
exports.createFreeBalance = createFreeBalance;
function deserializeFreeBalanceState(freeBalanceStateJSON) {
    const { activeApps, tokenAddresses, balances } = freeBalanceStateJSON;
    return {
        balancesIndexedByToken: (tokenAddresses || []).reduce((acc, tokenAddress, idx) => (Object.assign({}, acc, { [utils_1.getAddress(tokenAddress)]: balances[idx].map(({ to, amount }) => ({
                to,
                amount: utils_1.bigNumberify(amount._hex)
            })) })), {}),
        activeAppsMap: (activeApps || []).reduce((acc, identityHash) => (Object.assign({}, acc, { [identityHash]: true })), {})
    };
}
function serializeFreeBalanceState(freeBalanceState) {
    return {
        activeApps: Object.keys(freeBalanceState.activeAppsMap),
        tokenAddresses: Object.keys(freeBalanceState.balancesIndexedByToken),
        balances: Object.values(freeBalanceState.balancesIndexedByToken).map(balances => balances.map(({ to, amount }) => ({
            to,
            amount: {
                _hex: amount.toHexString()
            }
        })))
    };
}
function convertCoinTransfersToCoinTransfersMap(coinTransfers) {
    return (coinTransfers || []).reduce((acc, { to, amount }) => (Object.assign({}, acc, { [to]: amount })), {});
}
exports.convertCoinTransfersToCoinTransfersMap = convertCoinTransfersToCoinTransfersMap;
function convertCoinTransfersMapToCoinTransfers(coinTransfersMap) {
    return Object.entries(coinTransfersMap).map(([to, amount]) => ({
        to,
        amount
    }));
}
function getFreeBalanceAddress(publicIdentifier) {
    return xkeys_1.xkeyKthAddress(publicIdentifier, 0);
}
exports.getFreeBalanceAddress = getFreeBalanceAddress;
//# sourceMappingURL=free-balance.js.map