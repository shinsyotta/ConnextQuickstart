"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function jsonApiType(name) {
    return (target) => {
        target.jsonapiType = name;
        const functions = Object.getOwnPropertyNames(target.prototype).filter(key => key !== "constructor");
        // Type overriden operations.
        functions
            .filter(func => Object.values(target.rpcMethods).find(method => method.callback === func))
            .forEach(method => {
            const descriptor = Object.entries(target.rpcMethods).find(([, mapping]) => mapping.callback === method && mapping.method.includes("[type]"));
            if (!descriptor) {
                return;
            }
            const [key, originalMapping] = descriptor;
            target.rpcMethods[key] = {
                ...target.rpcMethods[key],
                method: originalMapping.method.replace("[type]", target.jsonapiType)
            };
        });
        // Map new functions.
        functions
            .filter(func => !Object.values(target.rpcMethods).find(method => method.callback === func))
            .forEach(method => {
            jsonApiOperation(method, target)(target.prototype, method);
        });
    };
}
exports.jsonApiType = jsonApiType;
function jsonApiOperation(name, forcedConstructor) {
    return (target, propertyKey) => {
        const constructor = forcedConstructor || target.constructor;
        const key = `${target.constructor.name}:${name}`;
        constructor.rpcMethods[key] = {
            method: `${constructor.jsonapiType || "[type]"}:${name}`,
            callback: propertyKey,
            type: constructor
        };
    };
}
exports.jsonApiOperation = jsonApiOperation;
function jsonApiDeserialize(payload) {
    return {
        methodName: `${payload.ref.type}:${payload.op}`,
        parameters: payload
    };
}
exports.jsonApiDeserialize = jsonApiDeserialize;
//# sourceMappingURL=jsonapi.js.map