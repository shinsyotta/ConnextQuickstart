"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const machine_1 = require("../../../src/machine");
const random_signing_keys_1 = require("./random-signing-keys");
const makeSigner = (hdNode) => {
    return async (args) => {
        if (args.length !== 1 && args.length !== 2) {
            throw Error("OP_SIGN middleware received wrong number of arguments.");
        }
        const [commitment, overrideKeyIndex] = args;
        const keyIndex = overrideKeyIndex || 0;
        const signingKey = new utils_1.SigningKey(hdNode.derivePath(`${keyIndex}`).privateKey);
        return signingKey.signDigest(commitment.hashToSign());
    };
};
class MiniNode {
    constructor(networkContext, provider) {
        this.networkContext = networkContext;
        this.provider = provider;
        [this.hdNode] = random_signing_keys_1.getRandomHDNodes(1);
        this.xpub = this.hdNode.neuter().extendedKey;
        this.scm = new Map();
        this.protocolRunner = new machine_1.ProtocolRunner(networkContext, provider);
        this.protocolRunner.register(machine_1.Opcode.OP_SIGN, makeSigner(this.hdNode));
        this.protocolRunner.register(machine_1.Opcode.WRITE_COMMITMENT, () => { });
        this.protocolRunner.register(machine_1.Opcode.PERSIST_STATE_CHANNEL, () => { });
    }
    async dispatchMessage(message) {
        this.scm = await this.protocolRunner.runProtocolWithMessage(message, this.scm);
    }
}
exports.MiniNode = MiniNode;
//# sourceMappingURL=mininode.js.map