"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const ts_mockito_1 = require("ts-mockito");
const src_1 = require("../../src");
const constants_2 = require("../../src/constants");
const machine_1 = require("../../src/machine");
const operation_1 = require("../../src/methods/app-instance/install/operation");
const models_1 = require("../../src/models");
const store_1 = require("../../src/store");
const random_signing_keys_1 = require("../machine/integration/random-signing-keys");
const memory_store_service_1 = require("../services/memory-store-service");
const utils_2 = require("./utils");
const NETWORK_CONTEXT_OF_ALL_ZERO_ADDRESSES = types_1.EXPECTED_CONTRACT_NAMES_IN_NETWORK_CONTEXT.reduce((acc, contractName) => (Object.assign({}, acc, { [contractName]: constants_1.AddressZero })), {});
describe("Can handle correct & incorrect installs", () => {
    let store;
    let protocolRunner;
    let initiatorIdentifier;
    beforeAll(() => {
        store = new store_1.Store(new memory_store_service_1.MemoryStoreService(), "install.spec.ts-test-store");
        protocolRunner = new machine_1.ProtocolRunner(NETWORK_CONTEXT_OF_ALL_ZERO_ADDRESSES, {});
        initiatorIdentifier = utils_1.HDNode.fromMnemonic(ethers_1.Wallet.createRandom().mnemonic).neuter().extendedKey;
    });
    it("fails to install with undefined appInstanceId", async () => {
        await expect(operation_1.install(store, protocolRunner, { appInstanceId: undefined }, initiatorIdentifier)).rejects.toThrowError(src_1.NO_APP_INSTANCE_ID_TO_INSTALL);
    });
    it("fails to install with empty string appInstanceId", async () => {
        await expect(operation_1.install(store, protocolRunner, { appInstanceId: "" }, initiatorIdentifier)).rejects.toThrowError(src_1.NO_APP_INSTANCE_ID_TO_INSTALL);
    });
    it("fails to install without the AppInstance being proposed first", async () => {
        await expect(operation_1.install(store, protocolRunner, { appInstanceId: constants_1.HashZero }, initiatorIdentifier)).rejects.toThrowError(src_1.NO_MULTISIG_FOR_APP_INSTANCE_ID);
    });
    it("fails to install without the AppInstanceId being in a channel", async () => {
        expect.hasAssertions();
        const mockedStore = ts_mockito_1.mock(store_1.Store);
        const appInstanceId = utils_1.hexlify(utils_1.randomBytes(32));
        const appInstanceProposal = utils_2.createAppInstanceProposalForTest(appInstanceId);
        ts_mockito_1.when(mockedStore.getAppInstanceProposal(appInstanceId)).thenResolve(appInstanceProposal);
        ts_mockito_1.when(mockedStore.getChannelFromAppInstanceID(appInstanceId)).thenThrow(Error(src_1.NO_MULTISIG_FOR_APP_INSTANCE_ID));
        await expect(operation_1.install(ts_mockito_1.instance(mockedStore), protocolRunner, { appInstanceId }, initiatorIdentifier)).rejects.toThrowError(src_1.NO_MULTISIG_FOR_APP_INSTANCE_ID);
    });
    it("succeeds to install a proposed AppInstance", async () => {
        const mockedProtocolRunner = ts_mockito_1.mock(machine_1.ProtocolRunner);
        const protocolRunner = ts_mockito_1.instance(mockedProtocolRunner);
        const mockedStore = ts_mockito_1.mock(store_1.Store);
        const store = ts_mockito_1.instance(mockedStore);
        const appInstanceId = utils_1.hexlify(utils_1.randomBytes(32));
        const multisigAddress = ethers_1.Wallet.createRandom().address;
        const extendedKeys = random_signing_keys_1.getRandomExtendedPubKeys(2);
        const participants = machine_1.xkeysToSortedKthAddresses(extendedKeys, 0);
        const stateChannel = models_1.StateChannel.setupChannel(constants_1.AddressZero, constants_1.AddressZero, multisigAddress, extendedKeys);
        expect(stateChannel
            .getFreeBalanceClass()
            .getBalance(constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, participants[0])).toEqual(constants_1.Zero);
        expect(stateChannel
            .getFreeBalanceClass()
            .getBalance(constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, participants[1])).toEqual(constants_1.Zero);
        await store.saveStateChannel(stateChannel);
        const appInstanceProposal = utils_2.createAppInstanceProposalForTest(appInstanceId);
        ts_mockito_1.when(mockedStore.getAppInstanceProposal(appInstanceId)).thenResolve(appInstanceProposal);
        ts_mockito_1.when(mockedStore.getChannelFromAppInstanceID(appInstanceId)).thenResolve(stateChannel);
        ts_mockito_1.when(mockedProtocolRunner.initiateProtocol(machine_1.Protocol.Install, ts_mockito_1.anything(), ts_mockito_1.anything())).thenResolve(new Map([[multisigAddress, stateChannel]]));
        await expect(operation_1.install(store, protocolRunner, {
            appInstanceId
        }, extendedKeys[0])).resolves.toEqual(appInstanceProposal);
    });
});
//# sourceMappingURL=install.spec.js.map