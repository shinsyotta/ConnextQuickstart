"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const src_1 = require("../../src");
const setup_1 = require("./setup");
const tic_tac_toe_1 = require("./tic-tac-toe");
const utils_1 = require("./utils");
const { TicTacToeApp } = global["networkContext"];
describe("Node method follows spec - getAppInstances", () => {
    let nodeA;
    let nodeB;
    beforeAll(async () => {
        const context = await setup_1.setup(global);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
    });
    it("returns the right response for getting the state of a non-existent AppInstance", async () => {
        const getStateReq = utils_1.constructGetStateRpc(uuid_1.v4());
        await expect(nodeA.rpcRouter.dispatch(getStateReq)).rejects.toThrowError(src_1.NO_MULTISIG_FOR_APP_INSTANCE_ID);
    });
    it("returns the right state for an installed AppInstance", async () => {
        await utils_1.createChannel(nodeA, nodeB);
        const [appInstanceId, params] = await utils_1.installApp(nodeA, nodeB, TicTacToeApp);
        const state = await utils_1.getState(nodeA, appInstanceId);
        const initialState = tic_tac_toe_1.initialEmptyTTTState();
        for (const property in initialState) {
            expect(state[property]).toEqual(params.initialState[property]);
        }
    });
});
//# sourceMappingURL=get-state.spec.js.map