"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class DepositController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.deposit = (params) => __awaiter(this, void 0, void 0, function* () {
            const myFreeBalanceAddress = this.connext.freeBalanceAddress;
            const { assetId, amount } = types_1.convert.Deposit("bignumber", params);
            const depositAddr = lib_1.xpubToAddress(this.connext.publicIdentifier);
            let bal;
            if (assetId === constants_1.AddressZero) {
                bal = yield this.ethProvider.getBalance(depositAddr);
            }
            else {
                const token = new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider);
                bal = yield token.balanceOf(depositAddr);
            }
            validation_1.validate(validation_1.invalidAddress(assetId), validation_1.notPositive(amount), validation_1.notLessThanOrEqualTo(amount, bal));
            const preDepositBalances = yield this.connext.getFreeBalance(assetId);
            this.log.info(`\nDepositing ${amount} of ${assetId} into ${this.connext.multisigAddress}\n`);
            this.log.info("Registering listeners........");
            this.registerListeners();
            this.log.info("Registered!");
            try {
                this.log.info(`Calling ${types_1.CFCoreTypes.RpcMethodName.DEPOSIT}`);
                yield this.connext.rescindDepositRights({ assetId });
                const err = yield this.proposeDepositInstall(assetId);
                if (err) {
                    throw new Error(err);
                }
                const depositResponse = yield this.connext.providerDeposit(amount, assetId);
                this.log.info(`Deposit Response: ${lib_1.stringify(depositResponse)}`);
                const postDepositBalances = yield this.connext.getFreeBalance(assetId);
                const diff = postDepositBalances[myFreeBalanceAddress].sub(preDepositBalances[myFreeBalanceAddress]);
                if (diff.lt(amount)) {
                    throw new Error("My balance was not increased by the deposit amount.");
                }
                this.log.info("Deposited!");
            }
            catch (e) {
                this.log.error(`Failed to deposit...`);
                this.removeListeners();
                throw e;
            }
            return {
                apps: yield this.connext.getAppInstances(this.connext.multisigAddress),
                freeBalance: yield this.connext.getFreeBalance(assetId),
            };
        });
        this.proposeDepositInstall = (assetId) => __awaiter(this, void 0, void 0, function* () {
            let boundReject;
            const threshold = assetId === constants_1.AddressZero
                ? yield this.ethProvider.getBalance(this.connext.multisigAddress)
                : yield new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.connext.multisigAddress);
            const initialState = {
                multisig: this.connext.multisigAddress,
                recipient: this.connext.freeBalanceAddress,
                threshold,
                tokenAddress: assetId,
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding, outcomeType, } = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.CoinBalanceRefundApp);
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: constants_1.Zero,
                initiatorDepositTokenAddress: assetId,
                outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
            };
            let appId;
            try {
                yield Promise.race([
                    new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                        boundReject = this.rejectInstallCoinBalance.bind(null, rej);
                        this.log.warn(`subscribing to indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`);
                        yield this.connext.messaging.subscribe(`indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`, res);
                        const { appInstanceId } = yield this.connext.proposeInstallApp(params);
                        appId = appInstanceId;
                        this.log.warn(`waiting for proposal acceptance of ${appInstanceId}`);
                        this.listener.on(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
                    })),
                    lib_1.delayAndThrow(lib_1.CF_METHOD_TIMEOUT, `App install took longer than ${lib_1.CF_METHOD_TIMEOUT / 1000} seconds`),
                ]);
                this.log.info(`App was proposed successfully!: ${appId}`);
                return undefined;
            }
            catch (e) {
                this.log.error(`Error installing app: ${e.toString()}`);
                return e.message();
            }
            finally {
                this.cleanupInstallListeners(appId, boundReject);
            }
        });
        this.depositConfirmedCallback = (data) => {
            this.removeListeners();
        };
        this.depositFailedCallback = (data) => {
            this.removeListeners();
        };
        this.rejectInstallCoinBalance = (rej, msg) => {
            return rej(`Install failed. Event data: ${lib_1.stringify(msg)}`);
        };
        this.cleanupInstallListeners = (appId, boundReject) => {
            this.connext.messaging.unsubscribe(`indra.node.${this.connext.nodePublicIdentifier}.install.${appId}`);
            this.listener.removeListener(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
        };
    }
    registerListeners() {
        this.listener.registerCfListener(types_1.CFCoreTypes.EventNames.DEPOSIT_CONFIRMED_EVENT, this.depositConfirmedCallback);
        this.listener.registerCfListener(types_1.CFCoreTypes.EventNames.DEPOSIT_FAILED_EVENT, this.depositFailedCallback);
    }
    removeListeners() {
        this.listener.removeCfListener(types_1.CFCoreTypes.EventNames.DEPOSIT_CONFIRMED_EVENT, this.depositConfirmedCallback);
        this.listener.removeCfListener(types_1.CFCoreTypes.EventNames.DEPOSIT_FAILED_EVENT, this.depositFailedCallback);
    }
}
exports.DepositController = DepositController;
//# sourceMappingURL=DepositController.js.map