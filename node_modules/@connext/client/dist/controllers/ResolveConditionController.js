"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const lib_1 = require("../lib");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class ResolveConditionController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.resolve = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Resolve condition called with parameters: ${lib_1.stringify(params)}`);
            const res = yield this.conditionResolvers[params.conditionType](params);
            return res;
        });
        this.handleResolveErr = (paymentId, e) => {
            this.log.error(`Failed to resolve linked transfer ${paymentId}: ${e.stack || e.message}`);
            this.connext.emit("RECIEVE_TRANSFER_FAILED_EVENT", { paymentId });
            throw e;
        };
        this.resolveLinkedTransfer = (params) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Resolving link: ${lib_1.stringify(params)}`);
            const { paymentId, preImage, meta } = params;
            const { assetId, amount } = yield this.node.fetchLinkedTransfer(params.paymentId);
            validation_1.validate(validation_1.notNegative(amount), validation_1.invalidAddress(assetId), validation_1.invalid32ByteHexString(params.paymentId), validation_1.invalid32ByteHexString(preImage));
            this.log.info(`Found link payment for ${amount} ${assetId}`);
            const amountBN = utils_1.bigNumberify(amount);
            const freeBal = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBal[this.connext.freeBalanceAddress];
            const { appId } = yield this.node.resolveLinkedTransfer(paymentId, lib_1.createLinkedHash(amountBN, assetId, paymentId, preImage), meta);
            try {
                yield this.verifyInstalledApp(appId, amountBN, assetId, paymentId, preImage);
            }
            catch (e) {
                yield this.connext.uninstallApp(appId);
                this.handleResolveErr(paymentId, e);
            }
            try {
                yield this.connext.takeAction(appId, { preImage });
                yield this.connext.uninstallApp(appId);
            }
            catch (e) {
                this.handleResolveErr(paymentId, e);
            }
            const postTransferBal = yield this.connext.getFreeBalance(assetId);
            const diff = postTransferBal[this.connext.freeBalanceAddress].sub(preTransferBal);
            if (!diff.eq(amountBN)) {
                this.log.error("Welp it appears the difference of the free balance before and after " +
                    "uninstalling is not what we expected......");
            }
            else if (postTransferBal[this.connext.freeBalanceAddress].lte(preTransferBal)) {
                this.log.info("Free balance after transfer is lte free balance " +
                    "before transfer..... That's not great..");
            }
            return {
                appId,
                freeBalance: yield this.connext.getFreeBalance(assetId),
                paymentId,
            };
        });
        this.resolveLinkedTransferToRecipient = (params) => __awaiter(this, void 0, void 0, function* () {
            const { paymentId, preImage, amount, assetId, meta } = params;
            validation_1.validate(validation_1.notNegative(amount), validation_1.invalidAddress(assetId), validation_1.invalid32ByteHexString(paymentId), validation_1.invalid32ByteHexString(preImage));
            this.log.info(`Found link payment for ${amount} ${assetId}`);
            this.connext.emit("RECIEVE_TRANSFER_STARTED_EVENT", { paymentId });
            const amountBN = utils_1.bigNumberify(amount);
            const freeBal = yield this.connext.getFreeBalance(assetId);
            const preTransferBal = freeBal[this.connext.freeBalanceAddress];
            const { appId } = yield this.node.resolveLinkedTransfer(paymentId, lib_1.createLinkedHash(amountBN, assetId, paymentId, preImage), meta);
            try {
                yield this.verifyInstalledApp(appId, amountBN, assetId, paymentId, preImage);
            }
            catch (e) {
                yield this.connext.uninstallApp(appId);
                this.handleResolveErr(paymentId, e);
            }
            try {
                yield this.connext.takeAction(appId, { preImage });
                yield this.connext.uninstallApp(appId);
            }
            catch (e) {
                this.handleResolveErr(paymentId, e);
            }
            const postTransferBal = yield this.connext.getFreeBalance(assetId);
            const diff = postTransferBal[this.connext.freeBalanceAddress].sub(preTransferBal);
            if (!diff.eq(amountBN)) {
                this.log.error("Welp it appears the difference of the free balance before and after " +
                    "uninstalling is not what we expected......");
            }
            else if (postTransferBal[this.connext.freeBalanceAddress].lte(preTransferBal)) {
                this.log.warn("Free balance after transfer is lte free balance " +
                    "before transfer..... That's not great..");
            }
            this.connext.emit("RECIEVE_TRANSFER_FINISHED_EVENT", { paymentId });
            return {
                appId,
                freeBalance: yield this.connext.getFreeBalance(assetId),
                paymentId,
            };
        });
        this.verifyInstalledApp = (appId, amountParam, assetIdParam, paymentIdParam, preImageParam) => __awaiter(this, void 0, void 0, function* () {
            const { appInstance } = yield this.connext.getAppInstanceDetails(appId);
            const { linkedHash, preImage, coinTransfers, amount, assetId, paymentId, } = appInstance.latestState;
            const throwErr = (reason) => {
                throw new Error(`Detected ${reason} when resolving linked transfer app ${appId}, refusing to takeAction`);
            };
            if (!utils_1.bigNumberify(amount).eq(amount)) {
                throwErr(`incorrect amount in state`);
            }
            if (assetIdParam !== assetId) {
                throwErr(`incorrect assetId`);
            }
            if (paymentIdParam !== paymentId) {
                throwErr(`incorrect paymentId`);
            }
            if (linkedHash !== lib_1.createLinkedHash(amountParam, assetIdParam, paymentIdParam, preImageParam)) {
                throwErr(`incorrect linked hash`);
            }
            if (constants_1.HashZero !== preImage) {
                throwErr(`non-zero preimage`);
            }
            if (!utils_1.bigNumberify(coinTransfers[0].amount).eq(amountParam)) {
                throwErr(`incorrect initial sender amount in latest state`);
            }
            if (coinTransfers[0].to !== lib_1.xpubToAddress(this.connext.nodePublicIdentifier)) {
                throwErr(`incorrect sender address in latest state`);
            }
            if (!utils_1.bigNumberify(coinTransfers[1].amount).eq(constants_1.Zero)) {
                throwErr(`incorrect initial receiver amount in latest state`);
            }
            if (coinTransfers[1].to !== lib_1.xpubToAddress(this.connext.publicIdentifier)) {
                throwErr(`incorrect receiver address in latest state`);
            }
            if (appInstance.isVirtualApp) {
                throwErr(`virtual app`);
            }
            return;
        });
        this.conditionResolvers = {
            LINKED_TRANSFER: this.resolveLinkedTransfer,
            LINKED_TRANSFER_TO_RECIPIENT: this.resolveLinkedTransferToRecipient,
        };
    }
}
exports.ResolveConditionController = ResolveConditionController;
//# sourceMappingURL=ResolveConditionController.js.map