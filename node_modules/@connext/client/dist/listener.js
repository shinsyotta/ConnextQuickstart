"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const events_1 = require("events");
const lib_1 = require("./lib");
const types_1 = require("./types");
const appProposals_1 = require("./validation/appProposals");
class ConnextListener extends events_1.EventEmitter {
    constructor(channelProvider, connext) {
        super();
        this.defaultCallbacks = {
            CREATE_CHANNEL_EVENT: (msg) => {
                this.emitAndLog("CREATE_CHANNEL_EVENT", msg.data);
            },
            DEPOSIT_CONFIRMED_EVENT: (msg) => __awaiter(this, void 0, void 0, function* () {
                this.emitAndLog("DEPOSIT_CONFIRMED_EVENT", msg.data);
            }),
            DEPOSIT_FAILED_EVENT: (msg) => {
                this.emitAndLog("DEPOSIT_FAILED_EVENT", msg.data);
            },
            DEPOSIT_STARTED_EVENT: (msg) => {
                const { value, txHash } = msg.data;
                this.log.info(`deposit for ${value.toString()} started. hash: ${txHash}`);
                this.emitAndLog("DEPOSIT_STARTED_EVENT", msg.data);
            },
            INSTALL_EVENT: (msg) => {
                this.emitAndLog("INSTALL_EVENT", msg.data);
            },
            INSTALL_VIRTUAL_EVENT: (msg) => {
                this.emitAndLog("INSTALL_VIRTUAL_EVENT", msg.data);
            },
            PROPOSE_INSTALL_EVENT: (msg) => __awaiter(this, void 0, void 0, function* () {
                this.emitAndLog("PROPOSE_INSTALL_EVENT", msg.data);
                const matchedResult = yield this.matchAppInstance(msg);
                if (!matchedResult) {
                    this.log.warn(`No matched app, doing nothing, ${lib_1.stringify(msg)}`);
                    return;
                }
                const { data: { params }, from, } = msg;
                if (from === this.connext.publicIdentifier) {
                    this.log.info(`Received proposal from our own node, doing nothing: ${lib_1.stringify(msg)}`);
                    return;
                }
                const { matchedApp } = matchedResult;
                yield this.verifyAndInstallKnownApp(msg, matchedApp);
                const coinBalanceDef = this.connext.appRegistry.filter((app) => app.name === types_1.SupportedApplications.CoinBalanceRefundApp)[0];
                if (params.appDefinition !== coinBalanceDef.appDefinitionAddress) {
                    this.log.info(`not sending propose message, not the coinbalance refund app`);
                    return;
                }
                this.log.info(`Sending acceptance message to: indra.client.${this.connext.publicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`);
                yield this.connext.messaging.publish(`indra.client.${this.connext.publicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`, lib_1.stringify(params));
                return;
            }),
            PROTOCOL_MESSAGE_EVENT: (msg) => {
                this.emitAndLog("PROTOCOL_MESSAGE_EVENT", msg.data);
            },
            REJECT_INSTALL_EVENT: (msg) => {
                this.emitAndLog("REJECT_INSTALL_EVENT", msg.data);
            },
            UNINSTALL_EVENT: (msg) => {
                this.emitAndLog("UNINSTALL_EVENT", msg.data);
            },
            UNINSTALL_VIRTUAL_EVENT: (msg) => {
                this.emitAndLog("UNINSTALL_VIRTUAL_EVENT", msg.data);
            },
            UPDATE_STATE_EVENT: (msg) => {
                this.emitAndLog("UPDATE_STATE_EVENT", msg.data);
            },
            WITHDRAWAL_CONFIRMED_EVENT: (msg) => {
                this.emitAndLog("WITHDRAWAL_CONFIRMED_EVENT", msg.data);
            },
            WITHDRAWAL_FAILED_EVENT: (msg) => {
                this.emitAndLog("WITHDRAWAL_FAILED_EVENT", msg.data);
            },
            WITHDRAWAL_STARTED_EVENT: (msg) => {
                const { params: { amount }, txHash, } = msg.data;
                this.log.info(`withdrawal for ${amount.toString()} started. hash: ${txHash}`);
                this.emitAndLog("WITHDRAWAL_STARTED_EVENT", msg.data);
            },
        };
        this.register = () => __awaiter(this, void 0, void 0, function* () {
            yield this.registerAvailabilitySubscription();
            this.registerDefaultListeners();
            yield this.registerLinkedTransferSubscription();
            return;
        });
        this.registerCfListener = (event, cb) => {
            this.log.debug(`Registering listener for ${event}`);
            this.channelProvider.on(event, (res) => __awaiter(this, void 0, void 0, function* () {
                yield cb(res);
                this.emit(event, res);
            }));
        };
        this.removeCfListener = (event, cb) => {
            this.log.debug(`Removing listener for ${event}`);
            try {
                this.removeListener(event, cb);
                return true;
            }
            catch (e) {
                this.log.error(`Error trying to remove registered listener from event ${event}: ${e.stack || e.message}`);
                return false;
            }
        };
        this.registerDefaultListeners = () => {
            Object.entries(this.defaultCallbacks).forEach(([event, callback]) => {
                this.channelProvider.on(types_1.CFCoreTypes.EventNames[event], callback);
            });
            this.channelProvider.on(types_1.CFCoreTypes.RpcMethodNames.chan_install, (msg) => __awaiter(this, void 0, void 0, function* () {
                const { result: { result: { appInstance }, }, } = msg;
                yield this.connext.messaging.publish(`indra.client.${this.connext.publicIdentifier}.install.${appInstance.identityHash}`, lib_1.stringify(appInstance));
            }));
            this.channelProvider.on(types_1.CFCoreTypes.RpcMethodNames.chan_uninstall, (data) => {
                const result = data.result.result;
                this.log.debug(`Emitting CFCoreTypes.RpcMethodNames.chan_uninstall event: ${lib_1.stringify(result)}`);
                this.connext.messaging.publish(`indra.client.${this.connext.publicIdentifier}.uninstall.${result.appInstanceId}`, lib_1.stringify(result));
            });
        };
        this.emitAndLog = (event, data) => {
            const protocol = event === types_1.CFCoreTypes.EventNames.PROTOCOL_MESSAGE_EVENT
                ? data.data
                    ? data.data.protocol
                    : data.protocol
                : "";
            this.log.info(`Recieved ${event}${protocol ? ` for ${protocol} protocol` : ""}`);
            this.log.debug(`Emitted ${event} with data ${lib_1.stringify(data)} at ${Date.now()}`);
            this.emit(event, data);
        };
        this.matchAppInstance = (msg) => __awaiter(this, void 0, void 0, function* () {
            const filteredApps = this.connext.appRegistry.filter((app) => {
                return app.appDefinitionAddress === msg.data.params.appDefinition;
            });
            if (!filteredApps || filteredApps.length === 0) {
                this.log.info(`Proposed app not in registered applications. App: ${lib_1.stringify(msg)}`);
                return undefined;
            }
            if (filteredApps.length > 1) {
                this.log.error(`Proposed app matched ${filteredApps.length} registered applications by definition address. App: ${lib_1.stringify(msg)}`);
                return undefined;
            }
            const { params, appInstanceId } = msg.data;
            const { initiatorDeposit, responderDeposit } = params;
            return {
                appInstanceId,
                matchedApp: filteredApps[0],
                proposeParams: Object.assign({}, params, { initiatorDeposit: utils_1.bigNumberify(initiatorDeposit), responderDeposit: utils_1.bigNumberify(responderDeposit) }),
            };
        });
        this.verifyAndInstallKnownApp = (msg, matchedApp) => __awaiter(this, void 0, void 0, function* () {
            const { data: { params, appInstanceId }, from, } = msg;
            const invalidProposal = yield appProposals_1.appProposalValidation[matchedApp.name](params, from, matchedApp, this.connext);
            if (invalidProposal) {
                this.log.error(`Proposed app is invalid. ${invalidProposal}`);
                yield this.connext.rejectInstallApp(appInstanceId);
                return;
            }
            if (matchedApp.name === types_1.SupportedApplications.SimpleTwoPartySwapApp) {
                return;
            }
            if (matchedApp.name === types_1.SupportedApplications.CoinBalanceRefundApp) {
                return;
            }
            this.log.debug(`Proposal for app install successful, attempting install now...`);
            let res;
            const virtualAppDefs = [this.connext.config.contractAddresses["SimpleTransferApp"]];
            if (virtualAppDefs.includes(params.appDefinition)) {
                res = yield this.connext.installVirtualApp(appInstanceId);
            }
            else {
                res = yield this.connext.installApp(appInstanceId);
            }
            this.log.debug(`App installed, res: ${lib_1.stringify(res)}`);
            return;
        });
        this.registerAvailabilitySubscription = () => __awaiter(this, void 0, void 0, function* () {
            const subject = `online.${this.connext.publicIdentifier}`;
            yield this.connext.messaging.subscribe(subject, (msg) => __awaiter(this, void 0, void 0, function* () {
                if (!msg.reply) {
                    this.log.warn(`No reply found for msg: ${msg}`);
                    return;
                }
                const response = true;
                this.connext.messaging.publish(msg.reply, {
                    err: null,
                    response,
                });
            }));
            this.log.debug(`Connected message pattern "${subject}"`);
        });
        this.registerLinkedTransferSubscription = () => __awaiter(this, void 0, void 0, function* () {
            const subject = `transfer.send-async.${this.connext.publicIdentifier}`;
            yield this.connext.messaging.subscribe(subject, (data) => __awaiter(this, void 0, void 0, function* () {
                this.log.info(`Received message for subscription: ${lib_1.stringify(data)}`);
                let paymentId;
                let encryptedPreImage;
                if (data.paymentId) {
                    this.log.debug(`Not nested data`);
                    paymentId = data.paymentId;
                    encryptedPreImage = data.encryptedPreImage;
                }
                else if (data.data) {
                    this.log.debug(`Nested data`);
                    const parsedData = JSON.parse(data.data);
                    paymentId = parsedData.paymentId;
                    encryptedPreImage = parsedData.encryptedPreImage;
                }
                else {
                    throw new Error(`Could not parse data from message: ${lib_1.stringify(data)}`);
                }
                if (!paymentId || !encryptedPreImage) {
                    throw new Error(`Unable to parse transfer details from message ${lib_1.stringify(data)}`);
                }
                yield this.connext.reclaimPendingAsyncTransfer(paymentId, encryptedPreImage);
                this.log.info(`Successfully reclaimed transfer with paymentId: ${paymentId}`);
            }));
        });
        this.channelProvider = channelProvider;
        this.connext = connext;
        this.log = new lib_1.Logger("ConnextListener", connext.log.logLevel);
    }
}
exports.ConnextListener = ConnextListener;
//# sourceMappingURL=listener.js.map