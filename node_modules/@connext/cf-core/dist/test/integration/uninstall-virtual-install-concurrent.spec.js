"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../src/constants");
const types_1 = require("../../src/types");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
expect.extend({ toBeLt: bignumber_jest_matcher_1.toBeLt });
jest.setTimeout(7500);
const { TicTacToeApp } = global["networkContext"];
describe("Node method follows spec when happening concurrently - install / uninstall virtual", () => {
    let multisigAddressAB;
    let multisigAddressBC;
    let nodeA;
    let nodeB;
    let nodeC;
    let installedAppInstanceId;
    let installCall;
    describe("NodeA can uninstall virtual app with NodeC and install regular app with nodeB concurrently", () => {
        beforeEach(async () => {
            const context = await setup_1.setup(global, true);
            nodeA = context["A"].node;
            nodeB = context["B"].node;
            nodeC = context["C"].node;
            multisigAddressAB = await utils_2.createChannel(nodeA, nodeB);
            multisigAddressBC = await utils_2.createChannel(nodeB, nodeC);
            await utils_2.collateralizeChannel(multisigAddressAB, nodeA, nodeB, utils_1.parseEther("2"));
            await utils_2.collateralizeChannel(multisigAddressBC, nodeB, nodeC, utils_1.parseEther("2"));
            const appDef = TicTacToeApp;
            installCall = utils_2.makeProposeCall(nodeB, appDef, undefined, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, constants_1.One, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS);
            installedAppInstanceId = await utils_2.installVirtualApp(nodeA, nodeB, nodeC, appDef, undefined, constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, constants_1.One, constants_1.One);
            expect(installedAppInstanceId).toBeDefined();
        });
        it("install app with ETH then uninstall and install apps simultaneously from the same node", async (done) => {
            let completedActions = 0;
            nodeB.once(types_1.NODE_EVENTS.PROPOSE_INSTALL, (msg) => {
                utils_2.makeInstallCall(nodeB, msg.data.appInstanceId);
            });
            nodeA.once(types_1.NODE_EVENTS.INSTALL, () => {
                completedActions += 1;
                if (completedActions === 2) {
                    done();
                }
            });
            nodeC.once(types_1.NODE_EVENTS.UNINSTALL_VIRTUAL, () => {
                completedActions += 1;
                if (completedActions === 2) {
                    done();
                }
            });
            nodeA.rpcRouter.dispatch(installCall);
            nodeA.rpcRouter.dispatch(utils_2.constructUninstallVirtualRpc(installedAppInstanceId, nodeB.publicIdentifier));
        });
        it("install app with ETH then uninstall virtual and install apps simultaneously from separate nodes", async (done) => {
            let completedActions = 0;
            nodeB.once(types_1.NODE_EVENTS.PROPOSE_INSTALL, (msg) => {
                utils_2.makeInstallCall(nodeB, msg.data.appInstanceId);
            });
            nodeA.once(types_1.NODE_EVENTS.INSTALL, () => {
                completedActions += 1;
                if (completedActions === 2) {
                    done();
                }
            });
            nodeA.once(types_1.NODE_EVENTS.UNINSTALL_VIRTUAL, () => {
                completedActions += 1;
                if (completedActions === 2) {
                    done();
                }
            });
            nodeA.rpcRouter.dispatch(installCall);
            nodeC.rpcRouter.dispatch(utils_2.constructUninstallVirtualRpc(installedAppInstanceId, nodeB.publicIdentifier));
        });
    });
});
//# sourceMappingURL=uninstall-virtual-install-concurrent.spec.js.map