"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const ethereum_1 = require("../../../../src/ethereum");
const app_identity_1 = require("../../../../src/ethereum/utils/app-identity");
const contracts_1 = require("../../../contracts");
const utils_2 = require("../../../unit/utils");
const mocks_1 = require("../../mocks");
describe("Set State Commitment", () => {
    let commitment;
    let tx;
    const networkContext = mocks_1.generateRandomNetworkContext();
    const appInstance = utils_2.createAppInstanceForTest();
    beforeAll(() => {
        commitment = new ethereum_1.SetStateCommitment(networkContext, appInstance.identity, appInstance.hashOfLatestState, appInstance.versionNumber, appInstance.timeout);
        tx = commitment.getSignedTransaction([]);
    });
    it("should be to ChallengeRegistry", () => {
        expect(tx.to).toBe(networkContext.ChallengeRegistry);
    });
    it("should have no value", () => {
        expect(tx.value).toBe(0);
    });
    describe("the calldata", () => {
        const iface = new utils_1.Interface(contracts_1.ChallengeRegistry.abi);
        let desc;
        beforeAll(() => {
            const { data } = tx;
            desc = iface.parseTransaction({ data });
        });
        it("should be to the setState method", () => {
            expect(desc.sighash).toBe(iface.functions.setState.sighash);
        });
        it("should contain expected AppIdentity argument", () => {
            const [channelNonce, participants, appDefinition, defaultTimeout] = desc.args[0];
            expect(channelNonce).toEqual(utils_1.bigNumberify(appInstance.identity.channelNonce));
            expect(participants).toEqual(appInstance.identity.participants);
            expect(appDefinition).toBe(appInstance.identity.appDefinition);
            expect(defaultTimeout).toEqual(utils_1.bigNumberify(appInstance.identity.defaultTimeout));
        });
        it("should contain expected SignedStateHashUpdate argument", () => {
            const [stateHash, versionNumber, timeout, []] = desc.args[1];
            expect(stateHash).toBe(appInstance.hashOfLatestState);
            expect(versionNumber).toEqual(utils_1.bigNumberify(appInstance.versionNumber));
            expect(timeout).toEqual(utils_1.bigNumberify(appInstance.timeout));
        });
    });
    it("should produce the correct hash to sign", () => {
        const hashToSign = commitment.hashToSign();
        const expectedHashToSign = utils_1.keccak256(utils_1.solidityPack(["bytes1", "bytes32", "uint256", "uint256", "bytes32"], [
            "0x19",
            app_identity_1.appIdentityToHash(appInstance.identity),
            appInstance.versionNumber,
            appInstance.timeout,
            appInstance.hashOfLatestState
        ]));
        expect(hashToSign).toBe(expectedHashToSign);
    });
});
//# sourceMappingURL=set-state-commitment.spec.js.map