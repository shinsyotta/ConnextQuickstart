"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const p_queue_1 = __importDefault(require("p-queue"));
const uuid_1 = __importDefault(require("uuid"));
const deferred_1 = require("../../src/deferred");
class Lock {
    constructor(lockName) {
        this.lockName = lockName;
        this.currentLockHandle = new deferred_1.Deferred();
        this.unlockKey = "";
        this.requestsForLock = new p_queue_1.default({ concurrency: 1 });
    }
    async acquireLock(timeout) {
        const unlockKey = uuid_1.default.v1();
        const lockAvailableNow = new deferred_1.Deferred();
        this.requestsForLock.add(() => {
            lockAvailableNow.resolve();
            return this.acquireLockInternal(unlockKey, timeout);
        });
        await lockAvailableNow.promise;
        return unlockKey;
    }
    async releaseLock(unlockKey) {
        this.verifyLockKey(unlockKey);
        if (this.currentLockHandle)
            this.currentLockHandle.resolve();
        this.currentLockHandle = null;
    }
    isAcquired() {
        return this.currentLockHandle !== null;
    }
    acquireLockInternal(unlockKey, timeout) {
        const claim = new deferred_1.Deferred();
        this.currentLockHandle = claim;
        this.unlockKey = unlockKey;
        setTimeout(() => claim.reject("Request timed out."), timeout);
        return claim.promise;
    }
    verifyLockKey(unlockKey) {
        if (unlockKey !== this.unlockKey) {
            throw new Error(`Attempted to unlock ${this.lockName} with invalid key: ${unlockKey}`);
        }
    }
}
exports.Lock = Lock;
//# sourceMappingURL=lock.js.map