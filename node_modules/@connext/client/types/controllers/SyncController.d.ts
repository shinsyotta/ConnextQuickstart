import { ConnextInternal } from '../Connext';
import { SyncControllerState } from '../state';
import { Block, ChannelState, ChannelStateUpdate, LogDescription, Sync, SyncResult, ThreadStateUpdate } from '../types';
import { AbstractController } from './AbstractController';
export declare const mergeSyncResults: (xs: SyncResult<string>[], ys: SyncResult<string>[]) => SyncResult<string>[];
/**
 * This function should be used to update the `syncResultsFromHub` by removing
 * any updates from the hub that are already in queue to be returned to the hub
 */
export declare const filterPendingSyncResults: (fromHub: SyncResult<string>[], toHub: SyncResult<string>[]) => any;
export declare class SyncController extends AbstractController {
    private static POLLER_INTERVAL_LENGTH;
    private poller;
    private flushErrorCount;
    constructor(name: string, connext: ConnextInternal);
    start(): Promise<void>;
    stop(): Promise<void>;
    sync(): Promise<void>;
    getSyncState(): SyncControllerState;
    private checkCurrentStateTimeoutAndInvalidate;
    /**
     * Checks to see whether a `DidUpdateChannel` event with `txCountGlobal`
     * matching `channel.txCountGlobal` has been emitted.
     *
     * Returns 'yes' if it has, 'no' if it has not, and 'unknown' if the
     * channel's timeout has not yet expired.
     */
    didContractEmitUpdateEvent(channel: ChannelState, updateTimestamp?: Date): Promise<{
        didEmit: 'yes' | 'no' | 'unknown';
        latestBlock: Block;
        event?: LogDescription;
    }>;
    sendUpdateToHub(update: ChannelStateUpdate | ThreadStateUpdate): Promise<any>;
    /**
     * If the current latest block has a `timestamp < timeout`, return the current
     * latest block. Otherwise find a block with a
     * `timestamp > timeout && timestamp < timeout + 60 minutes` (ie, a block
     * with a timestamp greater than the timeout, but no more than 60 minutes
     * greater).
     */
    findBlockNearestTimeout(timeout: number, delta?: number): Promise<Block>;
    /**
     * Sends all pending updates (that is, those which have been put onto the
     * store, but not yet sync'd) to the hub.
     */
    private flushLock;
    private flushPendingUpdatesToHub;
    /**
     * Responsible for handling sync responses from the hub, specifically
     * the channel status.
    */
    handleHubSync(sync: Sync): any;
    private _flushPendingUpdatesToHub;
    /**
     * Enqueues updates from the hub, to be handled by `StateUpdateController`.
     */
    private enqueueSyncResultsFromHub;
    private syncCustodialBalance;
    /**
     * Sends an invalidation to the hub.
     *
     * Note: this assumes that the caller has guaranteed that the state can
     * safely be invalidated. Currently this is true because `sendInvalidation`
     * is only called from one place - checkCurrentStateTimeoutAndInvalidate -
     * which performs the appropriate checks.
     *
     * If this gets called from other places, care will need to be taken to
     * ensure they have done the appropriate validation too.
     */
    private sendInvalidation;
}
