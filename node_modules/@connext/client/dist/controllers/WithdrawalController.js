"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class WithdrawalController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.withdrawConfirmedCallback = (data) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Withdrawal confimed.`);
            this.removeListeners();
        });
        this.withdrawFailedCallback = (data) => {
            this.log.warn(`Withdrawal failed with data: ${lib_1.stringify(data)}`);
            this.removeListeners();
        };
    }
    withdraw(params) {
        return __awaiter(this, void 0, void 0, function* () {
            params.assetId = params.assetId ? utils_1.getAddress(params.assetId) : undefined;
            const myFreeBalanceAddress = this.connext.freeBalanceAddress;
            const { amount, assetId, recipient, userSubmitted } = types_1.convert.Withdraw("bignumber", params);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            const preWithdrawalBal = freeBalance[this.connext.freeBalanceAddress];
            validation_1.validate(validation_1.notLessThanOrEqualTo(amount, preWithdrawalBal), validation_1.invalidAddress(assetId));
            if (recipient) {
                validation_1.validate(validation_1.invalidAddress(recipient));
            }
            const preWithdrawBalances = yield this.connext.getFreeBalance(assetId);
            this.log.info(`\nWithdrawing ${amount} wei from ${this.connext.multisigAddress} to ${recipient}\n`);
            this.registerListeners();
            let transaction;
            try {
                this.log.info(`Calling this.connext.rescindDepositRights before withdrawal for ${assetId}`);
                yield this.connext.rescindDepositRights({ assetId });
                if (!userSubmitted) {
                    this.log.info(`Calling ${types_1.CFCoreTypes.RpcMethodNames.chan_withdrawCommitment}`);
                    const withdrawResponse = yield this.connext.withdrawCommitment(amount, assetId, recipient);
                    this.log.info(`Withdraw Response: ${lib_1.stringify(withdrawResponse)}`);
                    const minTx = withdrawResponse.transaction;
                    yield this.connext.channelProvider.send("chan_storeSet", {
                        pairs: [
                            { path: lib_1.withdrawalKey(this.connext.publicIdentifier), value: { tx: minTx, retry: 0 } },
                        ],
                    });
                    transaction = yield this.node.withdraw(minTx);
                    yield this.connext.watchForUserWithdrawal();
                    this.log.info(`Node Withdraw Response: ${lib_1.stringify(transaction)}`);
                }
                else {
                    this.log.info(`Calling ${types_1.CFCoreTypes.RpcMethodNames.chan_withdraw}`);
                    const withdrawResponse = yield this.connext.providerWithdraw(assetId, new types_1.BigNumber(amount), recipient);
                    this.log.info(`Withdraw Response: ${lib_1.stringify(withdrawResponse)}`);
                    transaction = yield this.ethProvider.getTransaction(withdrawResponse.txHash);
                }
                const postWithdrawBalances = yield this.connext.getFreeBalance(assetId);
                this.log.info(`Pre-Withdraw Balances: ${lib_1.stringify(preWithdrawBalances)}`);
                const expectedFreeBal = utils_1.bigNumberify(preWithdrawBalances[myFreeBalanceAddress]).sub(amount);
                if (postWithdrawBalances && !postWithdrawBalances[myFreeBalanceAddress].eq(expectedFreeBal)) {
                    this.log.error(`My free balance was not decreased by the expected amount.`);
                }
                this.log.info("Withdrawn!");
            }
            catch (e) {
                this.log.error(`Failed to withdraw: ${e.stack || e.message}`);
                this.removeListeners();
                throw new Error(e);
            }
            return {
                apps: yield this.connext.getAppInstances(this.connext.multisigAddress),
                freeBalance: yield this.connext.getFreeBalance(),
                transaction,
            };
        });
    }
    registerListeners() {
        this.listener.registerCfListener(types_1.CFCoreTypes.EventNames.WITHDRAWAL_CONFIRMED_EVENT, this.withdrawConfirmedCallback);
        this.listener.registerCfListener(types_1.CFCoreTypes.EventNames.WITHDRAWAL_FAILED_EVENT, this.withdrawFailedCallback);
    }
    removeListeners() {
        this.listener.removeCfListener(types_1.CFCoreTypes.EventNames.WITHDRAWAL_CONFIRMED_EVENT, this.withdrawConfirmedCallback);
        this.listener.removeCfListener(types_1.CFCoreTypes.EventNames.WITHDRAWAL_FAILED_EVENT, this.withdrawFailedCallback);
    }
}
exports.WithdrawalController = WithdrawalController;
//# sourceMappingURL=WithdrawalController.js.map