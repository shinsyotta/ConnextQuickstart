'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var nats = require('ts-nats');
var wsNats = require('websocket-nats');

class Logger {
    constructor(name, logLevel) {
        this.levels = { debug: 4, info: 3, warn: 2, error: 1 };
        this.logLevel = 3;
        this.name = "Logger";
        this.name = typeof name !== "undefined" ? name : this.name;
        this.logLevel =
            typeof logLevel !== "undefined" ? parseInt(logLevel.toString(), 10) : this.logLevel;
    }
    error(msg) {
        this.log("error", msg);
    }
    warn(msg) {
        this.log("warn", msg);
    }
    info(msg) {
        this.log("info", msg);
    }
    debug(msg) {
        this.log("debug", msg);
    }
    log(level, msg) {
        if (this.levels[level] > this.logLevel)
            return;
        return console[level](`${level}: [${this.name}] ${msg}`);
    }
}

class NatsMessagingService {
    constructor(config, messagingServiceKey) {
        this.config = config;
        this.messagingServiceKey = messagingServiceKey;
        this.subscriptions = {};
        this.log = new Logger("NatsMessagingService", config.logLevel);
        this.log.debug(`Created with config: ${JSON.stringify(config, null, 2)}`);
    }
    async connect() {
        const messagingUrl = this.config.messagingUrl;
        const config = this.config;
        config.servers = typeof messagingUrl === "string" ? [messagingUrl] : messagingUrl;
        config.payload = nats.Payload.JSON;
        this.connection = await nats.connect(config);
        this.log.debug(`Connected!`);
    }
    async disconnect() {
        this.assertConnected();
        this.connection.close();
    }
    async onReceive(subject, callback) {
        this.assertConnected();
        this.subscriptions[subject] = await this.connection.subscribe(this.prependKey(`${subject}.>`), (err, msg) => {
            if (err || !msg || !msg.data) {
                this.log.error(`Encountered an error while handling callback for message ${msg}: ${err}`);
            }
            else {
                const data = typeof msg.data === "string" ? JSON.parse(msg).data : msg.data;
                this.log.debug(`Received message for ${subject}: ${JSON.stringify(data)}`);
                callback(data);
            }
        });
    }
    async send(to, msg) {
        this.assertConnected();
        this.log.debug(`Sending message to ${to}: ${JSON.stringify(msg)}`);
        this.connection.publish(this.prependKey(`${to}.${msg.from}`), msg);
    }
    async publish(subject, data) {
        this.assertConnected();
        this.log.debug(`Publishing ${subject}: ${JSON.stringify(data)}`);
        this.connection.publish(subject, data);
    }
    async request(subject, timeout, data = {}) {
        this.assertConnected();
        this.log.debug(`Requesting ${subject} with data: ${JSON.stringify(data)}`);
        const response = await this.connection.request(subject, timeout, data);
        this.log.debug(`Request for ${subject} returned: ${JSON.stringify(response)}`);
        return response;
    }
    async subscribe(subject, callback) {
        this.assertConnected();
        this.subscriptions[subject] = await this.connection.subscribe(subject, (err, msg) => {
            if (err || !msg || !msg.data) {
                this.log.error(`Encountered an error while handling callback for message ${msg}: ${err}`);
            }
            else {
                const data = typeof msg === "string" ? JSON.parse(msg) : msg;
                this.log.debug(`Subscription for ${subject}: ${JSON.stringify(data)}`);
                callback(data);
            }
        });
    }
    async unsubscribe(subject) {
        this.assertConnected();
        if (this.subscriptions[subject]) {
            this.subscriptions[subject].unsubscribe();
            this.log.debug(`Unsubscribed from ${subject}`);
        }
        else {
            this.log.warn(`Not subscribed to ${subject}, doing nothing`);
        }
    }
    async flush() {
        this.assertConnected();
        await this.connection.flush();
    }
    prependKey(subject) {
        return `${this.messagingServiceKey}.${subject}`;
    }
    assertConnected() {
        if (!this.connection) {
            throw new Error("No connection exists, NatsMessagingService is uninitialized.");
        }
    }
}

class WsMessagingService {
    constructor(config, messagingServiceKey) {
        this.config = config;
        this.messagingServiceKey = messagingServiceKey;
        this.subscriptions = {};
        this.log = new Logger("WsMessagingService", config.logLevel);
        this.log.debug(`Created with config: ${JSON.stringify(config, null, 2)}`);
    }
    async connect() {
        this.connection = await wsNats.connect(this.config.messagingUrl);
    }
    async disconnect() {
        this.assertConnected();
        this.connection.close();
    }
    async onReceive(subject, callback) {
        this.assertConnected();
        this.subscriptions[subject] = this.connection.subscribe(this.prependKey(`${subject}.>`), (msg) => {
            const data = typeof msg === "string" ? JSON.parse(msg) : msg;
            this.log.debug(`Received message for ${subject}: ${JSON.stringify(data)}`);
            callback(data);
        });
    }
    async send(to, msg) {
        this.assertConnected();
        this.log.debug(`Sending message to ${to}: ${JSON.stringify(msg)}`);
        await this.connection.publish(this.prependKey(`${to}.${msg.from}`), JSON.stringify(msg));
    }
    async publish(subject, data) {
        this.assertConnected();
        this.log.debug(`Publishing ${subject}: ${JSON.stringify(data)}`);
        await this.connection.publish(subject, data);
    }
    async request(subject, timeout, data = {}) {
        this.assertConnected();
        this.log.debug(`Requesting ${subject} with data: ${JSON.stringify(data)}`);
        return new Promise((resolve, reject) => {
            this.connection.request(subject, JSON.stringify(data), { max: 1, timeout }, (response) => {
                this.log.debug(`Request for ${subject} returned: ${response}`);
                resolve({ data: JSON.parse(response) });
            });
        });
    }
    async subscribe(subject, callback) {
        this.assertConnected();
        this.subscriptions[subject] = this.connection.subscribe(subject, (msg) => {
            const data = typeof msg === "string" ? JSON.parse(msg) : msg;
            this.log.debug(`Subscription for ${subject}: ${JSON.stringify(data)}`);
            callback(data);
        });
    }
    async unsubscribe(subject) {
        this.assertConnected();
        if (this.subscriptions[subject]) {
            await this.connection.unsubscribe(this.subscriptions[subject]);
            this.log.info(`Unsubscribed from ${subject}`);
        }
        else {
            this.log.warn(`Not subscribed to ${subject}, doing nothing`);
        }
    }
    async flush() {
        this.assertConnected();
        await this.connection.flush();
    }
    prependKey(subject) {
        return `${this.messagingServiceKey}.${subject}`;
    }
    assertConnected() {
        if (!this.connection) {
            throw new Error("No connection exists, WsMessagingService is uninitialized.");
        }
    }
}

class MessagingServiceFactory {
    constructor(config) {
        this.config = config;
        const { messagingUrl } = config;
        if (!messagingUrl) {
            throw new Error(`No messaging url provided. Config: ${JSON.stringify(config)}`);
        }
        if (typeof messagingUrl === "string") {
            this.serviceType = messagingUrl.startsWith("nats://") ? "nats" : "ws";
        }
        else if (messagingUrl[0] && messagingUrl[0].startsWith("nats://")) {
            this.serviceType = "nats";
        }
        else {
            throw new Error(`Invalid Messaging Url: ${JSON.stringify(messagingUrl)}`);
        }
    }
    connect() {
        throw Error("Connect service using NatsMessagingService.connect()");
    }
    createService(messagingServiceKey) {
        return this.serviceType === "ws"
            ? new WsMessagingService(this.config, messagingServiceKey)
            : new NatsMessagingService(this.config, messagingServiceKey);
    }
}

exports.MessagingServiceFactory = MessagingServiceFactory;
exports.NatsMessagingService = NatsMessagingService;
//# sourceMappingURL=index.js.map
