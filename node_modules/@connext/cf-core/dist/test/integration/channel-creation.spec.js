"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
describe("Node can create multisig, other owners get notified", () => {
    let nodeA;
    let nodeB;
    let nodeC;
    beforeAll(async () => {
        const context = await setup_1.setup(global, true);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        nodeC = context["C"].node;
    });
    it("Node A and Node B can create a channel", async (done) => {
        const owners = [
            nodeA.publicIdentifier,
            nodeB.publicIdentifier
        ];
        const expectedMsg = {
            from: nodeB.publicIdentifier,
            type: "CREATE_CHANNEL_EVENT",
            data: {
                owners: [
                    nodeB.freeBalanceAddress,
                    nodeA.freeBalanceAddress,
                ],
                counterpartyXpub: nodeB.publicIdentifier,
            }
        };
        let assertionCount = 0;
        nodeA.once("CREATE_CHANNEL_EVENT", async (msg) => {
            utils_2.assertNodeMessage(msg, expectedMsg, ['data.multisigAddress']);
            assertionCount += 1;
            if (assertionCount === 2)
                done();
        });
        nodeB.once("CREATE_CHANNEL_EVENT", async (msg) => {
            utils_2.assertNodeMessage(msg, Object.assign({}, expectedMsg, { data: Object.assign({}, expectedMsg.data, { counterpartyXpub: nodeA.publicIdentifier }) }), ['data.multisigAddress']);
            assertionCount += 1;
            if (assertionCount === 3)
                done();
        });
        const { result: { result: { multisigAddress } } } = await nodeB.rpcRouter.dispatch(utils_2.constructChannelCreationRpc(owners));
        expect(utils_1.isHexString(multisigAddress)).toBeTruthy();
        assertionCount += 1;
        if (assertionCount === 3)
            done();
    });
    describe("Queued channel creation", () => {
        it("Node A can create multiple back-to-back channels with Node B and Node C", async (done) => {
            const ownersABPublicIdentifiers = [
                nodeA.publicIdentifier,
                nodeB.publicIdentifier
            ];
            const ownersABFreeBalanceAddr = [
                nodeA.freeBalanceAddress,
                nodeB.freeBalanceAddress,
            ];
            const ownersACPublicIdentifiers = [
                nodeA.publicIdentifier,
                nodeC.publicIdentifier
            ];
            const ownersACFreeBalanceAddr = [
                nodeA.freeBalanceAddress,
                nodeC.freeBalanceAddress,
            ];
            nodeA.on("CREATE_CHANNEL_EVENT", async (msg) => {
                if (msg.data.owners === ownersABPublicIdentifiers) {
                    const openChannelsNodeA = await utils_2.getChannelAddresses(nodeA);
                    const openChannelsNodeB = await utils_2.getChannelAddresses(nodeB);
                    expect(openChannelsNodeA.size).toEqual(1);
                    expect(openChannelsNodeB.size).toEqual(1);
                    await utils_2.confirmChannelCreation(nodeA, nodeB, ownersABFreeBalanceAddr, msg.data);
                }
                else {
                    const openChannelsNodeA = await utils_2.getChannelAddresses(nodeA);
                    const openChannelsNodeC = await utils_2.getChannelAddresses(nodeC);
                    expect(openChannelsNodeA.size).toEqual(2);
                    expect(openChannelsNodeC.size).toEqual(1);
                    await utils_2.confirmChannelCreation(nodeA, nodeC, ownersACFreeBalanceAddr, msg.data);
                    done();
                }
            });
            const txHash1 = await utils_2.getMultisigCreationAddress(nodeA, ownersABPublicIdentifiers);
            const txHash2 = await utils_2.getMultisigCreationAddress(nodeA, ownersACPublicIdentifiers);
            expect(txHash1).toBeDefined();
            expect(txHash2).toBeDefined();
        });
    });
});
//# sourceMappingURL=channel-creation.spec.js.map