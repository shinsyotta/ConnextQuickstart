"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/utils");
const constants_1 = require("../../../../src/constants");
const machine_1 = require("../../../../src/machine");
const contracts_1 = require("../../../contracts");
const bignumber_jest_matcher_1 = require("../bignumber-jest-matcher");
const connect_ganache_1 = require("../connect-ganache");
const test_runner_1 = require("./test-runner");
let wallet;
let appWithAction;
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
var ActionType;
(function (ActionType) {
    ActionType[ActionType["SUBMIT_COUNTER_INCREMENT"] = 0] = "SUBMIT_COUNTER_INCREMENT";
    ActionType[ActionType["ACCEPT_INCREMENT"] = 1] = "ACCEPT_INCREMENT";
})(ActionType || (ActionType = {}));
beforeAll(async () => {
    [{}, wallet, {}] = await connect_ganache_1.connectToGanache();
    appWithAction = await new ethers_1.ContractFactory(contracts_1.AppWithAction.abi, contracts_1.AppWithAction.evm.bytecode, wallet).deploy();
});
describe("Three mininodes", () => {
    it("Can run all the protocols", async () => {
        const tr = new test_runner_1.TestRunner();
        await tr.connectToGanache();
        await tr.setup();
        await tr.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.InstallVirtualApp, tr.mininodeA.scm, {
            initiatorXpub: tr.mininodeA.xpub,
            intermediaryXpub: tr.mininodeB.xpub,
            responderXpub: tr.mininodeC.xpub,
            defaultTimeout: 100,
            appInterface: {
                addr: appWithAction.address,
                stateEncoding: "tuple(uint256 counter)",
                actionEncoding: "tuple(uint8 actionType, uint256 increment)"
            },
            initialState: {
                counter: 0
            },
            appSeqNo: 0,
            initiatorBalanceDecrement: utils_1.bigNumberify(0),
            responderBalanceDecrement: utils_1.bigNumberify(0),
            tokenAddress: constants_1.CONVENTION_FOR_ETH_TOKEN_ADDRESS,
            outcomeType: types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME
        });
        const [virtualAppInstance] = [
            ...tr.mininodeA.scm.get(tr.multisigAC).appInstances.values()
        ];
        expect(virtualAppInstance.isVirtualApp);
        await tr.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.Update, tr.mininodeA.scm, {
            initiatorXpub: tr.mininodeA.xpub,
            responderXpub: tr.mininodeC.xpub,
            multisigAddress: tr.multisigAC,
            appIdentityHash: virtualAppInstance.identityHash,
            newState: {
                counter: 1
            }
        });
        await tr.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.TakeAction, tr.mininodeA.scm, {
            initiatorXpub: tr.mininodeA.xpub,
            responderXpub: tr.mininodeC.xpub,
            multisigAddress: tr.multisigAC,
            appIdentityHash: virtualAppInstance.identityHash,
            action: {
                actionType: ActionType.SUBMIT_COUNTER_INCREMENT,
                increment: 1
            }
        });
        await tr.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.UninstallVirtualApp, tr.mininodeA.scm, {
            initiatorXpub: tr.mininodeA.xpub,
            intermediaryXpub: tr.mininodeB.xpub,
            responderXpub: tr.mininodeC.xpub,
            targetAppIdentityHash: virtualAppInstance.identityHash,
            targetOutcome: await virtualAppInstance.computeOutcome({
                counter: 2
            }, appWithAction.provider)
        });
    });
});
//# sourceMappingURL=protocols.spec.js.map