"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/utils");
const typescript_memoize_1 = require("typescript-memoize");
const contracts_1 = require("../contracts");
const app_identity_1 = require("../ethereum/utils/app-identity");
const types_1 = require("../types");
const utils_2 = require("../utils");
class AppInstance {
    constructor(participants, defaultTimeout, appInterface, isVirtualApp, appSeqNo, latestState, latestVersionNumber, latestTimeout, outcomeType, twoPartyOutcomeInterpreterParamsInternal, multiAssetMultiPartyCoinTransferInterpreterParamsInternal, singleAssetTwoPartyCoinTransferInterpreterParamsInternal) {
        this.participants = participants;
        this.defaultTimeout = defaultTimeout;
        this.appInterface = appInterface;
        this.isVirtualApp = isVirtualApp;
        this.appSeqNo = appSeqNo;
        this.latestState = latestState;
        this.latestVersionNumber = latestVersionNumber;
        this.latestTimeout = latestTimeout;
        this.outcomeType = outcomeType;
        this.twoPartyOutcomeInterpreterParamsInternal = twoPartyOutcomeInterpreterParamsInternal;
        this.multiAssetMultiPartyCoinTransferInterpreterParamsInternal = multiAssetMultiPartyCoinTransferInterpreterParamsInternal;
        this.singleAssetTwoPartyCoinTransferInterpreterParamsInternal = singleAssetTwoPartyCoinTransferInterpreterParamsInternal;
    }
    get twoPartyOutcomeInterpreterParams() {
        if (this.outcomeType !== types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME) {
            throw Error(`Invalid Accessor. AppInstance has outcomeType ${this.outcomeType}, not TWO_PARTY_FIXED_OUTCOME`);
        }
        return this.twoPartyOutcomeInterpreterParamsInternal;
    }
    get multiAssetMultiPartyCoinTransferInterpreterParams() {
        if (this.outcomeType !== types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER) {
            throw Error(`Invalid Accessor. AppInstance has outcomeType ${this.outcomeType}, not MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER`);
        }
        return this.multiAssetMultiPartyCoinTransferInterpreterParamsInternal;
    }
    get singleAssetTwoPartyCoinTransferInterpreterParams() {
        if (this.outcomeType !== types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER) {
            throw Error(`Invalid Accessor. AppInstance has outcomeType ${this.outcomeType}, not SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER `);
        }
        return this.singleAssetTwoPartyCoinTransferInterpreterParamsInternal;
    }
    static fromJson(json) {
        const deserialized = utils_2.bigNumberifyJson(json);
        return new AppInstance(deserialized.participants, deserialized.defaultTimeout, deserialized.appInterface, deserialized.isVirtualApp, deserialized.appSeqNo, deserialized.latestState, deserialized.latestVersionNumber, deserialized.latestTimeout, deserialized.outcomeType, deserialized.twoPartyOutcomeInterpreterParams, deserialized.multiAssetMultiPartyCoinTransferInterpreterParams, deserialized.singleAssetTwoPartyCoinTransferInterpreterParams);
    }
    toJson() {
        return utils_2.bigNumberifyJson({
            participants: this.participants,
            defaultTimeout: this.defaultTimeout,
            appInterface: this.appInterface,
            isVirtualApp: this.isVirtualApp,
            appSeqNo: this.appSeqNo,
            latestState: this.latestState,
            latestVersionNumber: this.latestVersionNumber,
            latestTimeout: this.latestTimeout,
            outcomeType: this.outcomeType,
            twoPartyOutcomeInterpreterParams: this
                .twoPartyOutcomeInterpreterParamsInternal,
            multiAssetMultiPartyCoinTransferInterpreterParams: this
                .multiAssetMultiPartyCoinTransferInterpreterParamsInternal,
            singleAssetTwoPartyCoinTransferInterpreterParams: this
                .singleAssetTwoPartyCoinTransferInterpreterParamsInternal,
            identityHash: this.identityHash
        });
    }
    get identityHash() {
        return app_identity_1.appIdentityToHash(this.identity);
    }
    get identity() {
        return {
            participants: this.participants,
            appDefinition: this.appInterface.addr,
            defaultTimeout: this.defaultTimeout,
            channelNonce: this.appSeqNo
        };
    }
    get hashOfLatestState() {
        return utils_1.keccak256(this.encodedLatestState);
    }
    get encodedLatestState() {
        return utils_1.defaultAbiCoder.encode([this.appInterface.stateEncoding], [this.latestState]);
    }
    get encodedInterpreterParams() {
        if (!this.isVirtualApp) {
            switch (this.outcomeType) {
                case types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER: {
                    return utils_1.defaultAbiCoder.encode([types_1.singleAssetTwoPartyCoinTransferInterpreterParamsEncoding], [this.singleAssetTwoPartyCoinTransferInterpreterParams]);
                }
                case types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER: {
                    return utils_1.defaultAbiCoder.encode([types_1.multiAssetMultiPartyCoinTransferInterpreterParamsEncoding], [this.multiAssetMultiPartyCoinTransferInterpreterParams]);
                }
                case types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME: {
                    return utils_1.defaultAbiCoder.encode([types_1.twoPartyFixedOutcomeInterpreterParamsEncoding], [this.twoPartyOutcomeInterpreterParams]);
                }
                default: {
                    throw Error("The outcome type in this application logic contract is not supported yet.");
                }
            }
        }
        else {
            switch (this.outcomeType) {
                case types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER: {
                    const { limit, tokenAddress } = this.singleAssetTwoPartyCoinTransferInterpreterParams;
                    return utils_1.defaultAbiCoder.encode([
                        `tuple(uint256 capitalProvided, address payable capitalProvider, address virtualAppUser, address tokenAddress)`,
                    ], [
                        {
                            tokenAddress,
                            capitalProvided: limit,
                            capitalProvider: this.participants[0],
                            virtualAppUser: this.participants[1]
                        }
                    ]);
                }
                case types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER: {
                    throw Error("Unimplemented Error. There is no interpreter params encoded for the (virtual app case of) MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER OutcomeType on the AppInstance model.");
                }
                case types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME: {
                    const { amount, playerAddrs, tokenAddress } = this.twoPartyOutcomeInterpreterParams;
                    return utils_1.defaultAbiCoder.encode([types_1.virtualAppAgreementEncoding], [
                        {
                            tokenAddress,
                            capitalProvided: amount,
                            capitalProvider: playerAddrs[0],
                            virtualAppUser: playerAddrs[1]
                        }
                    ]);
                }
                default: {
                    throw Error("The outcome type in this application logic contract is not supported yet.");
                }
            }
        }
    }
    get state() {
        return this.latestState;
    }
    get versionNumber() {
        return this.latestVersionNumber;
    }
    get timeout() {
        return this.latestTimeout;
    }
    setState(newState, timeout = this.defaultTimeout) {
        try {
            utils_1.defaultAbiCoder.encode([this.appInterface.stateEncoding], [newState]);
        }
        catch (e) {
            throw Error(`Attempted to setState on an app with an invalid state object.
          - appInstanceIdentityHash = ${this.identityHash}
          - newState = ${newState}
          - encodingExpected = ${this.appInterface.stateEncoding}
          Error: ${e.message}`);
        }
        return AppInstance.fromJson(Object.assign({}, this.toJson(), { latestState: newState, latestVersionNumber: this.versionNumber + 1, latestTimeout: timeout }));
    }
    async computeOutcome(state, provider) {
        return this.toEthersContract(provider).functions.computeOutcome(this.encodeState(state));
    }
    async computeOutcomeWithCurrentState(provider) {
        return this.computeOutcome(this.state, provider);
    }
    async computeStateTransition(action, provider) {
        const ret = {};
        const computedNextState = this.decodeAppState(await this.toEthersContract(provider).functions.applyAction(this.encodedLatestState, this.encodeAction(action)));
        for (const key in this.state) {
            ret[key] = computedNextState[key];
        }
        return ret;
    }
    encodeAction(action) {
        return utils_1.defaultAbiCoder.encode([this.appInterface.actionEncoding], [action]);
    }
    encodeState(state) {
        return utils_1.defaultAbiCoder.encode([this.appInterface.stateEncoding], [state]);
    }
    decodeAppState(encodedSolidityValueType) {
        return utils_1.defaultAbiCoder.decode([this.appInterface.stateEncoding], encodedSolidityValueType)[0];
    }
    toEthersContract(provider) {
        return new ethers_1.Contract(this.appInterface.addr, contracts_1.CounterfactualApp.abi, provider);
    }
}
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], AppInstance.prototype, "identityHash", null);
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], AppInstance.prototype, "identity", null);
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], AppInstance.prototype, "hashOfLatestState", null);
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], AppInstance.prototype, "encodedLatestState", null);
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], AppInstance.prototype, "encodedInterpreterParams", null);
exports.AppInstance = AppInstance;
//# sourceMappingURL=app-instance.js.map