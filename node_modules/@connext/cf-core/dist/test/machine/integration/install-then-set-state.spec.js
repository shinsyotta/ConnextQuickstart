"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../../src/constants");
const ethereum_1 = require("../../../src/ethereum");
const xkeys_1 = require("../../../src/machine/xkeys");
const models_1 = require("../../../src/models");
const free_balance_1 = require("../../../src/models/free-balance");
const contracts_1 = require("../../contracts");
const utils_2 = require("../../integration/utils");
const bignumber_jest_matcher_1 = require("./bignumber-jest-matcher");
const connect_ganache_1 = require("./connect-ganache");
const random_signing_keys_1 = require("./random-signing-keys");
const CREATE_PROXY_AND_SETUP_GAS = 1e6;
const SETSTATE_COMMITMENT_GAS = 1e6;
const CONDITIONAL_TX_DELEGATECALL_GAS = 1e6;
let provider;
let wallet;
let network;
let appRegistry;
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
beforeAll(async () => {
    jest.setTimeout(10000);
    [provider, wallet, {}] = await connect_ganache_1.connectToGanache();
    network = global["networkContext"];
    appRegistry = new ethers_1.Contract(network.ChallengeRegistry, contracts_1.ChallengeRegistry.abi, wallet);
});
describe("Scenario: install AppInstance, set state, put on-chain", () => {
    it("returns the funds the app had locked up for both ETH and ERC20 in app and free balance", async (done) => {
        const xprvs = random_signing_keys_1.getRandomExtendedPrvKeys(2);
        const multisigOwnerKeys = xkeys_1.xkeysToSortedKthSigningKeys(xprvs, 0);
        const xpubs = xprvs.map(random_signing_keys_1.extendedPrvKeyToExtendedPubKey);
        const erc20TokenAddress = global["networkContext"].DolphinCoin;
        const proxyFactory = new ethers_1.Contract(network.ProxyFactory, contracts_1.ProxyFactory.abi, wallet);
        proxyFactory.once("ProxyCreation", async (proxyAddress) => {
            let stateChannel = models_1.StateChannel.setupChannel(network.IdentityApp, proxyFactory.address, proxyAddress, xpubs, 1).setFreeBalance(free_balance_1.FreeBalanceClass.createWithFundedTokenAmounts(multisigOwnerKeys.map(key => key.address), constants_1.WeiPerEther, [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, erc20TokenAddress]));
            const uniqueAppSigningKeys = xkeys_1.xkeysToSortedKthSigningKeys(xprvs, stateChannel.numProposedApps);
            const identityAppInstance = new models_1.AppInstance(uniqueAppSigningKeys.map(x => x.address), stateChannel.freeBalance.defaultTimeout, {
                addr: network.IdentityApp,
                stateEncoding: "tuple(address to, uint256 amount)[][]",
                actionEncoding: undefined
            }, false, stateChannel.numProposedApps, [
                [
                    { to: multisigOwnerKeys[0].address, amount: constants_1.WeiPerEther },
                    { to: multisigOwnerKeys[1].address, amount: constants_1.Zero }
                ],
                [
                    { to: multisigOwnerKeys[0].address, amount: constants_1.Zero },
                    { to: multisigOwnerKeys[1].address, amount: constants_1.WeiPerEther }
                ]
            ], 0, stateChannel.freeBalance.timeout, types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER, undefined, {
                limit: [constants_1.WeiPerEther, constants_1.WeiPerEther],
                tokenAddresses: [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS, erc20TokenAddress]
            }, undefined);
            stateChannel = stateChannel.installApp(identityAppInstance, {
                [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]: {
                    [multisigOwnerKeys[0].address]: constants_1.WeiPerEther,
                    [multisigOwnerKeys[1].address]: constants_1.Zero
                },
                [erc20TokenAddress]: {
                    [multisigOwnerKeys[0].address]: constants_1.Zero,
                    [multisigOwnerKeys[1].address]: constants_1.WeiPerEther
                }
            });
            const setStateCommitment = new ethereum_1.SetStateCommitment(network, identityAppInstance.identity, utils_1.keccak256(identityAppInstance.encodedLatestState), identityAppInstance.versionNumber + 1, identityAppInstance.timeout);
            await wallet.sendTransaction(Object.assign({}, setStateCommitment.getSignedTransaction([
                uniqueAppSigningKeys[0].signDigest(setStateCommitment.hashToSign()),
                uniqueAppSigningKeys[1].signDigest(setStateCommitment.hashToSign())
            ]), { gasLimit: SETSTATE_COMMITMENT_GAS }));
            const setStateCommitmentForFreeBalance = new ethereum_1.SetStateCommitment(network, stateChannel.freeBalance.identity, stateChannel.freeBalance.hashOfLatestState, stateChannel.freeBalance.versionNumber, stateChannel.freeBalance.timeout);
            await wallet.sendTransaction(Object.assign({}, setStateCommitmentForFreeBalance.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(setStateCommitmentForFreeBalance.hashToSign()),
                multisigOwnerKeys[1].signDigest(setStateCommitmentForFreeBalance.hashToSign())
            ]), { gasLimit: SETSTATE_COMMITMENT_GAS }));
            for (const _ of Array(identityAppInstance.timeout)) {
                await provider.send("evm_mine", []);
            }
            await appRegistry.functions.setOutcome(identityAppInstance.identity, identityAppInstance.encodedLatestState);
            await appRegistry.functions.setOutcome(stateChannel.freeBalance.identity, stateChannel.freeBalance.encodedLatestState);
            const conditionalTransaction = new ethereum_1.ConditionalTransaction(network, stateChannel.multisigAddress, stateChannel.multisigOwners, identityAppInstance.identityHash, stateChannel.freeBalance.identityHash, network.MultiAssetMultiPartyCoinTransferInterpreter, utils_1.defaultAbiCoder.encode([types_1.multiAssetMultiPartyCoinTransferInterpreterParamsEncoding], [
                identityAppInstance.multiAssetMultiPartyCoinTransferInterpreterParams
            ]));
            const multisigDelegateCallTx = conditionalTransaction.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(conditionalTransaction.hashToSign()),
                multisigOwnerKeys[1].signDigest(conditionalTransaction.hashToSign())
            ]);
            await wallet.sendTransaction({
                to: proxyAddress,
                value: utils_1.parseEther("2")
            });
            await utils_2.transferERC20Tokens(proxyAddress, erc20TokenAddress, contracts_1.DolphinCoin.abi, utils_1.parseEther("2"));
            await wallet.sendTransaction(Object.assign({}, multisigDelegateCallTx, { gasLimit: CONDITIONAL_TX_DELEGATECALL_GAS }));
            expect(await provider.getBalance(proxyAddress)).toBeEq(constants_1.WeiPerEther);
            expect(await provider.getBalance(multisigOwnerKeys[0].address)).toBeEq(constants_1.WeiPerEther);
            expect(await provider.getBalance(multisigOwnerKeys[1].address)).toBeEq(constants_1.Zero);
            const erc20Contract = new ethers_1.Contract(erc20TokenAddress, contracts_1.DolphinCoin.abi, new providers_1.JsonRpcProvider(global["ganacheURL"]));
            expect(await erc20Contract.functions.balanceOf(proxyAddress)).toBeEq(constants_1.WeiPerEther);
            expect(await erc20Contract.functions.balanceOf(multisigOwnerKeys[0].address)).toBeEq(constants_1.Zero);
            expect(await erc20Contract.functions.balanceOf(multisigOwnerKeys[1].address)).toBeEq(constants_1.WeiPerEther);
            const freeBalanceConditionalTransaction = new ethereum_1.SetupCommitment(network, stateChannel.multisigAddress, stateChannel.multisigOwners, stateChannel.freeBalance.identity);
            const multisigDelegateCallTx2 = freeBalanceConditionalTransaction.getSignedTransaction([
                multisigOwnerKeys[0].signDigest(freeBalanceConditionalTransaction.hashToSign()),
                multisigOwnerKeys[1].signDigest(freeBalanceConditionalTransaction.hashToSign())
            ]);
            await wallet.sendTransaction(Object.assign({}, multisigDelegateCallTx2, { gasLimit: CONDITIONAL_TX_DELEGATECALL_GAS }));
            expect(await provider.getBalance(proxyAddress)).toBeEq(constants_1.Zero);
            expect(await provider.getBalance(multisigOwnerKeys[0].address)).toBeEq(constants_1.WeiPerEther);
            expect(await provider.getBalance(multisigOwnerKeys[1].address)).toBeEq(constants_1.WeiPerEther);
            expect(await erc20Contract.functions.balanceOf(proxyAddress)).toBeEq(constants_1.Zero);
            expect(await erc20Contract.functions.balanceOf(multisigOwnerKeys[0].address)).toBeEq(constants_1.WeiPerEther);
            expect(await erc20Contract.functions.balanceOf(multisigOwnerKeys[1].address)).toBeEq(constants_1.WeiPerEther);
            done();
        });
        await proxyFactory.functions.createProxyWithNonce(network.MinimumViableMultisig, new utils_1.Interface(contracts_1.MinimumViableMultisig.abi).functions.setup.encode([
            multisigOwnerKeys.map(x => x.address)
        ]), 0, { gasLimit: CREATE_PROXY_AND_SETUP_GAS });
    });
});
//# sourceMappingURL=install-then-set-state.spec.js.map