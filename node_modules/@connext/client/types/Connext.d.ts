/// <reference types="node" />
import { Web3Provider } from 'ethers/providers';
import { EventEmitter } from 'events';
import { IChannelManager } from './contract/ChannelManager';
import { BuyController, CollateralController, DepositController, ExchangeController, RedeemController, StateUpdateController, SyncController, ThreadController, WithdrawalController } from './controllers';
import { IHubAPIClient } from './Hub';
import { Logger } from './lib';
import { ConnextStore } from './state';
import { StateGenerator } from './StateGenerator';
import { Address, ChannelState, ConnextProvider, CustodialBalanceRowBN, Omit, PartialPurchaseRequest, Payment, PaymentProfileConfig, PurchasePaymentRow, PurchaseRowWithPayments, SignedDepositRequestProposal, SuccinctWithdrawalParameters, ThreadState, UnsignedChannelState, UnsignedThreadState, WithdrawalParameters } from './types';
import { Utils } from './Utils';
import { Validator } from './validator';
import { Wallet } from './Wallet';
export interface IConnextChannelOptions {
    connextProvider?: ConnextProvider;
    ethUrl?: string;
    hubUrl: string;
    logLevel?: number;
    mnemonic?: string;
    privateKey?: string;
    user?: string;
    externalWallet?: any;
    web3Provider?: Web3Provider;
    loadState?(): any;
    safeSignHook?(state: ChannelState | ThreadState): Promise<string>;
    saveState?(state: any): any;
}
export interface IConnextChannelInternalOptions extends IConnextChannelOptions {
    contract: IChannelManager;
    contractAddress: string;
    ethChainId: string;
    hub: IHubAPIClient;
    hubAddress: string;
    logLevel?: number;
    maxCollateralization: string;
    store?: ConnextStore;
    tokenAddress: string;
    user: string;
    wallet: Wallet;
    saveState?(state: any): any;
    loadState?(): any;
}
export declare const createClient: (opts: IConnextChannelOptions) => Promise<ConnextChannel>;
/**
 * Create an instance with:
 *  > const client = createChannel({...})
 *  > client.start() // start polling
 *  > client.on('onStateChange', state => {
 *  .   console.log('Connext state changed:', state)
 *  . })
 */
export declare abstract class ConnextChannel extends EventEmitter {
    opts: IConnextChannelInternalOptions;
    StateGenerator?: StateGenerator;
    Utils?: Utils;
    utils: Utils;
    Validator?: Validator;
    private internal;
    constructor(opts: IConnextChannelInternalOptions);
    start(): Promise<void>;
    stop(): Promise<void>;
    setPollInterval(ms: number): Promise<void>;
    getProfileConfig(): Promise<PaymentProfileConfig | undefined>;
    startProfileSession(): Promise<void>;
    buy(purchase: PartialPurchaseRequest): Promise<{
        purchaseId: string;
    }>;
    deposit(payment: Partial<Payment>, overrides: any): Promise<void>;
    exchange(toSell: string, currency: 'wei' | 'token'): Promise<void>;
    recipientNeedsCollateral(recipient: Address, amount: Payment): Promise<string | undefined>;
    withdraw(withdrawal: Partial<WithdrawalParameters> | SuccinctWithdrawalParameters): Promise<void>;
    requestCollateral(): Promise<void>;
    redeem(secret: string): Promise<{
        purchaseId: string;
    }>;
    getPaymentHistory(): Promise<PurchasePaymentRow[]>;
    getPaymentById(purchaseId: string): Promise<PurchaseRowWithPayments<object, string>>;
}
export declare class ConnextInternal extends ConnextChannel {
    contract: IChannelManager;
    hub: IHubAPIClient;
    opts: IConnextChannelInternalOptions;
    provider: any;
    store: ConnextStore;
    utils: Utils;
    validator: Validator;
    wallet: Wallet;
    log: Logger;
    buyController: BuyController;
    collateralController: CollateralController;
    depositController: DepositController;
    exchangeController: ExchangeController;
    redeemController: RedeemController;
    stateUpdateController: StateUpdateController;
    syncController: SyncController;
    threadController: ThreadController;
    withdrawalController: WithdrawalController;
    private _latestState;
    private _saving;
    private _savePending;
    constructor(opts: IConnextChannelInternalOptions);
    setPollInterval(ms: number): Promise<void>;
    calculateChannelWithdrawal(_withdrawal: Partial<WithdrawalParameters> | SuccinctWithdrawalParameters, custodial: CustodialBalanceRowBN): any;
    withdraw(withdrawal: Partial<WithdrawalParameters> | SuccinctWithdrawalParameters): Promise<void>;
    withdrawal(params: WithdrawalParameters): Promise<void>;
    recipientNeedsCollateral(recipient: Address, amount: Payment): Promise<string | undefined>;
    start(): Promise<void>;
    stop(): Promise<void>;
    generateSecret(): string;
    getContractEvents(eventName: string, fromBlock: number): Promise<any>;
    signChannelState(state: UnsignedChannelState): Promise<ChannelState>;
    signThreadState(state: UnsignedThreadState): Promise<ThreadState>;
    signDepositRequestProposal(args: Omit<SignedDepositRequestProposal, 'sigUser'>): Promise<SignedDepositRequestProposal>;
    /**
     * Waits for any persistent state to be saved.
     * If the save fails, the promise will reject.
     */
    awaitPersistentStateSaved(): Promise<void>;
    private _saveState;
    /**
     * Because it's possible that the state will continue to be updated while
     * a previous state is saving, loop until the state doesn't change while
     * it's being saved before we return.
     */
    private _saveLoop;
    private dispatch;
    private syncConfig;
    private getControllers;
    private getStore;
}
