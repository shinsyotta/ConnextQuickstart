"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const constants_2 = require("../../../../src/constants");
const machine_1 = require("../../../../src/machine");
const xkeys_1 = require("../../../../src/machine/xkeys");
const utils_1 = require("../../../../src/utils");
const contracts_1 = require("../../../contracts");
const bignumber_jest_matcher_1 = require("../bignumber-jest-matcher");
const connect_ganache_1 = require("../connect-ganache");
const message_router_1 = require("../message-router");
const mininode_1 = require("../mininode");
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
var Participant;
(function (Participant) {
    Participant[Participant["A"] = 0] = "A";
    Participant[Participant["B"] = 1] = "B";
    Participant[Participant["C"] = 2] = "C";
})(Participant = exports.Participant || (exports.Participant = {}));
class TestRunner {
    async connectToGanache() {
        const [provider, wallet, {}] = await connect_ganache_1.connectToGanache();
        this.provider = provider;
        const network = global["networkContext"];
        this.identityApp = await new ethers_1.ContractFactory(contracts_1.IdentityApp.abi, contracts_1.IdentityApp.evm.bytecode, wallet).deploy();
        this.mininodeA = new mininode_1.MiniNode(network, provider);
        this.mininodeB = new mininode_1.MiniNode(network, provider);
        this.mininodeC = new mininode_1.MiniNode(network, provider);
        const proxyBytecode = contracts_1.Proxy.evm.bytecode.object;
        this.multisigAB = await utils_1.getCreate2MultisigAddress([this.mininodeA.xpub, this.mininodeB.xpub], network.ProxyFactory, network.MinimumViableMultisig, provider);
        this.multisigAC = await utils_1.getCreate2MultisigAddress([this.mininodeA.xpub, this.mininodeC.xpub], network.ProxyFactory, network.MinimumViableMultisig, provider);
        this.multisigBC = await utils_1.getCreate2MultisigAddress([this.mininodeB.xpub, this.mininodeC.xpub], network.ProxyFactory, network.MinimumViableMultisig, provider);
        this.mr = new message_router_1.MessageRouter([
            this.mininodeA,
            this.mininodeB,
            this.mininodeC
        ]);
    }
    async setup() {
        this.mininodeA.scm.set(this.multisigAB, (await this.mininodeA.protocolRunner.runSetupProtocol({
            initiatorXpub: this.mininodeA.xpub,
            responderXpub: this.mininodeB.xpub,
            multisigAddress: this.multisigAB
        })).get(this.multisigAB));
        await this.mr.waitForAllPendingPromises();
        this.mininodeB.scm.set(this.multisigBC, (await this.mininodeB.protocolRunner.runSetupProtocol({
            initiatorXpub: this.mininodeB.xpub,
            responderXpub: this.mininodeC.xpub,
            multisigAddress: this.multisigBC
        })).get(this.multisigBC));
        await this.mr.waitForAllPendingPromises();
    }
    async unsafeFund() {
        for (const mininode of [this.mininodeA, this.mininodeB]) {
            const sc = mininode.scm.get(this.multisigAB);
            mininode.scm.set(this.multisigAB, sc.incrementFreeBalance({
                [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]: {
                    [sc.getFreeBalanceAddrOf(this.mininodeA.xpub)]: constants_1.One,
                    [sc.getFreeBalanceAddrOf(this.mininodeB.xpub)]: constants_1.One
                },
                [TestRunner.TEST_TOKEN_ADDRESS]: {
                    [sc.getFreeBalanceAddrOf(this.mininodeA.xpub)]: constants_1.One,
                    [sc.getFreeBalanceAddrOf(this.mininodeB.xpub)]: constants_1.One
                }
            }));
        }
        for (const mininode of [this.mininodeB, this.mininodeC]) {
            const sc = mininode.scm.get(this.multisigBC);
            mininode.scm.set(this.multisigBC, sc.incrementFreeBalance({
                [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]: {
                    [sc.getFreeBalanceAddrOf(this.mininodeB.xpub)]: constants_1.One,
                    [sc.getFreeBalanceAddrOf(this.mininodeC.xpub)]: constants_1.One
                },
                [TestRunner.TEST_TOKEN_ADDRESS]: {
                    [sc.getFreeBalanceAddrOf(this.mininodeB.xpub)]: constants_1.One,
                    [sc.getFreeBalanceAddrOf(this.mininodeC.xpub)]: constants_1.One
                }
            }));
        }
    }
    async installVirtualEqualDeposits(outcomeType, tokenAddress) {
        const stateEncoding = {
            [types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME]: "uint8",
            [types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER]: "tuple(address to, uint256 amount)[2]",
            [types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER]: "tuple(address to, uint256 amount)[][]"
        }[outcomeType];
        const initialState = {
            [types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME]: 0,
            [types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER]: [
                {
                    to: machine_1.xkeyKthAddress(this.mininodeA.xpub, 0),
                    amount: constants_1.Two
                },
                {
                    to: machine_1.xkeyKthAddress(this.mininodeC.xpub, 0),
                    amount: constants_1.Zero
                }
            ],
            [types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER]: [
                [
                    {
                        to: machine_1.xkeyKthAddress(this.mininodeA.xpub, 0),
                        amount: constants_1.Two
                    },
                    {
                        to: machine_1.xkeyKthAddress(this.mininodeC.xpub, 0),
                        amount: constants_1.Zero
                    }
                ]
            ]
        }[outcomeType];
        await this.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.InstallVirtualApp, this.mininodeA.scm, {
            outcomeType,
            tokenAddress,
            initialState,
            initiatorXpub: this.mininodeA.xpub,
            intermediaryXpub: this.mininodeB.xpub,
            responderXpub: this.mininodeC.xpub,
            initiatorBalanceDecrement: constants_1.One,
            responderBalanceDecrement: constants_1.One,
            appSeqNo: 1,
            appInterface: {
                stateEncoding,
                addr: this.identityApp.address,
                actionEncoding: undefined
            },
            defaultTimeout: 40
        });
    }
    async installEqualDeposits(outcomeType, tokenAddress) {
        const stateEncoding = {
            [types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME]: "uint8",
            [types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER]: "tuple(address to, uint256 amount)[2]",
            [types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER]: "tuple(address to, uint256 amount)[][]"
        }[outcomeType];
        const initialState = {
            [types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME]: 0,
            [types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER]: [
                {
                    to: machine_1.xkeyKthAddress(this.mininodeA.xpub, 0),
                    amount: constants_1.Two
                },
                {
                    to: machine_1.xkeyKthAddress(this.mininodeB.xpub, 0),
                    amount: constants_1.Zero
                }
            ],
            [types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER]: [
                [
                    {
                        to: machine_1.xkeyKthAddress(this.mininodeA.xpub, 0),
                        amount: constants_1.Two
                    },
                    {
                        to: machine_1.xkeyKthAddress(this.mininodeB.xpub, 0),
                        amount: constants_1.Zero
                    }
                ]
            ]
        }[outcomeType];
        const participants = xkeys_1.sortAddresses([
            machine_1.xkeyKthAddress(this.mininodeA.xpub, 1),
            machine_1.xkeyKthAddress(this.mininodeB.xpub, 1)
        ]);
        await this.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.Install, this.mininodeA.scm, {
            appInterface: {
                stateEncoding,
                addr: this.identityApp.address,
                actionEncoding: undefined
            },
            appSeqNo: 1,
            defaultTimeout: 40,
            disableLimit: false,
            initialState,
            initiatorBalanceDecrement: constants_1.One,
            initiatorDepositTokenAddress: tokenAddress,
            initiatorXpub: this.mininodeA.xpub,
            multisigAddress: this.multisigAB,
            outcomeType,
            participants,
            responderBalanceDecrement: constants_1.One,
            responderDepositTokenAddress: tokenAddress,
            responderXpub: this.mininodeB.xpub
        });
    }
    async installSplitDeposits(outcomeType, tokenAddressA, tokenAddressB) {
        const stateEncoding = {
            [types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME]: "uint8",
            [types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER]: "tuple(address to, uint256 amount)[2]",
            [types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER]: "tuple(address to, uint256 amount)[][]"
        }[outcomeType];
        const initialState = {
            [types_1.OutcomeType.TWO_PARTY_FIXED_OUTCOME]: 0,
            [types_1.OutcomeType.SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER]: [
                {
                    to: machine_1.xkeyKthAddress(this.mininodeA.xpub, 0),
                    amount: constants_1.Two
                },
                {
                    to: machine_1.xkeyKthAddress(this.mininodeB.xpub, 0),
                    amount: constants_1.Zero
                }
            ],
            [types_1.OutcomeType.MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER]: [
                [
                    {
                        to: machine_1.xkeyKthAddress(this.mininodeA.xpub, 0),
                        amount: constants_1.Two
                    },
                    {
                        to: machine_1.xkeyKthAddress(this.mininodeB.xpub, 0),
                        amount: constants_1.Zero
                    }
                ]
            ]
        }[outcomeType];
        const participants = xkeys_1.sortAddresses([
            machine_1.xkeyKthAddress(this.mininodeA.xpub, 1),
            machine_1.xkeyKthAddress(this.mininodeB.xpub, 1)
        ]);
        await this.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.Install, this.mininodeA.scm, {
            participants,
            outcomeType,
            initialState,
            initiatorXpub: this.mininodeA.xpub,
            responderXpub: this.mininodeB.xpub,
            multisigAddress: this.multisigAB,
            initiatorBalanceDecrement: constants_1.One,
            responderBalanceDecrement: constants_1.One,
            appInterface: {
                stateEncoding,
                addr: this.identityApp.address,
                actionEncoding: undefined
            },
            appSeqNo: 1,
            defaultTimeout: 40,
            initiatorDepositTokenAddress: tokenAddressA,
            responderDepositTokenAddress: tokenAddressB,
            disableLimit: false
        });
    }
    async uninstallVirtual() {
        const multisig = this.mininodeA.scm.get(this.multisigAC);
        if (!multisig) {
            throw new Error(`uninstallVirtual: Couldn't find multisig for ${this.multisigAC}`);
        }
        const [virtualAppInstance] = [...multisig.appInstances.values()];
        await this.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.UninstallVirtualApp, this.mininodeA.scm, {
            targetOutcome: await virtualAppInstance.computeOutcome(virtualAppInstance.latestState, this.provider),
            initiatorXpub: this.mininodeA.xpub,
            intermediaryXpub: this.mininodeB.xpub,
            responderXpub: this.mininodeC.xpub,
            targetAppIdentityHash: virtualAppInstance.identityHash
        });
        await this.mr.waitForAllPendingPromises();
    }
    async uninstall() {
        const multisig = this.mininodeA.scm.get(this.multisigAB);
        if (!multisig) {
            throw new Error(`uninstall: Couldn't find multisig for ${this.multisigAC}`);
        }
        const appInstances = multisig.appInstances;
        const [key] = [...appInstances.keys()].filter(key => {
            return (key !==
                this.mininodeA.scm.get(this.multisigAB).freeBalance.identityHash);
        });
        await this.mininodeA.protocolRunner.initiateProtocol(machine_1.Protocol.Uninstall, this.mininodeA.scm, {
            appIdentityHash: key,
            initiatorXpub: this.mininodeA.xpub,
            responderXpub: this.mininodeB.xpub,
            multisigAddress: this.multisigAB
        });
        await this.mr.waitForAllPendingPromises();
    }
    assertFB(participant, tokenAddress, expected) {
        const mininode = {
            [Participant.A]: this.mininodeA,
            [Participant.B]: this.mininodeB,
            [Participant.C]: this.mininodeC
        }[participant];
        for (const multisig in [
            this.multisigAB,
            this.multisigBC,
            this.multisigAC
        ]) {
            if (mininode.scm.has(multisig)) {
                expect(mininode.scm
                    .get(multisig)
                    .getFreeBalanceClass()
                    .getBalance(tokenAddress, machine_1.xkeyKthAddress(mininode.xpub, 0))).toBeEq(expected);
            }
        }
    }
}
TestRunner.TEST_TOKEN_ADDRESS = "0x88a5C2d9919e46F883EB62F7b8Dd9d0CC45bc290";
exports.TestRunner = TestRunner;
//# sourceMappingURL=test-runner.js.map