"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class RequestDepositRightsController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.requestDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            const assetId = params.assetId || constants_1.AddressZero;
            validation_1.validate(validation_1.invalidAddress(assetId));
            let multisigBalance;
            if (assetId === constants_1.AddressZero) {
                multisigBalance = yield this.connext.ethProvider.getBalance(this.connext.multisigAddress);
            }
            else {
                const token = new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.connext.ethProvider);
                multisigBalance = yield token.balanceOf(this.connext.multisigAddress);
            }
            const { collateralizationInFlight } = yield this.node.getChannel();
            if (collateralizationInFlight) {
                throw new Error(`Cannot claim deposit rights while hub is depositing.`);
            }
            const existingBalanceRefundApp = yield this.connext.getBalanceRefundApp(assetId);
            if (existingBalanceRefundApp) {
                if (utils_1.bigNumberify(existingBalanceRefundApp.latestState["threshold"]).eq(multisigBalance) &&
                    existingBalanceRefundApp.latestState["recipient"] === this.connext.freeBalanceAddress) {
                    this.log.info(`Balance refund app for ${assetId} is in the correct state, doing nothing`);
                    return {
                        freeBalance: yield this.connext.getFreeBalance(assetId),
                        recipient: this.connext.freeBalanceAddress,
                        tokenAddress: assetId,
                    };
                }
                this.log.info(`Balance refund app is not in the correct state, uninstalling first`);
                yield this.connext.rescindDepositRights({ assetId });
                this.log.info(`Balance refund app uninstalled`);
            }
            this.log.info(`Installing balance refund app for ${assetId}`);
            yield this.proposeDepositInstall(assetId);
            const requestDepositRightsResponse = yield this.channelProvider.send(types_1.CFCoreTypes.RpcMethodNames.chan_requestDepositRights, {
                multisigAddress: this.channelProvider.multisigAddress,
                tokenAddress: assetId,
            });
            this.log.debug(`requestDepositRightsResponse Response: ${lib_1.stringify(requestDepositRightsResponse)}`);
            this.log.info(`Deposit rights gained for ${assetId}`);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            return {
                freeBalance,
                recipient: this.connext.freeBalanceAddress,
                tokenAddress: assetId,
            };
        });
        this.proposeDepositInstall = (assetId) => __awaiter(this, void 0, void 0, function* () {
            const threshold = assetId === constants_1.AddressZero
                ? yield this.ethProvider.getBalance(this.connext.multisigAddress)
                : yield new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.connext.multisigAddress);
            const initialState = {
                multisig: this.connext.multisigAddress,
                recipient: this.connext.freeBalanceAddress,
                threshold,
                tokenAddress: assetId,
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding, outcomeType, } = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.CoinBalanceRefundApp);
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: constants_1.Zero,
                initiatorDepositTokenAddress: assetId,
                outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
            };
            const appId = yield this.proposeAndWaitForAccepted(params);
            return appId;
        });
    }
}
exports.RequestDepositRightsController = RequestDepositRightsController;
//# sourceMappingURL=RequestDepositRightsController.js.map