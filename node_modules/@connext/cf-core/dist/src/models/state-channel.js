"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const free_balance_app_1 = require("../ethereum/utils/free-balance-app");
const xkeys_1 = require("../machine/xkeys");
const utils_1 = require("../utils");
const app_instance_1 = require("./app-instance");
const free_balance_1 = require("./free-balance");
const constants_1 = require("../constants");
exports.HARD_CODED_ASSUMPTIONS = {
    freeBalanceDefaultTimeout: 172800
};
const ERRORS = {
    APPS_NOT_EMPTY: (size) => `Expected the appInstances list to be empty but size ${size}`,
    APP_DOES_NOT_EXIST: (identityHash) => `Attempted to edit an appInstance that does not exist: identity hash = ${identityHash}`,
    FREE_BALANCE_MISSING: "Cannot find ETH Free Balance App in StateChannel",
    FREE_BALANCE_IDX_CORRUPT: (idx) => `Index ${idx} used to find ETH Free Balance is broken`,
    INSUFFICIENT_FUNDS: "Attempted to install an appInstance without sufficient funds",
    MULTISIG_OWNERS_NOT_SORTED: "multisigOwners parameter of StateChannel must be sorted"
};
function sortAddresses(addrs) {
    return addrs.sort((a, b) => (parseInt(a, 16) < parseInt(b, 16) ? -1 : 1));
}
class StateChannel {
    constructor(multisigAddress, userNeuteredExtendedKeys, proposedAppInstances = new Map([]), appInstances = new Map([]), singleAssetTwoPartyIntermediaryAgreements = new Map([]), freeBalanceAppInstance, monotonicNumProposedApps = 0) {
        this.multisigAddress = multisigAddress;
        this.userNeuteredExtendedKeys = userNeuteredExtendedKeys;
        this.proposedAppInstances = proposedAppInstances;
        this.appInstances = appInstances;
        this.singleAssetTwoPartyIntermediaryAgreements = singleAssetTwoPartyIntermediaryAgreements;
        this.freeBalanceAppInstance = freeBalanceAppInstance;
        this.monotonicNumProposedApps = monotonicNumProposedApps;
        userNeuteredExtendedKeys.forEach(xpub => {
            if (!xpub.startsWith("xpub")) {
                throw Error(`StateChannel constructor given invalid extended keys: ${utils_1.prettyPrintObject(userNeuteredExtendedKeys)}`);
            }
        });
    }
    get multisigOwners() {
        return this.getSigningKeysFor(0);
    }
    get numProposedApps() {
        return this.monotonicNumProposedApps;
    }
    get numActiveApps() {
        return this.appInstances.size;
    }
    getAppInstance(appInstanceIdentityHash) {
        if (!this.appInstances.has(appInstanceIdentityHash)) {
            throw Error(ERRORS.APP_DOES_NOT_EXIST(appInstanceIdentityHash));
        }
        return this.appInstances.get(appInstanceIdentityHash);
    }
    hasAppInstance(appInstanceId) {
        return this.appInstances.has(appInstanceId);
    }
    hasAppInstanceOfKind(address) {
        return (Array.from(this.appInstances.values()).filter((appInstance) => {
            return appInstance.appInterface.addr === address;
        }).length > 0);
    }
    mostRecentlyInstalledAppInstance() {
        if (this.appInstances.size === 0) {
            throw Error("There are no installed AppInstances in this StateChannel");
        }
        return [...this.appInstances.values()].reduce((prev, current) => current.appSeqNo > prev.appSeqNo ? current : prev);
    }
    mostRecentlyProposedAppInstance() {
        if (this.proposedAppInstances.size === 0) {
            throw Error("There are no proposed AppInstances in this StateChannel");
        }
        return [...this.proposedAppInstances.values()].reduce((prev, current) => current.appSeqNo > prev.appSeqNo ? current : prev);
    }
    getAppInstanceOfKind(address) {
        const appInstances = Array.from(this.appInstances.values()).filter((appInstance) => {
            return appInstance.appInterface.addr === address;
        });
        if (appInstances.length !== 1) {
            throw Error(`Either 0 or more than 1 AppInstance of addr ${address} exists on channel: ${this.multisigAddress}`);
        }
        return appInstances[0];
    }
    getAppInstancesOfKind(address) {
        const appInstances = Array.from(this.appInstances.values()).filter((appInstance) => {
            return appInstance.appInterface.addr === address;
        });
        if (appInstances.length === 0) {
            throw Error(`No AppInstance of addr ${address} exists on channel: ${this.multisigAddress}`);
        }
        return appInstances;
    }
    hasBalanceRefundAppInstance(balanceRefundAppDefinitionAddress, tokenAddress) {
        return (Array.from(this.appInstances.values()).filter((appInstance) => appInstance.appInterface.addr === balanceRefundAppDefinitionAddress &&
            appInstance.latestState["tokenAddress"] === tokenAddress).length > 0);
    }
    hasProposedBalanceRefundAppInstance(balanceRefundAppDefinitionAddress, tokenAddress) {
        return (Array.from(this.proposedAppInstances.values()).filter((appInstance) => appInstance.appDefinition === balanceRefundAppDefinitionAddress &&
            appInstance.initialState["tokenAddress"] === tokenAddress).length > 0);
    }
    getBalanceRefundAppInstance(balanceRefundAppDefinitionAddress, tokenAddress = constants_1.CONVENTION_FOR_ETH_TOKEN_ADDRESS) {
        const appInstances = this.getAppInstancesOfKind(balanceRefundAppDefinitionAddress).filter((appInstance) => appInstance.latestState["tokenAddress"] === tokenAddress);
        if (appInstances.length === 0) {
            throw Error(`No CoinBalanceRefund app instance of tokenAddress ${tokenAddress} exists on channel: ${this.multisigAddress}`);
        }
        if (appInstances.length > 1) {
            throw Error(`More than 1 CoinBalanceRefund app instance of tokenAddress ${tokenAddress} exists on channel: ${this.multisigAddress}`);
        }
        return appInstances[0];
    }
    isAppInstanceInstalled(appInstanceIdentityHash) {
        return this.appInstances.has(appInstanceIdentityHash);
    }
    getSigningKeysFor(addressIndex) {
        return sortAddresses(this.userNeuteredExtendedKeys.map(xpub => xkeys_1.xkeyKthAddress(xpub, addressIndex)));
    }
    getNextSigningKeys() {
        return this.getSigningKeysFor(this.monotonicNumProposedApps);
    }
    get hasFreeBalance() {
        return !!this.freeBalanceAppInstance;
    }
    get freeBalance() {
        if (this.freeBalanceAppInstance) {
            return this.freeBalanceAppInstance;
        }
        throw Error("There is no free balance app instance installed in this state channel");
    }
    getMultisigOwnerAddrOf(xpub) {
        const [alice, bob] = this.multisigOwners;
        const topLevelKey = xkeys_1.xkeyKthAddress(xpub, 0);
        if (topLevelKey !== alice && topLevelKey !== bob) {
            throw Error(`getMultisigOwnerAddrOf received invalid xpub not in multisigOwners: ${xpub}`);
        }
        return topLevelKey;
    }
    getFreeBalanceAddrOf(xpub) {
        const [alice, bob] = this.freeBalanceAppInstance.participants;
        const topLevelKey = xkeys_1.xkeyKthAddress(xpub, 0);
        if (topLevelKey !== alice && topLevelKey !== bob) {
            throw Error(`getFreeBalanceAddrOf received invalid xpub without free balance account: ${xpub}`);
        }
        return topLevelKey;
    }
    getFreeBalanceClass() {
        return free_balance_1.FreeBalanceClass.fromAppInstance(this.freeBalance);
    }
    build(args) {
        return new StateChannel(args.multisigAddress || this.multisigAddress, args.userNeuteredExtendedKeys || this.userNeuteredExtendedKeys, args.proposedAppInstances || this.proposedAppInstances, args.appInstances || this.appInstances, args.singleAssetTwoPartyIntermediaryAgreements ||
            this.singleAssetTwoPartyIntermediaryAgreements, args.freeBalanceAppInstance || this.freeBalanceAppInstance, args.monotonicNumProposedApps || this.monotonicNumProposedApps);
    }
    incrementFreeBalance(increments) {
        return this.build({
            freeBalanceAppInstance: this.getFreeBalanceClass()
                .increment(increments)
                .toAppInstance(this.freeBalance)
        });
    }
    addActiveApp(activeApp) {
        return this.build({
            freeBalanceAppInstance: this.getFreeBalanceClass()
                .addActiveApp(activeApp)
                .toAppInstance(this.freeBalance)
        });
    }
    removeActiveApp(activeApp) {
        return this.build({
            freeBalanceAppInstance: this.getFreeBalanceClass()
                .removeActiveApp(activeApp)
                .toAppInstance(this.freeBalance)
        });
    }
    addActiveAppAndIncrementFreeBalance(activeApp, tokenIndexedIncrements) {
        return this.incrementFreeBalance(tokenIndexedIncrements).addActiveApp(activeApp);
    }
    removeActiveAppAndIncrementFreeBalance(activeApp, tokenIndexedIncrements) {
        return this.removeActiveApp(activeApp).incrementFreeBalance(tokenIndexedIncrements);
    }
    setFreeBalance(newFreeBalanceClass) {
        return this.build({
            freeBalanceAppInstance: newFreeBalanceClass.toAppInstance(this.freeBalance)
        });
    }
    static setupChannel(freeBalanceAppAddress, multisigAddress, userNeuteredExtendedKeys, freeBalanceTimeout) {
        return new StateChannel(multisigAddress, userNeuteredExtendedKeys, new Map([]), new Map([]), new Map(), free_balance_1.createFreeBalance(userNeuteredExtendedKeys, freeBalanceAppAddress, freeBalanceTimeout || exports.HARD_CODED_ASSUMPTIONS.freeBalanceDefaultTimeout), 1);
    }
    static createEmptyChannel(multisigAddress, userNeuteredExtendedKeys) {
        return new StateChannel(multisigAddress, userNeuteredExtendedKeys, new Map([]), new Map(), new Map(), undefined, 1);
    }
    addProposal(proposal) {
        const proposedAppInstances = new Map(this.proposedAppInstances.entries());
        proposedAppInstances.set(proposal.identityHash, proposal);
        return this.build({
            proposedAppInstances,
            monotonicNumProposedApps: this.monotonicNumProposedApps + 1
        });
    }
    removeProposal(appInstanceId) {
        const proposedAppInstances = new Map(this.proposedAppInstances.entries());
        proposedAppInstances.delete(appInstanceId);
        return this.build({
            proposedAppInstances
        });
    }
    addAppInstance(appInstance) {
        const appInstances = new Map(this.appInstances.entries());
        appInstances.set(appInstance.identityHash, appInstance);
        return this.build({
            appInstances,
            monotonicNumProposedApps: this.monotonicNumProposedApps + 1
        });
    }
    removeAppInstance(appInstanceId) {
        const appInstances = new Map(this.appInstances.entries());
        appInstances.delete(appInstanceId);
        return this.build({
            appInstances
        });
    }
    setState(appInstanceIdentityHash, state) {
        const appInstance = this.getAppInstance(appInstanceIdentityHash);
        const appInstances = new Map(this.appInstances.entries());
        appInstances.set(appInstanceIdentityHash, appInstance.setState(state));
        return this.build({
            appInstances
        });
    }
    addSingleAssetTwoPartyIntermediaryAgreement(targetIdentityHash, agreement, decrements, tokenAddress) {
        const evaaInstances = new Map(this.singleAssetTwoPartyIntermediaryAgreements.entries());
        evaaInstances.set(targetIdentityHash, agreement);
        return this.build({
            singleAssetTwoPartyIntermediaryAgreements: evaaInstances
        }).addActiveAppAndIncrementFreeBalance(targetIdentityHash, {
            [tokenAddress]: free_balance_app_1.flip(decrements)
        });
    }
    removeSingleAssetTwoPartyIntermediaryAgreement(targetIdentityHash, increments, tokenAddress) {
        const singleAssetTwoPartyIntermediaryAgreements = new Map(this.singleAssetTwoPartyIntermediaryAgreements.entries());
        if (!singleAssetTwoPartyIntermediaryAgreements.delete(targetIdentityHash)) {
            throw Error(`cannot find agreement with target hash ${targetIdentityHash}`);
        }
        return this.build({
            singleAssetTwoPartyIntermediaryAgreements
        }).removeActiveAppAndIncrementFreeBalance(targetIdentityHash, {
            [tokenAddress]: increments
        });
    }
    installApp(appInstance, tokenIndexedDecrements) {
        const participants = this.getSigningKeysFor(appInstance.appSeqNo);
        if (!participants.every((v, idx) => v === appInstance.participants[idx])) {
            throw Error("AppInstance passed to installApp has incorrect participants");
        }
        const appInstances = new Map(this.appInstances.entries());
        appInstances.set(appInstance.identityHash, appInstance);
        let proposedAppInstances;
        if (this.proposedAppInstances.has(appInstance.identityHash)) {
            const withoutProposal = this.removeProposal(appInstance.identityHash);
            proposedAppInstances = withoutProposal.proposedAppInstances;
        }
        return this.build({
            appInstances,
            proposedAppInstances
        }).addActiveAppAndIncrementFreeBalance(appInstance.identityHash, free_balance_app_1.flipTokenIndexedBalances(tokenIndexedDecrements));
    }
    uninstallApp(appInstanceIdentityHash, tokenIndexedIncrements) {
        const appToBeUninstalled = this.getAppInstance(appInstanceIdentityHash);
        if (appToBeUninstalled.identityHash !== appInstanceIdentityHash) {
            throw Error(`Consistency error: app stored under key ${appInstanceIdentityHash} has identityHah ${appToBeUninstalled.identityHash}`);
        }
        const appInstances = new Map(this.appInstances.entries());
        if (!appInstances.delete(appToBeUninstalled.identityHash)) {
            throw Error(`Consistency error: managed to call get on ${appInstanceIdentityHash} but failed to call delete`);
        }
        return this.build({
            appInstances
        }).removeActiveAppAndIncrementFreeBalance(appInstanceIdentityHash, tokenIndexedIncrements);
    }
    getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(key) {
        const ret = this.singleAssetTwoPartyIntermediaryAgreements.get(key);
        if (!ret) {
            throw Error(`Could not find any eth virtual app agreements with virtual app ${key}`);
        }
        return ret;
    }
    toJson() {
        return {
            multisigAddress: this.multisigAddress,
            userNeuteredExtendedKeys: this.userNeuteredExtendedKeys,
            proposedAppInstances: [...this.proposedAppInstances.entries()],
            appInstances: [...this.appInstances.entries()].map((appInstanceEntry) => {
                return [appInstanceEntry[0], appInstanceEntry[1].toJson()];
            }),
            freeBalanceAppInstance: !!this.freeBalanceAppInstance
                ? this.freeBalanceAppInstance.toJson()
                :
                    undefined,
            monotonicNumProposedApps: this.monotonicNumProposedApps,
            singleAssetTwoPartyIntermediaryAgreements: [
                ...this.singleAssetTwoPartyIntermediaryAgreements.entries()
            ]
        };
    }
    static fromJson(json) {
        const dropNulls = (arr) => {
            if (arr) {
                return arr.filter((x) => !!x);
            }
            return arr;
        };
        try {
            return new StateChannel(json.multisigAddress, json.userNeuteredExtendedKeys, new Map([...Object.values(dropNulls(json.proposedAppInstances) || [])].map((proposal) => {
                return [proposal[0], proposal[1]];
            })), new Map([...Object.values(dropNulls(json.appInstances) || [])].map((appInstanceEntry) => {
                return [
                    appInstanceEntry[0],
                    app_instance_1.AppInstance.fromJson(appInstanceEntry[1])
                ];
            })), new Map(json.singleAssetTwoPartyIntermediaryAgreements || []), json.freeBalanceAppInstance
                ? app_instance_1.AppInstance.fromJson(json.freeBalanceAppInstance)
                : undefined, json.monotonicNumProposedApps);
        }
        catch (e) {
            throw new Error(`could not create state channel from json: ${utils_1.prettyPrintObject(json)}. Error: ${e}`);
        }
    }
    static async getPeersAddressFromChannel(myIdentifier, store, multisigAddress) {
        const stateChannel = await store.getStateChannel(multisigAddress);
        const owners = stateChannel.userNeuteredExtendedKeys;
        return owners.filter(owner => owner !== myIdentifier);
    }
    static async getPeersAddressFromAppInstanceID(myIdentifier, store, appInstanceId) {
        const multisigAddress = await store.getMultisigAddressFromAppInstance(appInstanceId);
        return StateChannel.getPeersAddressFromChannel(myIdentifier, store, multisigAddress);
    }
}
exports.StateChannel = StateChannel;
//# sourceMappingURL=state-channel.js.map