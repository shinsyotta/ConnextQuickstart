"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const lib_1 = require("../lib");
class AbstractController {
    constructor(name, connext) {
        this.proposeAndInstallLedgerApp = (params) => __awaiter(this, void 0, void 0, function* () {
            const { appInstanceId } = yield this.connext.proposeInstallApp(params);
            let boundResolve;
            let boundReject;
            try {
                const res = yield Promise.race([
                    new Promise((res, rej) => {
                        boundResolve = this.resolveInstall.bind(null, res, rej, appInstanceId);
                        boundReject = this.rejectInstall.bind(null, rej, appInstanceId);
                        this.log.debug(`subscribing to indra.node.${this.connext.nodePublicIdentifier}.install.${this.connext.multisigAddress}`);
                        this.connext.messaging.subscribe(`indra.node.${this.connext.nodePublicIdentifier}.install.${appInstanceId}`, boundResolve);
                        this.listener.on(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
                    }),
                    lib_1.delayAndThrow(lib_1.CF_METHOD_TIMEOUT, `App install took longer than ${lib_1.CF_METHOD_TIMEOUT / 1000} seconds`),
                ]);
                this.log.info(`Installed app ${appInstanceId}`);
                this.log.debug(`Installed app details: ${lib_1.stringify(res)}`);
                return appInstanceId;
            }
            catch (e) {
                this.log.error(`Error installing app: ${e.stack || e.message}`);
                return appInstanceId;
            }
            finally {
                this.cleanupInstallListeners(boundReject, appInstanceId);
            }
        });
        this.proposeAndWaitForAccepted = (params) => __awaiter(this, void 0, void 0, function* () {
            let boundReject;
            let appId;
            try {
                yield Promise.race([
                    new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                        boundReject = this.rejectProposal.bind(null, rej);
                        this.log.debug(`subscribing to indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`);
                        this.connext.messaging.subscribe(`indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`, res);
                        const { appInstanceId } = yield this.connext.proposeInstallApp(params);
                        appId = appInstanceId;
                        this.log.debug(`waiting for proposal acceptance of ${appInstanceId}`);
                        this.listener.on(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
                    })),
                    lib_1.delayAndThrow(lib_1.CF_METHOD_TIMEOUT, `App proposal took longer than ${lib_1.CF_METHOD_TIMEOUT / 1000} seconds`),
                ]);
                this.log.info(`App was proposed successfully!: ${appId}`);
                return appId;
            }
            catch (e) {
                this.log.error(`Error proposing app: ${e.stack || e.message}`);
                return e.message;
            }
            finally {
                this.cleanupProposalListeners(boundReject);
            }
        });
        this.resolveInstall = (res, rej, appInstanceId, message) => {
            const appInstance = message.data.data ? message.data.data : message.data;
            if (appInstance.identityHash !== appInstanceId) {
                const msg = `Caught install event for different app ${lib_1.stringify(message)}, expected ${appInstanceId}. This should not happen.`;
                this.log.warn(msg);
                rej(msg);
            }
            res(message);
        };
        this.rejectInstall = (rej, appInstanceId, message) => {
            const data = message.data.data ? message.data.data : message.data;
            if (data.appInstanceId !== appInstanceId) {
                const msg = `Caught reject install event for different app ${lib_1.stringify(message)}, expected ${appInstanceId}. This should not happen.`;
                this.log.warn(msg);
                rej(msg);
            }
            return rej(`Install failed. Event data: ${lib_1.stringify(message)}`);
        };
        this.rejectProposal = (rej, msg) => {
            rej(`Proposal rejected, event data: ${lib_1.stringify(msg)}`);
        };
        this.cleanupInstallListeners = (boundReject, appId) => {
            this.connext.messaging.unsubscribe(`indra.node.${this.connext.nodePublicIdentifier}.install.${appId}`);
            this.listener.removeCfListener("REJECT_INSTALL_EVENT", boundReject);
        };
        this.cleanupProposalListeners = (boundReject) => {
            this.connext.messaging.unsubscribe(`indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`);
            this.listener.removeCfListener("REJECT_INSTALL_EVENT", boundReject);
        };
        this.connext = connext;
        this.name = name;
        this.node = connext.node;
        this.channelProvider = connext.channelProvider;
        this.listener = connext.listener;
        this.log = new lib_1.Logger(name, connext.log.logLevel);
        this.ethProvider = connext.ethProvider;
    }
}
exports.AbstractController = AbstractController;
//# sourceMappingURL=AbstractController.js.map