"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const hdnode_1 = require("ethers/utils/hdnode");
const ethereum_1 = require("../ethereum");
const enums_1 = require("../machine/enums");
const xkeys_1 = require("../machine/xkeys");
const get_outcome_increments_1 = require("./utils/get-outcome-increments");
const signature_forwarder_1 = require("./utils/signature-forwarder");
const signature_validator_1 = require("./utils/signature-validator");
const store_1 = require("../store");
function xkeyTo0thAddress(xpub) {
    return hdnode_1.fromExtendedKey(xpub).derivePath("0").address;
}
const { OP_SIGN, IO_SEND_AND_WAIT, IO_SEND, PERSIST_STATE_CHANNEL } = enums_1.Opcode;
exports.UNINSTALL_VIRTUAL_APP_PROTOCOL = {
    0: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { message: { processID, params }, provider, stateChannelsMap, network, } = context;
            const { intermediaryXpub, responderXpub } = params;
            const intermediaryAddress = xkeys_1.xkeyKthAddress(intermediaryXpub, 0);
            const responderAddress = xkeys_1.xkeyKthAddress(responderXpub, 0);
            const [stateChannelWithAllThreeParties, stateChannelWithIntermediary, stateChannelWithResponding, timeLockedPassThroughAppInstance] = yield __await(getUpdatedStateChannelAndAppInstanceObjectsForInitiating(stateChannelsMap, params, provider, network));
            const timeLockedPassThroughSetStateCommitment = new ethereum_1.SetStateCommitment(network, timeLockedPassThroughAppInstance.identity, timeLockedPassThroughAppInstance.hashOfLatestState, timeLockedPassThroughAppInstance.appSeqNo, timeLockedPassThroughAppInstance.defaultTimeout);
            const initiatingSignatureOnTimeLockedPassThroughSetStateCommitment = yield yield __await([
                OP_SIGN,
                timeLockedPassThroughSetStateCommitment
            ]);
            const m1 = {
                params,
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: 1,
                toXpub: intermediaryXpub,
                customData: {
                    signature: initiatingSignatureOnTimeLockedPassThroughSetStateCommitment
                }
            };
            const m4 = (yield yield __await([IO_SEND_AND_WAIT, m1]));
            const { customData: { signature: responderSignatureOnTimeLockedPassThroughSetStateCommitment, signature2: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment } } = m4;
            signature_validator_1.assertIsValidSignature(responderAddress, timeLockedPassThroughSetStateCommitment, responderSignatureOnTimeLockedPassThroughSetStateCommitment);
            signature_validator_1.assertIsValidSignature(intermediaryAddress, timeLockedPassThroughSetStateCommitment, intermediarySignatureOnTimeLockedPassThroughSetStateCommitment);
            const aliceIngridAppDisactivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithIntermediary.freeBalance.identity, stateChannelWithIntermediary.freeBalance.hashOfLatestState, stateChannelWithIntermediary.freeBalance.versionNumber, stateChannelWithIntermediary.freeBalance.timeout);
            const initiatingSignatureOnAliceIngridAppDisactivationCommitment = yield yield __await([
                OP_SIGN,
                aliceIngridAppDisactivationCommitment
            ]);
            const m5 = {
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: intermediaryXpub,
                customData: {
                    signature: initiatingSignatureOnAliceIngridAppDisactivationCommitment
                }
            };
            const m8 = (yield yield __await([IO_SEND_AND_WAIT, m5]));
            const { customData: { signature: intermediarySignatureOnAliceIngridAppDisactivationCommitment } } = m8;
            signature_validator_1.assertIsValidSignature(intermediaryAddress, aliceIngridAppDisactivationCommitment, intermediarySignatureOnAliceIngridAppDisactivationCommitment);
            yield yield __await([
                PERSIST_STATE_CHANNEL,
                [
                    stateChannelWithIntermediary,
                    stateChannelWithAllThreeParties,
                    stateChannelWithResponding
                ]
            ]);
            context.stateChannelsMap.set(stateChannelWithIntermediary.multisigAddress, stateChannelWithIntermediary);
            context.stateChannelsMap.set(stateChannelWithAllThreeParties.multisigAddress, stateChannelWithAllThreeParties);
            context.stateChannelsMap.set(stateChannelWithResponding.multisigAddress, stateChannelWithResponding);
        });
    },
    1: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { message: { processID, params, customData: { signature: initiatingSignatureOnTimeLockedPassThroughSetStateCommitment } }, provider, stateChannelsMap, network, } = context;
            const { initiatorXpub, responderXpub } = params;
            const initiatorAddress = xkeys_1.xkeyKthAddress(initiatorXpub, 0);
            const responderAddress = xkeys_1.xkeyKthAddress(responderXpub, 0);
            const [stateChannelWithAllThreeParties, stateChannelWithInitiating, stateChannelWithResponding, timeLockedPassThroughAppInstance] = yield __await(getUpdatedStateChannelAndAppInstanceObjectsForIntermediary(stateChannelsMap, params, provider, network));
            const timeLockedPassThroughSetStateCommitment = new ethereum_1.SetStateCommitment(network, timeLockedPassThroughAppInstance.identity, timeLockedPassThroughAppInstance.hashOfLatestState, timeLockedPassThroughAppInstance.appSeqNo, timeLockedPassThroughAppInstance.defaultTimeout);
            signature_validator_1.assertIsValidSignature(initiatorAddress, timeLockedPassThroughSetStateCommitment, initiatingSignatureOnTimeLockedPassThroughSetStateCommitment);
            const intermediarySignatureOnTimeLockedPassThroughSetStateCommitment = yield yield __await([
                OP_SIGN,
                timeLockedPassThroughSetStateCommitment
            ]);
            const m2 = {
                processID,
                params,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: 2,
                toXpub: responderXpub,
                customData: {
                    signature: initiatingSignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature2: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment
                }
            };
            const m3 = (yield yield __await([IO_SEND_AND_WAIT, m2]));
            const { customData: { signature: respondingSignatureOnTimeLockedPassThroughSetStateCommitment } } = m3;
            signature_validator_1.assertIsValidSignature(responderAddress, timeLockedPassThroughSetStateCommitment, respondingSignatureOnTimeLockedPassThroughSetStateCommitment);
            const m4 = {
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: initiatorXpub,
                customData: {
                    signature: respondingSignatureOnTimeLockedPassThroughSetStateCommitment,
                    signature2: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment
                }
            };
            const m5 = (yield yield __await([IO_SEND_AND_WAIT, m4]));
            const { customData: { signature: initiatingSignatureOnAliceIngridAppDisactivationCommitment } } = m5;
            const aliceIngridAppDisactivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithInitiating.freeBalance.identity, stateChannelWithInitiating.freeBalance.hashOfLatestState, stateChannelWithInitiating.freeBalance.versionNumber, stateChannelWithInitiating.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(initiatorAddress, aliceIngridAppDisactivationCommitment, initiatingSignatureOnAliceIngridAppDisactivationCommitment);
            const intermediarySignatureOnAliceIngridAppDisactivationCommitment = yield yield __await([
                OP_SIGN,
                aliceIngridAppDisactivationCommitment
            ]);
            const ingridBobAppDisactivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithResponding.freeBalance.identity, stateChannelWithResponding.freeBalance.hashOfLatestState, stateChannelWithResponding.freeBalance.versionNumber, stateChannelWithResponding.freeBalance.timeout);
            const intermediarySignatureOnIngridBobAppDisactivationCommitment = yield yield __await([
                OP_SIGN,
                ingridBobAppDisactivationCommitment
            ]);
            const m6 = {
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: responderXpub,
                customData: {
                    signature: intermediarySignatureOnIngridBobAppDisactivationCommitment
                }
            };
            const m7 = (yield yield __await([IO_SEND_AND_WAIT, m6]));
            const { customData: { signature: respondingSignatureOnIngridBobAppDisactivationCommitment } } = m7;
            signature_validator_1.assertIsValidSignature(responderAddress, ingridBobAppDisactivationCommitment, respondingSignatureOnIngridBobAppDisactivationCommitment);
            context.stateChannelsMap.set(stateChannelWithInitiating.multisigAddress, stateChannelWithInitiating);
            context.stateChannelsMap.set(stateChannelWithAllThreeParties.multisigAddress, stateChannelWithAllThreeParties);
            context.stateChannelsMap.set(stateChannelWithResponding.multisigAddress, stateChannelWithResponding);
            yield yield __await([
                PERSIST_STATE_CHANNEL,
                [
                    stateChannelWithInitiating,
                    stateChannelWithAllThreeParties,
                    stateChannelWithResponding
                ]
            ]);
            const m8 = {
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: initiatorXpub,
                customData: {
                    signature: intermediarySignatureOnAliceIngridAppDisactivationCommitment
                }
            };
            yield yield __await([IO_SEND, m8]);
        });
    },
    2: function (context) {
        return __asyncGenerator(this, arguments, function* () {
            const { message: { processID, params, customData: { signature: initiatingSignatureOnTimeLockedPassThroughSetStateCommitment, signature2: intermediarySignatureOnTimeLockedPassThroughSetStateCommitment } }, provider, stateChannelsMap, network, } = context;
            const { initiatorXpub, intermediaryXpub } = params;
            const initiatorAddress = xkeys_1.xkeyKthAddress(initiatorXpub, 0);
            const intermediaryAddress = xkeys_1.xkeyKthAddress(intermediaryXpub, 0);
            const [stateChannelWithAllThreeParties, stateChannelWithIntermediary, stateChannelWithInitiating, timeLockedPassThroughAppInstance] = yield __await(getUpdatedStateChannelAndAppInstanceObjectsForResponding(stateChannelsMap, params, provider, network));
            const timeLockedPassThroughSetStateCommitment = new ethereum_1.SetStateCommitment(network, timeLockedPassThroughAppInstance.identity, timeLockedPassThroughAppInstance.hashOfLatestState, timeLockedPassThroughAppInstance.appSeqNo, timeLockedPassThroughAppInstance.defaultTimeout);
            signature_validator_1.assertIsValidSignature(initiatorAddress, timeLockedPassThroughSetStateCommitment, initiatingSignatureOnTimeLockedPassThroughSetStateCommitment);
            signature_validator_1.assertIsValidSignature(intermediaryAddress, timeLockedPassThroughSetStateCommitment, intermediarySignatureOnTimeLockedPassThroughSetStateCommitment);
            const respondingSignatureOnTimeLockedPassThroughSetStateCommitment = yield yield __await([
                OP_SIGN,
                timeLockedPassThroughSetStateCommitment
            ]);
            const m3 = {
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: intermediaryXpub,
                customData: {
                    signature: respondingSignatureOnTimeLockedPassThroughSetStateCommitment
                }
            };
            const m6 = (yield yield __await([IO_SEND_AND_WAIT, m3]));
            const { customData: { signature: intermediarySignatureOnIngridBobAppDisactivationCommitment } } = m6;
            const ingridBobAppDisactivationCommitment = new ethereum_1.SetStateCommitment(network, stateChannelWithIntermediary.freeBalance.identity, stateChannelWithIntermediary.freeBalance.hashOfLatestState, stateChannelWithIntermediary.freeBalance.versionNumber, stateChannelWithIntermediary.freeBalance.timeout);
            signature_validator_1.assertIsValidSignature(intermediaryAddress, ingridBobAppDisactivationCommitment, intermediarySignatureOnIngridBobAppDisactivationCommitment);
            const respondingSignatureOnIngridBobAppDisactivationCommitment = yield yield __await([
                OP_SIGN,
                ingridBobAppDisactivationCommitment
            ]);
            yield yield __await([
                PERSIST_STATE_CHANNEL,
                [
                    stateChannelWithInitiating,
                    stateChannelWithAllThreeParties,
                    stateChannelWithIntermediary
                ]
            ]);
            const m7 = {
                processID,
                protocol: enums_1.Protocol.UninstallVirtualApp,
                seq: signature_forwarder_1.UNASSIGNED_SEQ_NO,
                toXpub: intermediaryXpub,
                customData: {
                    signature: respondingSignatureOnIngridBobAppDisactivationCommitment
                }
            };
            yield yield __await([IO_SEND, m7]);
            context.stateChannelsMap.set(stateChannelWithIntermediary.multisigAddress, stateChannelWithIntermediary);
            context.stateChannelsMap.set(stateChannelWithAllThreeParties.multisigAddress, stateChannelWithAllThreeParties);
            context.stateChannelsMap.set(stateChannelWithInitiating.multisigAddress, stateChannelWithInitiating);
        });
    }
};
async function getStateChannelFromMapWithOwners(stateChannelsMap, userXpubs, network) {
    const multisigAddress = await store_1.Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, userXpubs, network.ProxyFactory, network.MinimumViableMultisig, network.provider);
    return stateChannelsMap.get(multisigAddress);
}
async function getUpdatedStateChannelAndAppInstanceObjectsForInitiating(stateChannelsMap, params, provider, network) {
    const { intermediaryXpub, responderXpub, initiatorXpub, targetAppIdentityHash, targetOutcome } = params;
    const initiatorAddress = xkeyTo0thAddress(initiatorXpub);
    const intermediaryAddress = xkeyTo0thAddress(intermediaryXpub);
    const responderAddress = xkeyTo0thAddress(responderXpub);
    const [stateChannelWithAllThreeParties, stateChannelWithIntermediary, stateChannelWithResponding] = [
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, responderXpub, intermediaryXpub], network),
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, intermediaryXpub], network),
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, responderXpub], network)
    ];
    const agreement = stateChannelWithIntermediary.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(targetAppIdentityHash);
    const { tokenAddress } = agreement;
    const timeLockedPassThroughAppInstance = stateChannelWithAllThreeParties.getAppInstance(agreement.timeLockedPassThroughIdentityHash);
    const virtualAppInstance = stateChannelWithResponding.getAppInstance(timeLockedPassThroughAppInstance.state["targetAppIdentityHash"]);
    const virtualAppHasExpired = timeLockedPassThroughAppInstance.state["switchesOutcomeAt"].lte(await provider.getBlockNumber());
    const tokenIndexedIncrements = await get_outcome_increments_1.computeTokenIndexedFreeBalanceIncrements(virtualAppHasExpired
        ? timeLockedPassThroughAppInstance
        : virtualAppInstance, provider);
    return [
        stateChannelWithAllThreeParties.removeAppInstance(timeLockedPassThroughAppInstance.identityHash),
        stateChannelWithIntermediary.removeSingleAssetTwoPartyIntermediaryAgreement(virtualAppInstance.identityHash, {
            [intermediaryAddress]: tokenIndexedIncrements[tokenAddress][responderAddress],
            [initiatorAddress]: tokenIndexedIncrements[tokenAddress][initiatorAddress]
        }, tokenAddress),
        stateChannelWithResponding.removeAppInstance(virtualAppInstance.identityHash),
        timeLockedPassThroughAppInstance.setState(Object.assign({}, timeLockedPassThroughAppInstance.state, { switchesOutcomeAt: 0, defaultOutcome: targetOutcome }))
    ];
}
async function getUpdatedStateChannelAndAppInstanceObjectsForResponding(stateChannelsMap, params, provider, network) {
    const { intermediaryXpub, responderXpub, initiatorXpub, targetAppIdentityHash, targetOutcome } = params;
    const initiatorAddress = xkeyTo0thAddress(initiatorXpub);
    const intermediaryAddress = xkeyTo0thAddress(intermediaryXpub);
    const responderAddress = xkeyTo0thAddress(responderXpub);
    const [stateChannelWithAllThreeParties, stateChannelWithIntermediary, stateChannelWithInitiating] = [
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, responderXpub, intermediaryXpub], network),
        await getStateChannelFromMapWithOwners(stateChannelsMap, [responderXpub, intermediaryXpub], network),
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, responderXpub], network)
    ];
    const agreement = stateChannelWithIntermediary.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(targetAppIdentityHash);
    const { tokenAddress } = agreement;
    const timeLockedPassThroughAppInstance = stateChannelWithAllThreeParties.getAppInstance(agreement.timeLockedPassThroughIdentityHash);
    const virtualAppInstance = stateChannelWithInitiating.getAppInstance(timeLockedPassThroughAppInstance.state["targetAppIdentityHash"]);
    const expectedOutcome = await virtualAppInstance.computeOutcomeWithCurrentState(provider);
    if (expectedOutcome !== targetOutcome) {
        throw Error("UninstallVirtualApp Protocol: Received targetOutcome that did not match expected outcome based on latest state of Virtual App.");
    }
    const virtualAppHasExpired = timeLockedPassThroughAppInstance.state["switchesOutcomeAt"].lte(await provider.getBlockNumber());
    const tokenIndexedIncrements = await get_outcome_increments_1.computeTokenIndexedFreeBalanceIncrements(virtualAppHasExpired
        ? timeLockedPassThroughAppInstance
        : virtualAppInstance, provider);
    return [
        stateChannelWithAllThreeParties.removeAppInstance(timeLockedPassThroughAppInstance.identityHash),
        stateChannelWithIntermediary.removeSingleAssetTwoPartyIntermediaryAgreement(virtualAppInstance.identityHash, {
            [intermediaryAddress]: tokenIndexedIncrements[tokenAddress][initiatorAddress],
            [responderAddress]: tokenIndexedIncrements[tokenAddress][responderAddress]
        }, tokenAddress),
        stateChannelWithInitiating.removeAppInstance(virtualAppInstance.identityHash),
        timeLockedPassThroughAppInstance.setState(Object.assign({}, timeLockedPassThroughAppInstance.state, { switchesOutcomeAt: 0, defaultOutcome: expectedOutcome }))
    ];
}
async function getUpdatedStateChannelAndAppInstanceObjectsForIntermediary(stateChannelsMap, params, provider, network) {
    const { intermediaryXpub, responderXpub, initiatorXpub, targetAppIdentityHash, targetOutcome } = params;
    const initiatorAddress = xkeyTo0thAddress(initiatorXpub);
    const intermediaryAddress = xkeyTo0thAddress(intermediaryXpub);
    const responderAddress = xkeyTo0thAddress(responderXpub);
    const [stateChannelWithAllThreeParties, stateChannelWithInitiating, stateChannelWithResponding] = [
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, responderXpub, intermediaryXpub], network),
        await getStateChannelFromMapWithOwners(stateChannelsMap, [initiatorXpub, intermediaryXpub], network),
        await getStateChannelFromMapWithOwners(stateChannelsMap, [intermediaryXpub, responderXpub], network)
    ];
    const agreementWithInitiating = stateChannelWithInitiating.getSingleAssetTwoPartyIntermediaryAgreementFromVirtualApp(targetAppIdentityHash);
    const { tokenAddress } = agreementWithInitiating;
    const timeLockedPassThroughAppInstance = stateChannelWithAllThreeParties.getAppInstance(agreementWithInitiating.timeLockedPassThroughIdentityHash);
    const virtualAppHasExpired = timeLockedPassThroughAppInstance.state["switchesOutcomeAt"].lte(await provider.getBlockNumber());
    const tokenIndexedIncrements = await get_outcome_increments_1.computeTokenIndexedFreeBalanceIncrements(timeLockedPassThroughAppInstance, provider, virtualAppHasExpired
        ? timeLockedPassThroughAppInstance.state["defaultOutcome"]
        : targetOutcome);
    return [
        stateChannelWithAllThreeParties.removeAppInstance(timeLockedPassThroughAppInstance.identityHash),
        stateChannelWithInitiating.removeSingleAssetTwoPartyIntermediaryAgreement(timeLockedPassThroughAppInstance.state["targetAppIdentityHash"], {
            [intermediaryAddress]: tokenIndexedIncrements[tokenAddress][responderAddress],
            [initiatorAddress]: tokenIndexedIncrements[tokenAddress][initiatorAddress]
        }, tokenAddress),
        stateChannelWithResponding.removeSingleAssetTwoPartyIntermediaryAgreement(timeLockedPassThroughAppInstance.state["targetAppIdentityHash"], {
            [intermediaryAddress]: tokenIndexedIncrements[tokenAddress][initiatorAddress],
            [responderAddress]: tokenIndexedIncrements[tokenAddress][responderAddress]
        }, tokenAddress),
        timeLockedPassThroughAppInstance.setState(Object.assign({}, timeLockedPassThroughAppInstance.state, { switchesOutcomeAt: 0, defaultOutcome: targetOutcome }))
    ];
}
//# sourceMappingURL=uninstall-virtual-app.js.map