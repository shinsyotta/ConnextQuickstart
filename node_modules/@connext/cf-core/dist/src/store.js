"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const db_schema_1 = require("./db-schema");
const errors_1 = require("./methods/errors");
const models_1 = require("./models");
const utils_2 = require("./utils");
class Store {
    constructor(storeService, storeKeyPrefix) {
        this.storeService = storeService;
        this.storeKeyPrefix = storeKeyPrefix;
    }
    static async getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, owners, proxyFactoryAddress, minimumViableMultisigAddress, provider) {
        for (const stateChannel of stateChannelsMap.values()) {
            if (stateChannel.userNeuteredExtendedKeys.sort().toString() ===
                owners.sort().toString()) {
                return stateChannel.multisigAddress;
            }
        }
        if (provider) {
            return await utils_2.getCreate2MultisigAddress(owners, proxyFactoryAddress, minimumViableMultisigAddress, provider);
        }
        throw new Error(errors_1.NO_MULTISIG_FOR_COUNTERPARTIES(owners));
    }
    async getMultisigAddressWithCounterparty(owners, proxyFactoryAddress, minimumViableMultisigAddress, provider) {
        const stateChannelsMap = await this.getStateChannelsMap();
        return await Store.getMultisigAddressWithCounterpartyFromMap(stateChannelsMap, owners, proxyFactoryAddress, minimumViableMultisigAddress, provider);
    }
    async getStateChannelsMap() {
        const channelsJSON = ((await this.storeService.get(`${this.storeKeyPrefix}/${db_schema_1.DB_NAMESPACE_CHANNEL}`)) || {});
        return new Map(Object.values(channelsJSON)
            .map(models_1.StateChannel.fromJson)
            .map(sc => [sc.multisigAddress, sc]));
    }
    async getStateChannel(multisigAddress) {
        const stateChannelJson = await this.storeService.get(`${this.storeKeyPrefix}/${db_schema_1.DB_NAMESPACE_CHANNEL}/${multisigAddress}`);
        if (!stateChannelJson) {
            throw Error(errors_1.NO_STATE_CHANNEL_FOR_MULTISIG_ADDR(multisigAddress));
        }
        const channel = models_1.StateChannel.fromJson(stateChannelJson);
        return channel;
    }
    async hasStateChannel(multisigAddress) {
        return !!(await this.storeService.get(`${this.storeKeyPrefix}/${db_schema_1.DB_NAMESPACE_CHANNEL}/${multisigAddress}`));
    }
    async getMultisigAddressFromAppInstance(appInstanceId) {
        for (const sc of (await this.getStateChannelsMap()).values()) {
            if (sc.proposedAppInstances.has(appInstanceId) ||
                sc.appInstances.has(appInstanceId) ||
                (sc.hasFreeBalance && sc.freeBalance.identityHash === appInstanceId)) {
                return sc.multisigAddress;
            }
        }
        throw new Error(errors_1.NO_MULTISIG_FOR_APP_INSTANCE_ID);
    }
    async saveStateChannel(stateChannel) {
        await this.storeService.set([
            {
                path: `${this.storeKeyPrefix}/${db_schema_1.DB_NAMESPACE_CHANNEL}/${stateChannel.multisigAddress}`,
                value: stateChannel.toJson()
            }
        ]);
    }
    async saveAppInstanceState(appInstanceId, newState) {
        const channel = await this.getChannelFromAppInstanceID(appInstanceId);
        const updatedChannel = await channel.setState(appInstanceId, newState);
        await this.saveStateChannel(updatedChannel);
    }
    async getProposedAppInstances(multisigAddress) {
        const chanArray = multisigAddress
            ? [await this.getStateChannel(multisigAddress)]
            : [...(await this.getStateChannelsMap()).values()];
        return chanArray.reduce((lst, sc) => [...lst, ...sc.proposedAppInstances.values()], []);
    }
    async getAppInstances(multisigAddress) {
        const chanArray = multisigAddress
            ? [await this.getStateChannel(multisigAddress)]
            : [...(await this.getStateChannelsMap()).values()];
        return chanArray.reduce((acc, channel) => {
            acc.push(...Array.from(channel.appInstances.values()).map(appInstance => appInstance.toJson()));
            return acc;
        }, []);
    }
    async getAppInstanceProposal(appInstanceId) {
        const multisigAddress = await this.getMultisigAddressFromAppInstance(appInstanceId);
        if (!multisigAddress) {
            throw new Error(errors_1.NO_PROPOSED_APP_INSTANCE_FOR_APP_INSTANCE_ID(appInstanceId));
        }
        const stateChannel = await this.getStateChannel(multisigAddress);
        if (!stateChannel.proposedAppInstances.has(appInstanceId)) {
            throw new Error(errors_1.NO_PROPOSED_APP_INSTANCE_FOR_APP_INSTANCE_ID(appInstanceId));
        }
        return stateChannel.proposedAppInstances.get(appInstanceId);
    }
    async getChannelFromAppInstanceID(appInstanceId) {
        return await this.getStateChannel(await this.getMultisigAddressFromAppInstance(appInstanceId));
    }
    async getWithdrawalCommitment(multisigAddress) {
        return this.storeService.get([this.storeKeyPrefix, db_schema_1.DB_NAMESPACE_WITHDRAWALS, multisigAddress].join("/"));
    }
    async storeWithdrawalCommitment(multisigAddress, commitment) {
        return this.storeService.set([
            {
                path: [
                    this.storeKeyPrefix,
                    db_schema_1.DB_NAMESPACE_WITHDRAWALS,
                    multisigAddress
                ].join("/"),
                value: commitment
            }
        ]);
    }
    async setCommitment(args, commitment) {
        return this.storeService.set([
            {
                path: [
                    this.storeKeyPrefix,
                    db_schema_1.DB_NAMESPACE_ALL_COMMITMENTS,
                    utils_1.solidityKeccak256(["address", "uint256", "bytes"], [commitment.to, commitment.value, commitment.data])
                ].join("/"),
                value: args.concat([commitment])
            }
        ]);
    }
    async getAppInstance(appInstanceId) {
        const channel = await this.getChannelFromAppInstanceID(appInstanceId);
        return channel.getAppInstance(appInstanceId);
    }
    async getOrCreateStateChannelBetweenVirtualAppParticipants(multisigAddress, proxyFactoryAddress, initiatorXpub, responderXpub) {
        try {
            return await this.getStateChannel(multisigAddress);
        }
        catch (e) {
            if (e
                .toString()
                .includes(errors_1.NO_STATE_CHANNEL_FOR_MULTISIG_ADDR(multisigAddress))) {
                const stateChannel = models_1.StateChannel.createEmptyChannel(multisigAddress, proxyFactoryAddress, [initiatorXpub, responderXpub]);
                await this.saveStateChannel(stateChannel);
                return stateChannel;
            }
            throw Error(e);
        }
    }
}
exports.Store = Store;
//# sourceMappingURL=store.js.map