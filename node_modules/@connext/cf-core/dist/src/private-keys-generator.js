"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/utils");
const hdnode_1 = require("ethers/utils/hdnode");
const loglevel_1 = __importDefault(require("loglevel"));
const typescript_memoize_1 = require("typescript-memoize");
const constants_1 = require("./constants");
exports.EXTENDED_PRIVATE_KEY_PATH = "EXTENDED_PRIVATE_KEY";
class PrivateKeysGetter {
    constructor(privateKeyGenerator) {
        this.privateKeyGenerator = privateKeyGenerator;
        this.appInstanceIdentityHashToPrivateKey = new Map();
        this.privateKeys = new Set();
    }
    async getPrivateKey(appInstanceIdentityHash) {
        const validHDPathRepresentationOfIdentityHash = convertDecimalStringToValidHDPath(new utils_1.BigNumber(appInstanceIdentityHash).toString());
        if (this.appInstanceIdentityHashToPrivateKey.has(validHDPathRepresentationOfIdentityHash)) {
            return await this.appInstanceIdentityHashToPrivateKey.get(validHDPathRepresentationOfIdentityHash);
        }
        const privateKey = await this.privateKeyGenerator(validHDPathRepresentationOfIdentityHash);
        try {
            new ethers_1.Wallet(privateKey);
        }
        catch (e) {
            throw new Error(`
        Invalid private key retrieved from wallet-provided
        callback given AppInstance ID ${appInstanceIdentityHash}: ${JSON.stringify(e, null, 4)}
      `);
        }
        if (this.privateKeys.has(privateKey)) {
            throw new Error(`Wallet-provided callback function returned a colliding private key for two different AppInstance IDs`);
        }
        this.appInstanceIdentityHashToPrivateKey = this.appInstanceIdentityHashToPrivateKey.set(validHDPathRepresentationOfIdentityHash, privateKey);
        this.privateKeys.add(privateKey);
        return privateKey;
    }
}
__decorate([
    typescript_memoize_1.Memoize(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PrivateKeysGetter.prototype, "getPrivateKey", null);
exports.PrivateKeysGetter = PrivateKeysGetter;
async function getPrivateKeysGeneratorAndXPubOrThrow(storeService, privateKeyGenerator, publicExtendedKey) {
    if (publicExtendedKey && !privateKeyGenerator) {
        throw new Error("Cannot provide an extended public key but not provide a private key generation function");
    }
    if (!publicExtendedKey && privateKeyGenerator) {
        throw new Error("Cannot provide a private key generation function but not provide an extended public key");
    }
    if (publicExtendedKey && privateKeyGenerator) {
        return Promise.resolve([
            new PrivateKeysGetter(privateKeyGenerator),
            publicExtendedKey
        ]);
    }
    let extendedPrvKey = await storeService.get(exports.EXTENDED_PRIVATE_KEY_PATH);
    if (!extendedPrvKey) {
        loglevel_1.default.info("No (extended public key, private key generation function) pair was provided and no extended private key was found in store. Generating a random extended private key");
        extendedPrvKey = hdnode_1.fromMnemonic(ethers_1.Wallet.createRandom().mnemonic).extendedKey;
        await storeService.set([
            { path: exports.EXTENDED_PRIVATE_KEY_PATH, value: extendedPrvKey }
        ]);
    }
    else {
        loglevel_1.default.info("Using extended private key found in the store.");
    }
    const [privKeyGenerator, extendedPubKey] = generatePrivateKeyGeneratorAndXPubPair(extendedPrvKey);
    return Promise.resolve([
        new PrivateKeysGetter(privKeyGenerator),
        extendedPubKey
    ]);
}
exports.getPrivateKeysGeneratorAndXPubOrThrow = getPrivateKeysGeneratorAndXPubOrThrow;
function generatePrivateKeyGeneratorAndXPubPair(extendedPrvKey) {
    const hdNode = hdnode_1.fromExtendedKey(extendedPrvKey).derivePath(constants_1.CF_PATH);
    return [
        function (uniqueID) {
            return Promise.resolve(hdNode.derivePath(uniqueID).privateKey);
        },
        hdNode.neuter().extendedKey
    ];
}
exports.generatePrivateKeyGeneratorAndXPubPair = generatePrivateKeyGeneratorAndXPubPair;
function convertDecimalStringToValidHDPath(numbers) {
    const components = numbers.split("").reduce((componentAccumulator, number, index) => {
        if (index === 0) {
            return componentAccumulator;
        }
        if (index % 10 === 0) {
            componentAccumulator.push([number]);
        }
        else {
            componentAccumulator[componentAccumulator.length - 1].push(number);
        }
        return componentAccumulator;
    }, [[numbers[0]]]);
    return components.map((component) => component.join("")).join("/");
}
//# sourceMappingURL=private-keys-generator.js.map