"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rpc_server_1 = require("rpc-server");
const utils_1 = require("./utils");
class RpcRouter extends rpc_server_1.Router {
    constructor({ controllers, requestHandler }) {
        super({ controllers });
        this.requestHandler = requestHandler;
    }
    async dispatch(rpc) {
        const controller = Object.values(rpc_server_1.Controller.rpcMethods).find(mapping => mapping.method === rpc.methodName);
        if (!controller) {
            throw Error(`Cannot execute ${rpc.methodName}: no controller`);
        }
        const result = rpc_server_1.jsonRpcSerializeAsResponse({
            result: await new controller.type()[controller.callback](this.requestHandler, utils_1.bigNumberifyJson(rpc.parameters)),
            type: rpc.methodName
        }, rpc.id);
        this.requestHandler.outgoing.emit(rpc.methodName, result);
        return result;
    }
    async subscribe(event, callback) {
        this.requestHandler.outgoing.on(event, callback);
    }
    async subscribeOnce(event, callback) {
        this.requestHandler.outgoing.once(event, callback);
    }
    async unsubscribe(event, callback) {
        this.requestHandler.outgoing.off(event, callback);
    }
    async emit(event, data, emitter = "incoming") {
        let eventData = data;
        if (!eventData["jsonrpc"]) {
            eventData = rpc_server_1.jsonRpcSerializeAsResponse(eventData, Date.now());
        }
        this.requestHandler[emitter].emit(event, eventData.result);
    }
    eventListenerCount(event) {
        return typeof this.requestHandler.outgoing.listenerCount === "function"
            ? this.requestHandler.outgoing.listenerCount(event)
            : 0;
    }
}
exports.default = RpcRouter;
//# sourceMappingURL=rpc-router.js.map