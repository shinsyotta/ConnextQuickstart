"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const setup_1 = require("./setup");
const utils_1 = require("./utils");
const { TicTacToeApp } = global["networkContext"];
describe("Node method follows spec - rejectInstall", () => {
    let nodeA;
    let nodeB;
    beforeEach(async () => {
        const context = await setup_1.setup(global);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
    });
    describe("Rejects proposal with non-null initial state", () => {
        it("Node A installs, node b rejects", async (done) => {
            const multisigAddress = await utils_1.createChannel(nodeA, nodeB);
            await utils_1.collateralizeChannel(multisigAddress, nodeA, nodeB);
            expect(await utils_1.getInstalledAppInstances(nodeA)).toEqual([]);
            expect(await utils_1.getInstalledAppInstances(nodeB)).toEqual([]);
            let proposedAppId;
            nodeA.on("REJECT_INSTALL_EVENT", async (msg) => {
                utils_1.assertNodeMessage(msg, {
                    from: nodeB.publicIdentifier,
                    type: "REJECT_INSTALL_EVENT",
                    data: {
                        appInstanceId: proposedAppId
                    }
                });
                expect((await utils_1.getProposedAppInstances(nodeA)).length).toEqual(0);
                expect((await utils_1.getProposedAppInstances(nodeB)).length).toEqual(0);
                done();
            });
            nodeB.on("PROPOSE_INSTALL_EVENT", async (msg) => {
                const rejectReq = utils_1.constructRejectInstallRpc(msg.data.appInstanceId);
                expect((await utils_1.getProposedAppInstances(nodeA)).length).toEqual(1);
                expect((await utils_1.getProposedAppInstances(nodeB)).length).toEqual(1);
                proposedAppId = msg.data.appInstanceId;
                await nodeB.rpcRouter.dispatch(rejectReq);
            });
            const { params, appInstanceId } = await utils_1.makeAndSendProposeCall(nodeA, nodeB, TicTacToeApp);
            await utils_1.confirmProposedAppInstance(params, await utils_1.getAppInstanceProposal(nodeA, appInstanceId));
        });
        it("Node A installs, node a rejects", async (done) => {
            const multisigAddress = await utils_1.createChannel(nodeA, nodeB);
            await utils_1.collateralizeChannel(multisigAddress, nodeA, nodeB);
            expect(await utils_1.getInstalledAppInstances(nodeA)).toEqual([]);
            expect(await utils_1.getInstalledAppInstances(nodeB)).toEqual([]);
            let proposedAppId;
            nodeB.on("REJECT_INSTALL_EVENT", async (msg) => {
                utils_1.assertNodeMessage(msg, {
                    from: nodeA.publicIdentifier,
                    type: "REJECT_INSTALL_EVENT",
                    data: {
                        appInstanceId: proposedAppId
                    }
                });
                expect((await utils_1.getProposedAppInstances(nodeA)).length).toEqual(0);
                expect((await utils_1.getProposedAppInstances(nodeB)).length).toEqual(0);
                done();
            });
            nodeB.on("PROPOSE_INSTALL_EVENT", async (msg) => {
                const rejectReq = utils_1.constructRejectInstallRpc(msg.data.appInstanceId);
                expect((await utils_1.getProposedAppInstances(nodeA)).length).toEqual(1);
                expect((await utils_1.getProposedAppInstances(nodeB)).length).toEqual(1);
                proposedAppId = msg.data.appInstanceId;
                await nodeA.rpcRouter.dispatch(rejectReq);
            });
            const { params, appInstanceId } = await utils_1.makeAndSendProposeCall(nodeA, nodeB, TicTacToeApp);
            await utils_1.confirmProposedAppInstance(params, await utils_1.getAppInstanceProposal(nodeA, appInstanceId));
        });
    });
});
//# sourceMappingURL=reject-install.spec.js.map