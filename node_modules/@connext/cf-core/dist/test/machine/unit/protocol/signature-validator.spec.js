"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const signature_validator_1 = require("../../../../src/protocol/utils/signature-validator");
describe("Signature Validator Helper", () => {
    let signer;
    let signature;
    let commitment;
    beforeEach(() => {
        signer = new utils_1.SigningKey(utils_1.hexlify(utils_1.randomBytes(32)));
        commitment = {
            hashToSign: () => constants_1.HashZero
        };
        signature = signer.signDigest(commitment.hashToSign());
    });
    it("validates signatures correctly", () => {
        expect(() => signature_validator_1.assertIsValidSignature(signer.address, commitment, signature)).not.toThrow();
    });
    it("throws if signature is undefined", () => {
        expect(() => signature_validator_1.assertIsValidSignature(signer.address, commitment, undefined)).toThrow("assertIsValidSignature received an undefined signature");
    });
    it("throws if commitment is undefined", () => {
        expect(() => signature_validator_1.assertIsValidSignature(signer.address, undefined, signature)).toThrow("assertIsValidSignature received an undefined commitment");
    });
    it("throws if the signature is wrong", () => {
        const rightHash = commitment.hashToSign();
        const wrongHash = constants_1.HashZero.replace("00", "11");
        const signature = signer.signDigest(wrongHash);
        const wrongSigner = utils_1.recoverAddress(rightHash, signature);
        expect(() => signature_validator_1.assertIsValidSignature(signer.address, commitment, signature)).toThrow(`Validating a signature with expected signer ${signer.address} but recovered ${wrongSigner} for commitment hash ${rightHash}`);
    });
});
//# sourceMappingURL=signature-validator.spec.js.map