"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/utils");
const constants_1 = require("./constants");
const contracts_1 = require("./contracts");
const xkeys_1 = require("./machine/xkeys");
function getFirstElementInListNotEqualTo(test, list) {
    return list.filter(x => x !== test)[0];
}
exports.getFirstElementInListNotEqualTo = getFirstElementInListNotEqualTo;
function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.timeout = timeout;
exports.getCreate2MultisigAddress = async (owners, proxyFactoryAddress, minimumViableMultisigAddress, ethProvider) => {
    const proxyFactory = new ethers_1.Contract(proxyFactoryAddress, contracts_1.ProxyFactory.abi, ethProvider);
    const proxyBytecode = await proxyFactory.functions.proxyCreationCode();
    return utils_1.getAddress(utils_1.solidityKeccak256(["bytes1", "address", "uint256", "bytes32"], [
        "0xff",
        proxyFactoryAddress,
        utils_1.solidityKeccak256(["bytes32", "uint256"], [
            utils_1.keccak256(new utils_1.Interface(contracts_1.MinimumViableMultisig.abi).functions.setup.encode([
                xkeys_1.xkeysToSortedKthAddresses(owners, 0)
            ])),
            0
        ]),
        utils_1.solidityKeccak256(["bytes", "uint256"], [`0x${proxyBytecode.replace("0x", "")}`, minimumViableMultisigAddress])
    ]).slice(-40));
};
exports.wait = (ms) => new Promise(r => setTimeout(r, ms));
exports.bigNumberifyJson = (json) => JSON.parse(JSON.stringify(json), (key, val) => (val && val["_hex"] ? utils_1.bigNumberify(val) : val));
exports.deBigNumberifyJson = (json) => JSON.parse(JSON.stringify(json), (key, val) => val && utils_1.BigNumber.isBigNumber(val) ? val.toHexString() : val);
function signaturesToBytes(...signatures) {
    return signatures
        .map(utils_1.joinSignature)
        .map(s => s.substr(2))
        .reduce((acc, v) => acc + v, "0x");
}
exports.signaturesToBytes = signaturesToBytes;
function sortSignaturesBySignerAddress(digest, signatures) {
    const ret = signatures.slice();
    ret.sort((sigA, sigB) => {
        const addrA = utils_1.recoverAddress(digest, signaturesToBytes(sigA));
        const addrB = utils_1.recoverAddress(digest, signaturesToBytes(sigB));
        return new utils_1.BigNumber(addrA).lt(addrB) ? -1 : 1;
    });
    return ret;
}
exports.sortSignaturesBySignerAddress = sortSignaturesBySignerAddress;
function signaturesToBytesSortedBySignerAddress(digest, ...signatures) {
    return signaturesToBytes(...sortSignaturesBySignerAddress(digest, signatures));
}
exports.signaturesToBytesSortedBySignerAddress = signaturesToBytesSortedBySignerAddress;
function prettyPrintObject(object) {
    return JSON.stringify(object, null, constants_1.JSON_STRINGIFY_SPACE);
}
exports.prettyPrintObject = prettyPrintObject;
async function sleep(timeInMilliseconds) {
    return new Promise(resolve => setTimeout(resolve, timeInMilliseconds));
}
exports.sleep = sleep;
//# sourceMappingURL=utils.js.map