"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const constants_2 = require("../../../../src/constants");
const ethereum_1 = require("../../../../src/ethereum");
const app_identity_1 = require("../../../../src/ethereum/utils/app-identity");
const models_1 = require("../../../../src/models");
const free_balance_1 = require("../../../../src/models/free-balance");
const contracts_1 = require("../../../contracts");
const utils_2 = require("../../../unit/utils");
const random_signing_keys_1 = require("../../integration/random-signing-keys");
const mocks_1 = require("../../mocks");
describe("ConditionalTransaction", () => {
    let tx;
    const networkContext = mocks_1.generateRandomNetworkContext();
    const interaction = {
        sender: random_signing_keys_1.getRandomExtendedPubKey(),
        receiver: random_signing_keys_1.getRandomExtendedPubKey()
    };
    let stateChannel = models_1.StateChannel.setupChannel(networkContext.IdentityApp, networkContext.ProxyFactory, utils_1.getAddress(utils_1.hexlify(utils_1.randomBytes(20))), [interaction.sender, interaction.receiver]);
    stateChannel = stateChannel.setFreeBalance(free_balance_1.FreeBalanceClass.createWithFundedTokenAmounts(stateChannel.multisigOwners, constants_1.WeiPerEther, [constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS]));
    const freeBalanceETH = stateChannel.freeBalance;
    const appInstance = utils_2.createAppInstanceForTest(stateChannel);
    beforeAll(() => {
        tx = new ethereum_1.ConditionalTransaction(networkContext, stateChannel.multisigAddress, stateChannel.multisigOwners, appInstance.identityHash, freeBalanceETH.identityHash, constants_1.AddressZero, constants_1.HashZero).getTransactionDetails();
    });
    it("should be to the ConditionalTransactionDelegateTarget contract", () => {
        expect(tx.to).toBe(networkContext.ConditionalTransactionDelegateTarget);
    });
    it("should have no value", () => {
        expect(tx.value).toBe(0);
    });
    describe("the calldata", () => {
        let iface;
        let calldata;
        beforeAll(() => {
            iface = new utils_1.Interface(contracts_1.ConditionalTransactionDelegateTarget.abi);
            calldata = iface.parseTransaction({ data: tx.data });
        });
        it("should be directed at the executeEffectOfInterpretedAppOutcome method", () => {
            expect(calldata.sighash).toBe(iface.functions.executeEffectOfInterpretedAppOutcome.sighash);
        });
        it("should have correctly constructed arguments", () => {
            const [appRegistryAddress, freeBalanceAppIdentity, appIdentityHash, interpreterAddress, interpreterParams] = calldata.args;
            expect(appRegistryAddress).toBe(networkContext.ChallengeRegistry);
            expect(freeBalanceAppIdentity).toBe(freeBalanceETH.identityHash);
            expect(appIdentityHash).toBe(app_identity_1.appIdentityToHash(appInstance.identity));
            expect(interpreterAddress).toBe(constants_1.AddressZero);
            expect(interpreterParams).toBe(constants_1.HashZero);
        });
    });
});
//# sourceMappingURL=conditional-transaction-commitment.spec.js.map