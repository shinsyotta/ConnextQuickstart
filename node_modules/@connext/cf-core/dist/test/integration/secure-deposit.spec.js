"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const providers_1 = require("ethers/providers");
const loglevel_1 = __importDefault(require("loglevel"));
const constants_2 = require("../../src/constants");
const contracts_1 = require("../contracts");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const setup_1 = require("./setup");
const utils_1 = require("./utils");
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
loglevel_1.default.setLevel(loglevel_1.default.levels.SILENT);
function confirmDepositMessages(initiator, responder, params) {
    const startedMsg = {
        from: initiator.publicIdentifier,
        type: "DEPOSIT_STARTED_EVENT",
        data: {
            value: params.amount
        }
    };
    const confirmMsg = {
        from: initiator.publicIdentifier,
        type: "DEPOSIT_CONFIRMED_EVENT",
        data: params
    };
    initiator.once("DEPOSIT_STARTED_EVENT", (msg) => {
        utils_1.assertNodeMessage(msg, startedMsg, ["data.txHash"]);
    });
    initiator.once("DEPOSIT_CONFIRMED_EVENT", (msg) => {
        utils_1.assertNodeMessage(msg, confirmMsg);
    });
    responder.once("DEPOSIT_CONFIRMED_EVENT", (msg) => {
        utils_1.assertNodeMessage(msg, confirmMsg);
    });
}
describe("Node method follows spec - deposit", () => {
    let nodeA;
    let nodeB;
    let provider;
    let multisigAddress;
    beforeEach(async () => {
        const context = await setup_1.setup(global);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
        multisigAddress = await utils_1.createChannel(nodeA, nodeB);
        expect(multisigAddress).toBeDefined();
        nodeA.off("DEPOSIT_CONFIRMED_EVENT");
        nodeB.off("DEPOSIT_CONFIRMED_EVENT");
    });
    it("has the right balance before an ERC20 deposit has been made", async () => {
        const erc20ContractAddress = global["networkContext"].DolphinCoin;
        const freeBalanceState = await utils_1.getFreeBalanceState(nodeA, multisigAddress, erc20ContractAddress);
        expect(Object.values(freeBalanceState)).toMatchObject([constants_1.Zero, constants_1.Zero]);
    });
    it("has the right balance for both parties after deposits", async () => {
        const preDepositBalance = await provider.getBalance(multisigAddress);
        await utils_1.deposit(nodeB, multisigAddress, constants_1.One, nodeA);
        await utils_1.deposit(nodeA, multisigAddress, constants_1.One, nodeB);
        expect(await provider.getBalance(multisigAddress)).toBeEq(preDepositBalance.add(2));
        const freeBalanceState = await utils_1.getFreeBalanceState(nodeA, multisigAddress);
        expect(Object.values(freeBalanceState)).toMatchObject([constants_1.One, constants_1.One]);
    });
    it("updates balances correctly when depositing both ERC20 tokens and ETH", async () => {
        const erc20ContractAddress = global["networkContext"].DolphinCoin;
        const erc20Contract = new ethers_1.Contract(erc20ContractAddress, contracts_1.DolphinCoin.abi, new providers_1.JsonRpcProvider(global["ganacheURL"]));
        await utils_1.transferERC20Tokens(await nodeA.signerAddress());
        await utils_1.transferERC20Tokens(await nodeB.signerAddress());
        let preDepositBalance = await provider.getBalance(multisigAddress);
        const preDepositERC20Balance = await erc20Contract.functions.balanceOf(multisigAddress);
        await utils_1.deposit(nodeA, multisigAddress, constants_1.One, nodeB, erc20ContractAddress);
        await utils_1.deposit(nodeB, multisigAddress, constants_1.One, nodeA, erc20ContractAddress);
        expect(await provider.getBalance(multisigAddress)).toEqual(preDepositBalance);
        expect(await erc20Contract.functions.balanceOf(multisigAddress)).toEqual(preDepositERC20Balance.add(constants_1.Two));
        await confirmEthAndERC20FreeBalances(nodeA, multisigAddress, erc20ContractAddress);
        await confirmEthAndERC20FreeBalances(nodeB, multisigAddress, erc20ContractAddress);
        preDepositBalance = await provider.getBalance(multisigAddress);
        await utils_1.deposit(nodeA, multisigAddress, constants_1.One, nodeB);
        await utils_1.deposit(nodeB, multisigAddress, constants_1.One, nodeA);
        expect(await provider.getBalance(multisigAddress)).toBeEq(preDepositBalance.add(2));
        const freeBalanceState = await utils_1.getFreeBalanceState(nodeA, multisigAddress);
        expect(Object.values(freeBalanceState)).toMatchObject([constants_1.One, constants_1.One]);
    });
});
async function confirmEthAndERC20FreeBalances(node, multisigAddress, erc20ContractAddress) {
    const tokenIndexedFreeBalances = await utils_1.getTokenIndexedFreeBalanceStates(node, multisigAddress);
    expect(Object.values(tokenIndexedFreeBalances[constants_2.CONVENTION_FOR_ETH_TOKEN_ADDRESS])).toMatchObject([constants_1.Zero, constants_1.Zero]);
    expect(Object.values(tokenIndexedFreeBalances[erc20ContractAddress])).toMatchObject([constants_1.One, constants_1.One]);
}
//# sourceMappingURL=secure-deposit.spec.js.map