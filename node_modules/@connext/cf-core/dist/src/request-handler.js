"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const loglevel_1 = __importDefault(require("loglevel"));
const api_1 = require("./api");
const store_1 = require("./store");
const types_1 = require("./types");
const utils_1 = require("./utils");
class RequestHandler {
    constructor(publicIdentifier, incoming, outgoing, storeService, messagingService, protocolRunner, networkContext, provider, wallet, storeKeyPrefix, blocksNeededForConfirmation, processQueue) {
        this.publicIdentifier = publicIdentifier;
        this.incoming = incoming;
        this.outgoing = outgoing;
        this.storeService = storeService;
        this.messagingService = messagingService;
        this.protocolRunner = protocolRunner;
        this.networkContext = networkContext;
        this.provider = provider;
        this.wallet = wallet;
        this.blocksNeededForConfirmation = blocksNeededForConfirmation;
        this.processQueue = processQueue;
        this.methods = new Map();
        this.events = new Map();
        this.store = new store_1.Store(storeService, storeKeyPrefix);
    }
    injectRouter(router) {
        this.router = router;
        this.mapPublicApiMethods();
        this.mapEventHandlers();
    }
    async callMethod(method, req) {
        const result = {
            type: req.type,
            requestId: req.requestId,
            result: await this.methods.get(method)(this, req.params)
        };
        return result;
    }
    mapPublicApiMethods() {
        for (const methodName in api_1.methodNameToImplementation) {
            this.methods.set(methodName, api_1.methodNameToImplementation[methodName]);
            this.incoming.on(methodName, async (req) => {
                const res = {
                    type: req.type,
                    requestId: req.requestId,
                    result: await this.methods.get(methodName)(this, utils_1.bigNumberifyJson(req.params))
                };
                this.router.emit(req.methodName, res, "outgoing");
            });
        }
    }
    mapEventHandlers() {
        for (const eventName of Object.values(types_1.NODE_EVENTS)) {
            this.events.set(eventName, api_1.eventNameToImplementation[eventName]);
        }
    }
    async callEvent(event, msg) {
        const controllerExecutionMethod = this.events.get(event);
        const controllerCount = this.router.eventListenerCount(event);
        if (!controllerExecutionMethod && controllerCount === 0) {
            if (event === "DEPOSIT_CONFIRMED_EVENT") {
                loglevel_1.default.info(`No event handler for counter depositing into channel: ${JSON.stringify(msg, undefined, 4)}`);
            }
            else {
                throw Error(`Recent ${event} which has no event handler`);
            }
        }
        if (controllerExecutionMethod) {
            await controllerExecutionMethod(this, msg);
        }
        this.router.emit(event, msg);
    }
    async isLegacyEvent(event) {
        return this.events.has(event);
    }
    async getSigner() {
        return this.wallet;
    }
    async getSignerAddress() {
        const signer = await this.getSigner();
        return await signer.getAddress();
    }
}
exports.RequestHandler = RequestHandler;
//# sourceMappingURL=request-handler.js.map