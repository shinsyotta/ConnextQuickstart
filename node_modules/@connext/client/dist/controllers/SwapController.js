"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const hdnode_1 = require("ethers/utils/hdnode");
const lib_1 = require("../lib");
const cfCore_1 = require("../lib/cfCore");
const constants_2 = require("../lib/constants");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
exports.calculateExchange = (amount, swapRate) => {
    return utils_1.bigNumberify(utils_1.formatEther(amount.mul(utils_1.parseEther(swapRate))).replace(/\.[0-9]*$/, ""));
};
class SwapController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.resolveInstallSwap = (res, appId, data) => {
            if (appId !== data.params.appInstanceId) {
                this.log.warn(`Attempting to resolve promise for ${appId}, but got event data from ${lib_1.stringify(data)}. This should not happen.`);
                return;
            }
            res(data);
            return data;
        };
        this.rejectInstallSwap = (rej, appId, msg) => {
            const appInstanceId = msg.appInstanceId || msg.data.appInstanceId;
            if (msg.data) {
                this.log.warn(`This should not have this structure when emitted, strange. msg: ${lib_1.stringify(msg)}`);
            }
            if (appId !== appInstanceId) {
                this.log.warn(`Attempting to reject promise for ${appId}, but got event data from ${lib_1.stringify(msg)}. This should not happen.`);
                return;
            }
            rej(`Install rejected. Event data: ${lib_1.stringify(msg)}`);
            return msg;
        };
        this.swapAppInstall = (amount, toAssetId, fromAssetId, swapRate, appInfo) => __awaiter(this, void 0, void 0, function* () {
            let boundResolve;
            let boundReject;
            const swappedAmount = exports.calculateExchange(amount, swapRate);
            this.log.info(`Installing swap app. Swapping ${amount.toString()} of ${fromAssetId}` +
                ` for ${swappedAmount.toString()} of ${toAssetId}`);
            const initialState = {
                coinTransfers: [
                    [
                        {
                            amount,
                            to: hdnode_1.fromExtendedKey(this.connext.publicIdentifier).derivePath("0").address,
                        },
                    ],
                    [
                        {
                            amount: swappedAmount,
                            to: hdnode_1.fromExtendedKey(this.connext.nodePublicIdentifier).derivePath("0").address,
                        },
                    ],
                ],
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding } = appInfo;
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: amount,
                initiatorDepositTokenAddress: fromAssetId,
                outcomeType: appInfo.outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: swappedAmount,
                responderDepositTokenAddress: toAssetId,
                timeout: constants_1.Zero,
            };
            const res = yield this.connext.proposeInstallApp(params);
            this.log.warn(`Successfully proposed appId: ${res.appInstanceId}`);
            yield Promise.race([
                new Promise((resolve, reject) => {
                    boundReject = this.rejectInstallSwap.bind(null, reject, res.appInstanceId);
                    boundResolve = this.resolveInstallSwap.bind(null, resolve, res.appInstanceId);
                    this.listener.on(types_1.CFCoreTypes.EventNames.INSTALL_EVENT, boundResolve);
                    this.listener.on(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
                }),
                lib_1.delayAndThrow(constants_2.CF_METHOD_TIMEOUT, `App install took longer than ${constants_2.CF_METHOD_TIMEOUT / 1000} seconds`),
            ]);
            this.cleanupInstallListeners(boundResolve, boundReject);
            return res.appInstanceId;
        });
        this.cleanupInstallListeners = (boundResolve, boundReject) => {
            this.listener.removeListener(types_1.CFCoreTypes.EventNames.INSTALL_EVENT, boundResolve);
            this.listener.removeListener(types_1.CFCoreTypes.EventNames.REJECT_INSTALL_EVENT, boundReject);
        };
    }
    swap(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { amount, toAssetId, fromAssetId, swapRate } = types_1.convert.SwapParameters("bignumber", params);
            const preSwapFromBal = yield this.connext.getFreeBalance(fromAssetId);
            const userBal = preSwapFromBal[this.connext.freeBalanceAddress];
            const preSwapToBal = yield this.connext.getFreeBalance(toAssetId);
            const nodeBal = preSwapToBal[cfCore_1.xpubToAddress(this.connext.nodePublicIdentifier)];
            const swappedAmount = exports.calculateExchange(amount, swapRate);
            validation_1.validate(validation_1.invalidAddress(fromAssetId), validation_1.invalidAddress(toAssetId), validation_1.notLessThanOrEqualTo(amount, userBal), validation_1.notGreaterThan(amount, constants_1.Zero), validation_1.notLessThanOrEqualTo(swappedAmount, nodeBal), validation_1.notPositive(utils_1.parseEther(swapRate)));
            const appInfo = this.connext.getRegisteredAppDetails("SimpleTwoPartySwapApp");
            const appId = yield this.swapAppInstall(amount, toAssetId, fromAssetId, swapRate, appInfo);
            this.log.info(`Swap app installed! Uninstalling without updating state.`);
            yield this.connext.uninstallApp(appId);
            const postSwapFromBal = yield this.connext.getFreeBalance(fromAssetId);
            const postSwapToBal = yield this.connext.getFreeBalance(toAssetId);
            const diffFrom = preSwapFromBal[this.connext.freeBalanceAddress].sub(postSwapFromBal[this.connext.freeBalanceAddress]);
            const diffTo = postSwapToBal[this.connext.freeBalanceAddress].sub(preSwapToBal[this.connext.freeBalanceAddress]);
            if (!diffFrom.eq(amount) || !diffTo.eq(swappedAmount)) {
                throw new Error("Invalid final swap amounts - this shouldn't happen!!");
            }
            const newState = yield this.connext.getChannel();
            return newState;
        });
    }
}
exports.SwapController = SwapController;
//# sourceMappingURL=SwapController.js.map