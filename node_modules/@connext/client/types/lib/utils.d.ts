export declare const capitalize: (str: string) => string;
/**
 * A simple lock that can be used with async/await.
 *
 * For example:
 *
 *  funcLock = Lock.released()
 *
 *  // NOTE: this pattern is implemented by the `synchronized` decorator, below.
 *  async function lockedFunction() {
 *    await this.funcLock
 *    this.funcLock = new Lock()
 *    try {
 *      ... do stuff ...
 *    } finally {
 *      this.funcLock.release()
 *    }
 *  }
 *
 */
export declare class Lock<T = void> implements PromiseLike<T> {
    static released(): any;
    then: any;
    catch: any;
    private _resolve;
    private _p;
    constructor();
    release(val?: T): any;
}
/**
 * Synchronize (ie, lock so as to allow only allow one concurrent caller) a
 * method.
 *
 * For example:
 *
 *   class MyClass {
 *
 *     fooLock = Lock.release()
 *
 *     @synchronized('fooLock')
 *     async foo(msg: string) {
 *       await sleep(1000)
 *       console.log('msg:', msg)
 *     }
 *   }
 *
 *   > x = new MyClass()
 *   > x.foo('first')
 *   > x.foo('second')
 *   ... 1 second ...
 *   msg: first
 *   ... 1 more second ...
 *   msg: second
 */
export declare const synchronized: (lockName: string) => any;
export declare const isFunction: (functionToCheck: any) => boolean;
/**
 * A simple FIFO queue.
 *
 * For example:
 *
 *  > queue = new Queue([1])
 *  > queue.put(2)
 *  > queue.length
 *  2
 *  > await queue.shift()
 *  1
 *  > queue.peek()
 *  1
 *  > await queue.shift()
 *  1
 *  > queue.peek()
 *  Queue.EMPTY
 *
 */
export declare class Queue<T> {
    static readonly EMPTY: unique symbol;
    length: number;
    private _notEmpty;
    private _items;
    constructor(items?: T[]);
    put(...items: T[]): void;
    shift(): Promise<T | undefined>;
    peek(): T | (typeof Queue)['EMPTY'];
}
/**
 * A promise that exposes `resolve()` and `reject()` methods.
 */
export declare class ResolveablePromise<T = void> implements PromiseLike<T> {
    catch: any;
    reject: (err: any) => void;
    resolve: (arg?: T) => void;
    then: any;
    private _p;
    constructor();
}
/**
 * Catches any exception which might be raised by a promise and returns a
 * tuple of [result, error], where either the result or the error will be
 * undefined:
 *
 *   let [res, error] = await maybe(someApi.get(...))
 *   if (err) {
 *     return `Oh no there was an error: ${err}`
 *   }
 *   console.log('The result:', res)
 *
 * The result is also an object with `res` and `err` fields:
 *
 *   let someResult = await maybe(someApi.get(...))
 *   if (someResult.err) {
 *     return `Oh no there was an error: ${someResult.err}`
 *   }
 *   console.log('The result:', someResult.res)
 *
 */
declare type MaybeRes<T> = [T, any] & {
    res: T;
    err: any;
};
export declare const maybe: <T>(p: Promise<T>) => Promise<MaybeRes<T>>;
/**
 * Times out a promise. Waits for either:
 * 1) Promise `p` to resolve. If so, `[false, T]` is returned (where T is the
 *    return value of `p`.
 * 2) Timeout `timeout` expires. If so, `[true, p]` is returned (where `p` is
 *    the original promise.
 *
 * If timeout is false-y then `[false, T]` will be unconditionally returned.
 */
export declare const timeoutPromise: <T>(p: Promise<T>, timeout: number | undefined) => Promise<[false, T] | [true, Promise<T>]>;
/**
 * Used to assert at compile time that a statement is unreachable.
 *
 * For example:
 *
 *  type Option = 'a' | 'b'
 *
 *  function handleOption(o: Option) {
 *    if (o == 'a')
 *      return handleA()
 *    if (o == 'b')
 *      return handleB()
 *    assertUnreachable(o)
 *  }
 */
export declare const assertUnreachable: (x: never) => never;
/**
 * Sleep.
 *
 *    await sleep(1000)
 */
export declare const sleep: (t: number) => Promise<any>;
export {};
