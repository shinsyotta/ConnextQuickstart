import { BN } from './lib';
import { ChannelState, ChannelStateBN, ChannelUpdateReason, DepositArgsBN, ExchangeArgsBN, InvalidationArgs, PaymentArgsBN, PaymentBN, PendingArgsBN, PendingExchangeArgsBN, ThreadState, ThreadStateBN, UnsignedChannelState, UnsignedChannelStateBN, UnsignedThreadState, UpdateRequestBN, VerboseChannelEventBN, WithdrawalArgsBN } from './types';
/**
 * Calculate the amount of wei/tokens to sell/recieve from the perspective of
 * the user.
 *
 * If the 'seller' is the hub, the amounts will be multiplied by -1 so callers
 * can apply the values as if they were from the perspective of the user.
 *
 * Note: because the number of tokens being sold may not cleanly divide into
 * the exchange rate, the number of tokens sold (ie, 'res.tokensSold') may be
 * slightly lower than the number of tokens reqested to sell (ie,
 * 'args.tokensToSell'). For this reason, it's important that callers use the
 * 'tokensSold' field to calculate how many tokens are being transferred::
 *
 *   const exchange = calculateExchange(...)
 *   state.balanceWeiUser -= exchange.weiSold
 *   state.balanceTokenUser -= exchange.tokensSold
 *   state.balanceWeiHub += exchange.weiReceived
 *   state.balanceTokenHub += exchange.tokensReceived
 *
 */
export declare const calculateExchange: (args: import("./types").ExchangeArgs<import("ethers/utils/bignumber").BigNumber>) => any;
export declare function depositIfNegative(r: any, src: string, dst: string): any;
export declare function objMap<T, F extends keyof T, R>(obj: T, func: (val: T[F], field: F) => R): {
    [key in keyof T]: R;
};
export declare function coalesce<T>(...vals: Array<T | null | undefined>): T | undefined;
/**
 * Subtracts the arguments, returning either the value (if greater than zero)
 * or zero.
 */
export declare const subOrZero: (a: import("ethers/utils/bignumber").BigNumber | undefined, ...args: (import("ethers/utils/bignumber").BigNumber | undefined)[]) => import("ethers/utils/bignumber").BigNumber;
export declare class StateGenerator {
    private utils;
    stateTransitionHandlers: {
        [name in ChannelUpdateReason]: any;
    };
    constructor();
    createChannelStateFromRequest(prev: ChannelStateBN, request: UpdateRequestBN): UnsignedChannelState;
    channelPayment(prev: ChannelStateBN, args: PaymentArgsBN): UnsignedChannelState;
    exchange(prev: ChannelStateBN, args: ExchangeArgsBN): UnsignedChannelState;
    proposePendingDeposit(prev: ChannelStateBN, args: DepositArgsBN): UnsignedChannelState;
    /**
     * Apply an exchange to the state, assuming that there is sufficient balance
     * (otherwise the result may have negative balances; see also:
     * applyCollateralizedExchange).
     */
    applyInChannelExchange(state: UnsignedChannelStateBN, exchangeArgs: ExchangeArgsBN): UnsignedChannelStateBN;
    /**
     * Apply an exchange to the state, adding a pending deposit to the user if
     * the hub doesn't have sufficient balance (note: collateral will only be
     * added when the hub is selling to the user; collateral will never be
     * deposited into the user's channel).
     */
    applyCollateralizedExchange(state: UnsignedChannelStateBN, exchangeArgs: ExchangeArgsBN): UnsignedChannelStateBN;
    applyPending(state: UnsignedChannelStateBN, args: PendingArgsBN): UnsignedChannelStateBN;
    proposePending(prev: UnsignedChannelStateBN, args: PendingArgsBN): UnsignedChannelState;
    proposePendingExchange(prev: UnsignedChannelStateBN, args: PendingExchangeArgsBN): UnsignedChannelState;
    /**
     * Any time there is a user deposit and a hub withdrawal, the state can be
     * simplified so it becomes an in-channel exchange.
     *
     * For example:
     *
     *   balanceUser: 0
     *   balanceHub: 5
     *   pendingDepositUser: 10
     *   pendingWithdrawalHub: 7
     *
     * Can be simplified to:
     *
     *   balanceUser: 7
     *   balanceHub: 5
     *   pendingDepositUser: 3
     *   pendingWithdrawalHub: 0
     *
     * NOTE: This function is un-used. See comment at top of function.
    private _unused_applyInChannelTransferSimplifications(
      _state: UnsignedChannelStateBN,
    ): UnsignedChannelStateBN {
      const state = { ..._state }
      // !!! NOTE !!!
      // This function is currently un-used because:
      // 1. At present there isn't a need to optimize in-channel balance
      //    transfers, and
      // 2. It has not been exhaustively tested.
      //
      // It is being left in place because:
      // 1. In the future it may be desierable to optimize in-channel balance
      //    exchanges, and
      // 2. There will likely be future discussions around 'maybe we should
      //    optmize balance transfers!', and this comment will serve as a
      //    starting point to the discussion.
      // !!! NOTE !!!
      const s = state as any
      // Hub is withdrawing from their balance and a balance is being sent from
      // reserve to the user. Deduct from the hub's pending withdrawal, the
      // user's pending deposit, and add to the user's balance:
      //
      //   balanceUser: 0
      //   pendingDepositUser: 4
      //   pendingWithdrawalUser: 1
      //   pendingWithdrawalHub: 9
      //
      // Becomes:
      //
      //   balanceUser: 3
      //   pendingDepositUser: 0
      //   pendingWithdrawalUser: 1
      //   pendingWithdrawalHub: 5
      //
      for (const type of ['Wei', 'Token']) {
        // First, calculate how much can be added directly from the hub's
        // withdrawal to the user's balance (this potentially leaves a deposit
        // that will be immediately withdrawn, which is handled below):
        //
        //   pendingWithdrawalUser: 1
        //   pendingWithdrawalHub: 9
        //   pendingDepositUser: 4
        //   balanceUser: 0
        //
        // Becomes:
        //
        //   pendingWithdrawalUser: 1
        //   pendingWithdrawalHub: 6 (9 - (4 - 1))
        //   pendingDepositUser: 1 (4 - (4 - 1))
        //   balanceUser: 3 (0 + (4 - 1))
        //
        let delta = minBN([
          // Amount being deducted from the hub's balance
          subOrZero(s[`pendingWithdrawal${type}Hub`], s[`pendingDeposit${type}Hub`]),
          // Amount being added to the user's balance
          subOrZero(s[`pendingDeposit${type}User`], s[`pendingWithdrawal${type}User`]),
        ])
        s[`pendingWithdrawal${type}Hub`] = s[`pendingWithdrawal${type}Hub`].sub(delta)
        s[`pendingDeposit${type}User`] = s[`pendingDeposit${type}User`].sub(delta)
        s[`balance${type}User`] = s[`balance${type}User`].add(delta)
        // Second, calculate how much can be deducted from both the hub's
        // withdrawal and the user deposit:
        //
        //   pendingWithdrawalUser: 1
        //   pendingWithdrawalHub: 6
        //   pendingDepositUser: 1
        //   balanceUser: 3
        //
        // Becomes:
        //
        //   pendingWithdrawalUser: 1
        //   pendingWithdrawalHub: 5 (6 - 1)
        //   pendingDepositUser: 0 (1 - 1)
        //   balanceUser: 3
        //
        delta = minBN([
          // Amount being deducted from the hub's balance
          subOrZero(s[`pendingWithdrawal${type}Hub`], s[`pendingDeposit${type}Hub`]),
          // Amount being sent to the user for direct withdrawal
          s[`pendingDeposit${type}User`],
        ])
        s[`pendingWithdrawal${type}Hub`] = s[`pendingWithdrawal${type}Hub`].sub(delta)
        s[`pendingDeposit${type}User`] = s[`pendingDeposit${type}User`].sub(delta)
      }
      // User is withdrawing from their balance and a deposit is being made from
      // reserve into the hub's balance. Increase the user's pending deposit,
      // decrease the hub's deposit, and add to the hub's balance:
      //
      //   pendingWithdrawalUser: 5
      //   pendingDepositHub: 3
      //   balanceHub: 0
      //
      // Becomes:
      //
      //   pendingWithdrawalUser: 5
      //   pendingDepositUser: 3
      //   balanceHub: 3
      //
      for (const type of ['Wei', 'Token']) {
        const delta = minBN([
          // Amount being deducted from the user's balance
          subOrZero(s[`pendingWithdrawal${type}User`], s[`pendingDeposit${type}User`]),
          // Amount being added from reserve to the hub's balance
          subOrZero(s[`pendingDeposit${type}Hub`], s[`pendingWithdrawal${type}Hub`]),
        ])
        s[`pendingDeposit${type}User`] = s[`pendingDeposit${type}User`].add(delta)
        s[`pendingDeposit${type}Hub`] = s[`pendingDeposit${type}Hub`].sub(delta)
        s[`balance${type}Hub`] = s[`balance${type}Hub`].add(delta)
      }
      return state
    }
    */
    /**
     * Creates WithdrawalArgs based on more user-friendly inputs.
     *
     * See comments on the CreateWithdrawal type for a description.
     */
    proposePendingWithdrawal(prev: UnsignedChannelStateBN, args: WithdrawalArgsBN): UnsignedChannelState;
    confirmPending(prev: ChannelStateBN): UnsignedChannelState;
    emptyChannel(event: VerboseChannelEventBN): UnsignedChannelState;
    openThread(prev: ChannelStateBN, initialThreadStates: ThreadState[], args: ThreadStateBN): UnsignedChannelState;
    closeThread(prev: ChannelStateBN, _initialThreadStates: ThreadState[], args: ThreadStateBN): UnsignedChannelState;
    threadPayment(prev: ThreadStateBN, args: PaymentBN): UnsignedThreadState;
    invalidation(prev: ChannelStateBN, args: InvalidationArgs): UnsignedChannelState;
    private revertPending;
    _revertPendingUpdates(chan: ChannelState<BN>, args: InvalidationArgs): any;
    _revertPendingWithdrawalAndExchange(chan: ChannelStateBN, args: WithdrawalArgsBN): any;
}
