"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const contracts_1 = require("../contracts");
const utils_2 = require("../utils");
const types_1 = require("./types");
const app_identity_1 = require("./utils/app-identity");
const iface = new utils_1.Interface(contracts_1.ChallengeRegistry.abi);
class SetStateCommitment extends types_1.EthereumCommitment {
    constructor(networkContext, appIdentity, hashedAppState, appVersionNumber, timeout) {
        super();
        this.networkContext = networkContext;
        this.appIdentity = appIdentity;
        this.hashedAppState = hashedAppState;
        this.appVersionNumber = appVersionNumber;
        this.timeout = timeout;
    }
    hashToSign() {
        return utils_1.keccak256(utils_1.solidityPack(["bytes1", "bytes32", "uint256", "uint256", "bytes32"], [
            "0x19",
            app_identity_1.appIdentityToHash(this.appIdentity),
            this.appVersionNumber,
            this.timeout,
            this.hashedAppState
        ]));
    }
    getSignedTransaction(sigs) {
        return {
            to: this.networkContext.ChallengeRegistry,
            value: 0,
            data: iface.functions.setState.encode([
                this.appIdentity,
                this.getSignedStateHashUpdate(sigs)
            ])
        };
    }
    getSignedStateHashUpdate(signatures) {
        return {
            appStateHash: this.hashedAppState,
            versionNumber: this.appVersionNumber,
            timeout: this.timeout,
            signatures: utils_2.sortSignaturesBySignerAddress(this.hashToSign(), signatures).map(utils_1.joinSignature)
        };
    }
}
exports.SetStateCommitment = SetStateCommitment;
//# sourceMappingURL=set-state-commitment.js.map