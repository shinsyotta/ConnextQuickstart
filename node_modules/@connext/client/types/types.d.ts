import { BN } from './lib';
export { Contract } from 'ethers/contract';
export { Block, Filter, Provider, TransactionReceipt, TransactionRequest, TransactionResponse, } from 'ethers/providers';
export { BigNumber as BN, Interface, LogDescription, Transaction, UnsignedTransaction, } from 'ethers/utils';
export { ChannelManager } from './contract/ChannelManager';
export declare type Address = string;
export declare type ExchangeRates = {
    [key in CurrencyType]?: string;
};
export interface ExchangeRateState {
    lastUpdated: Date;
    rates: ExchangeRates;
}
export declare const CurrencyType: {
    DAI: string;
    DEI: string;
    ETH: string;
    FIN: string;
    WEI: string;
};
export declare type CurrencyType = keyof typeof CurrencyType;
export interface HubConfig<T = string> {
    contractAddress: Address;
    ethChainId: string;
    hubAddress: Address;
    maxCollateralization: T;
    tokenAddress: Address;
}
export declare type HubConfigBN = HubConfig<BN>;
export declare type ConnextProvider = any;
/*********************************
 ****** HELPER FUNCTIONS *********
 *********************************/
export interface NumericTypes {
    'str': string;
    'bn': BN;
    'number': number;
}
export declare type NumericTypeName = keyof NumericTypes;
export declare const convertFields: (fromType: "number" | "bn" | "str", toType: "number" | "bn" | "str", fields: string[], input: any) => any;
/*********************************
 ********* CHANNEL TYPES *********
 *********************************/
export interface UnsignedChannelState<T = string> {
    contractAddress: Address;
    user: Address;
    recipient: Address;
    balanceWeiHub: T;
    balanceWeiUser: T;
    balanceTokenHub: T;
    balanceTokenUser: T;
    pendingDepositWeiHub: T;
    pendingDepositWeiUser: T;
    pendingDepositTokenHub: T;
    pendingDepositTokenUser: T;
    pendingWithdrawalWeiHub: T;
    pendingWithdrawalWeiUser: T;
    pendingWithdrawalTokenHub: T;
    pendingWithdrawalTokenUser: T;
    txCountGlobal: number;
    txCountChain: number;
    threadRoot: string;
    threadCount: number;
    timeout: number;
}
export declare type UnsignedChannelStateBN = UnsignedChannelState<BN>;
export declare type ChannelState<T = string> = UnsignedChannelState<T> & (({
    sigUser: string;
    sigHub: string;
}) | ({
    sigUser?: string;
    sigHub: string;
}) | ({
    sigUser: string;
    sigHub?: string;
}));
export declare type ChannelStateBN = ChannelState<BN>;
export declare const addSigToChannelState: (channel: UnsignedChannelState<string> | (UnsignedChannelState<string> & {
    sigUser: string;
    sigHub: string;
}) | (UnsignedChannelState<string> & {
    sigUser?: string | undefined;
    sigHub: string;
}) | (UnsignedChannelState<string> & {
    sigUser: string;
    sigHub?: string | undefined;
}), sig?: string | undefined, isUser?: boolean) => ChannelState<string>;
export declare const ChannelStatus: {
    CS_CHAINSAW_ERROR: string;
    CS_CHANNEL_DISPUTE: string;
    CS_OPEN: string;
    CS_THREAD_DISPUTE: string;
};
export declare type ChannelStatus = keyof typeof ChannelStatus;
export declare const DisputeStatus: {
    CD_FAILED: string;
    CD_FINISHED: string;
    CD_IN_DISPUTE_PERIOD: string;
    CD_PENDING: string;
};
export declare type DisputeStatus = keyof typeof DisputeStatus;
export declare const ChannelUpdateReasons: {
    [key in keyof UpdateRequestTypes]: string;
};
export declare type ChannelUpdateReason = keyof UpdateRequestTypes;
export interface ExchangeArgs<T = string> {
    exchangeRate: string;
    seller: 'user' | 'hub';
    tokensToSell: T;
    weiToSell: T;
}
export declare type ExchangeArgsBN = ExchangeArgs<BN>;
export interface PaymentArgs<T = string> {
    recipient: 'user' | 'hub';
    amountToken: T;
    amountWei: T;
}
export declare type PaymentArgsBN = PaymentArgs<BN>;
export interface DepositArgs<T = string> {
    depositWeiHub: T;
    depositWeiUser: T;
    depositTokenHub: T;
    depositTokenUser: T;
    timeout: number;
    sigUser?: string;
    reason?: any;
}
export declare type DepositArgsBN = DepositArgs<BN>;
export interface SignedDepositRequestProposal<T = string> extends Payment<T> {
    sigUser: string;
}
export declare type SignedDepositRequestProposalBN = SignedDepositRequestProposal<BN>;
export interface PendingArgs<T = string> {
    depositWeiUser: T;
    depositWeiHub: T;
    depositTokenUser: T;
    depositTokenHub: T;
    withdrawalWeiUser: T;
    withdrawalWeiHub: T;
    withdrawalTokenUser: T;
    withdrawalTokenHub: T;
    recipient: Address;
    timeout: number;
}
export declare type PendingArgsBN = PendingArgs<BN>;
export declare type PendingExchangeArgs<T = string> = ExchangeArgs<T> & PendingArgs<T>;
export declare type PendingExchangeArgsBN = PendingExchangeArgs<BN>;
export interface WithdrawalArgs<T = string> {
    seller: 'user' | 'hub';
    exchangeRate: string;
    tokensToSell: T;
    weiToSell: T;
    recipient: Address;
    targetWeiUser: T;
    targetTokenUser: T;
    targetWeiHub: T;
    targetTokenHub: T;
    additionalWeiHubToUser?: T;
    additionalTokenHubToUser?: T;
    timeout: number;
}
export declare type WithdrawalArgsBN = WithdrawalArgs<BN>;
export interface ConfirmPendingArgs {
    transactionHash: Address;
}
/**
 * An Invalidation occurs when both parties want or need to agree that a state
 * is not valid.
 *
 * This can happen for two reasons:
 * 1. When the timeout on a state expires. More formally, a block mined with a
 *    timestamp greater than the state's timeout, but the contract has not
 *    emitted a `DidUpdateChannel` event with a matching channel and txCount;
 *    ie, the state has not been sent to chain.
 *
 * 2. Either party wants to reject a half-signed state sent by the
 *    counterparty. For example, if an exchange is proposed and half-signed,
 *    but the counterparty does not agree with the exchange rate.
 *
 * Rules for state invalidation:
 * 1. A fully-signed state can only be invalidated if it has a timeout and that
 *    timeout has expired (per the definition of 'expired', above)
 *
 * 2. An invalidation must reference the latest valid state (ie, the one which
 *    should be reverted to) and the latest invalid state.
 *
 *    These will typically be 'N - 1' and 'N', except in the case of purchases,
 *    where the client may send multiple half-signed states to the hub*. In
 *    this case, the hub will invalidate all the states or none of them.
 *
 *    *: in the future, purchases should be simplified so they only send one
 *       state, so this will no longer be relevant.
 *
 * 3. The sender must always sign the invalidation before relaying it to the
 *    counterparty (ie, it never makes sense to have an unsigned Invalidation).
 *
 * TODO REB-12: do we need to do anything special with invalidating unsigned
 * states? (ex, ProposePendingDeposit)
 */
export declare const InvalidationReason: {
    CU_INVALID_ERROR: string;
    CU_INVALID_REJECTED: string;
    CU_INVALID_TIMEOUT: string;
};
export declare type InvalidationReason = keyof typeof InvalidationReason;
export interface InvalidationArgs<T = string> {
    withdrawal: WithdrawalArgs<T> | undefined;
    invalidTxCount: number;
    reason: InvalidationReason;
    message?: string;
}
export declare type InvalidationArgsBN = InvalidationArgs<BN>;
export declare type EmptyChannelArgs = ConfirmPendingArgs;
export declare type ArgsTypes<T = string> = ExchangeArgs<T> | PaymentArgs<T> | DepositArgs<T> | WithdrawalArgs<T> | ConfirmPendingArgs | InvalidationArgs<T> | EmptyChannelArgs | ThreadState<T> | {};
export declare type ArgTypesBN = ArgsTypes<BN>;
export interface UpdateRequest<T = string, Args = ArgsTypes<T>> {
    id?: number;
    reason: ChannelUpdateReason;
    args: Args;
    txCount: number | undefined;
    sigUser?: string;
    sigHub?: string;
    createdOn?: Date;
    initialThreadStates?: ThreadState[];
}
export interface UpdateRequestTypes<T = string> {
    Payment: UpdateRequest<T, PaymentArgs>;
    Exchange: UpdateRequest<T, ExchangeArgs>;
    ProposePendingDeposit: UpdateRequest<T, DepositArgs>;
    ProposePendingWithdrawal: UpdateRequest<T, WithdrawalArgs>;
    ConfirmPending: UpdateRequest<T, ConfirmPendingArgs>;
    Invalidation: UpdateRequest<T, InvalidationArgs>;
    EmptyChannel: UpdateRequest<T, EmptyChannelArgs>;
    OpenThread: UpdateRequest<T, ThreadState<T>>;
    CloseThread: UpdateRequest<T, ThreadState<T>>;
}
export interface UpdateArgTypes<T = string> {
    Payment: PaymentArgs<T>;
    Exchange: ExchangeArgs<T>;
    ProposePendingDeposit: DepositArgs<T>;
    ProposePendingWithdrawal: WithdrawalArgs<T>;
    ConfirmPending: ConfirmPendingArgs;
    Invalidation: InvalidationArgs;
    EmptyChannel: EmptyChannelArgs;
    OpenThread: ThreadState<T>;
    CloseThread: ThreadState<T>;
}
export declare type UpdateRequestBN = UpdateRequest<BN>;
export interface ChannelStateUpdate<T = string> {
    id?: number;
    reason: ChannelUpdateReason;
    state: ChannelState<T>;
    args: ArgsTypes<T>;
    metadata?: object;
}
export declare type ChannelStateUpdateBN = ChannelStateUpdate<BN>;
export interface ChannelStateUpdateRow<T = string> extends ChannelStateUpdate<T> {
    id: number;
    createdOn: Date;
    channelId?: number;
    chainsawId?: number;
    invalid?: InvalidationReason;
    onchainTxLogicalId?: number;
}
export declare type ChannelStateUpdateRowBN = ChannelStateUpdateRow<BN>;
export declare type SyncResult<T = string> = {
    type: 'thread';
    update: ThreadStateUpdate<T>;
} | {
    type: 'channel';
    update: UpdateRequest<T>;
};
export declare type SyncResultBN = SyncResult<BN>;
export interface Sync<T = string> {
    status: ChannelStatus;
    updates: Array<SyncResult<T>>;
}
export interface ChannelRow<T = string> {
    id: number;
    status: ChannelStatus;
    lastUpdateOn: Date;
    user: string;
    state: ChannelState<T>;
}
export declare type ChannelRowBN = ChannelRow<BN>;
/*********************************
 ********* THREAD TYPES **********
 *********************************/
export interface ThreadRow<T = string> {
    id: number;
    status: ThreadStatus;
    state: ThreadState<T>;
}
export declare type ThreadRowBN = ThreadRow<BN>;
export interface ThreadStateUpdateRow<T = string> {
    id: number;
    createdOn: Date;
    state: ThreadState<T>;
}
export declare type ThreadStateUpdateRowBN = ThreadStateUpdateRow<BN>;
export interface UnsignedThreadState<T = string> {
    contractAddress: Address;
    sender: Address;
    receiver: Address;
    threadId: number;
    balanceWeiSender: T;
    balanceWeiReceiver: T;
    balanceTokenSender: T;
    balanceTokenReceiver: T;
    txCount: number;
}
export declare type UnsignedThreadStateBN = UnsignedThreadState<BN>;
export declare type ThreadState<T = string> = UnsignedThreadState<T> & ({
    sigA: string;
});
export declare type ThreadStateBN = ThreadState<BN>;
export declare const ThreadStatus: {
    CT_CLOSED: string;
    CT_EXITING: string;
    CT_OPEN: string;
};
export declare type ThreadStatus = keyof typeof ThreadStatus;
export interface ThreadStateUpdate<T = string> {
    id?: number;
    createdOn?: Date;
    state: ThreadState<T>;
    metadata?: object;
}
export declare type ThreadStateUpdateBN = ThreadStateUpdate<BN>;
export declare const addSigToThreadState: (thread: UnsignedThreadState<string>, sig?: string | undefined) => ThreadState<string>;
/*********************************
 ********* CONTRACT TYPES ********
 *********************************/
export interface ChannelManagerChannelDetails {
    txCountGlobal: number;
    txCountChain: number;
    threadRoot: string;
    threadCount: number;
    exitInitiator: string;
    channelClosingTime: number;
    status: string;
}
export declare const ChannelEventReasons: {
    DidEmptyChannel: string;
    DidStartExitChannel: string;
    DidUpdateChannel: string;
};
export declare type ChannelEventReason = keyof typeof ChannelEventReasons;
export interface BaseChannelEvent<T = string> {
    user: Address;
    senderIdx: '0' | '1';
    weiBalances: [T, T];
    tokenBalances: [T, T];
    txCount: [string, string];
    threadRoot: string;
    threadCount: string;
}
export declare type DidStartExitChannelEvent = BaseChannelEvent<string>;
export declare type DidStartExitChannelEventBN = BaseChannelEvent<BN>;
export declare type DidEmptyChannelEvent = BaseChannelEvent<string>;
export declare type DidEmptyChannelEventBN = BaseChannelEvent<BN>;
export declare type DidUpdateChannelEvent<T = string> = BaseChannelEvent & {
    pendingWeiUpdates: [T, T, T, T];
    pendingTokenUpdates: [T, T, T, T];
};
export declare type DidUpdateChannelEventBN = DidUpdateChannelEvent<BN>;
export declare const EventInputs: {
    'DidEmptyChannel': ({
        type: string;
        name: string;
        indexed: boolean;
    } | {
        type: string;
        name: string;
        indexed?: undefined;
    })[];
    'DidStartExitChannel': ({
        type: string;
        name: string;
        indexed: boolean;
    } | {
        type: string;
        name: string;
        indexed?: undefined;
    })[];
    'DidUpdateChannel': ({
        type: string;
        name: string;
        indexed: boolean;
    } | {
        type: string;
        name: string;
        indexed?: undefined;
    })[];
};
export declare type ChannelEvent<T = string> = BaseChannelEvent<T> | DidUpdateChannelEvent<T>;
export declare type VerboseChannelEvent<T = string> = UnsignedChannelState<T> & {
    sender: Address;
};
export declare type VerboseChannelEventBN = VerboseChannelEvent<BN>;
export declare const makeEventVerbose: (obj: ChannelEvent<string>, hubAddress: string, contractAddress: string) => VerboseChannelEvent<string>;
export declare const convertVerboseEvent: <To extends "number" | "bn" | "str">(to: To, obj: VerboseChannelEvent<any>) => VerboseChannelEvent<NumericTypes[To]>;
/*********************************
 ********* WALLET TYPES **********
 *********************************/
export interface ThreadHistoryItem {
    sender: Address;
    receiver: Address;
    threadId: number;
}
export interface Payment<T = string> {
    amountWei: T;
    amountToken: T;
}
export declare type PaymentBN = Payment<BN>;
export interface WithdrawalParameters<T = string> {
    recipient: Address;
    exchangeRate: string;
    withdrawalWeiUser: T;
    tokensToSell: T;
    weiToSell?: T;
    withdrawalTokenUser?: T;
}
export declare type WithdrawalParametersBN = WithdrawalParameters<BN>;
export interface SuccinctWithdrawalParameters<T = string> extends Partial<Payment> {
    recipient?: Address;
}
export declare type SuccinctWithdrawalParametersBN = SuccinctWithdrawalParameters<BN>;
/*********************************
 ******* PAYMENT PROFILES ********
 *********************************/
export interface PaymentProfileConfig<T = string> {
    id?: number;
    minimumMaintainedCollateralToken: T;
    amountToCollateralizeToken: T;
    minimumMaintainedCollateralWei?: T;
    amountToCollateralizeWei?: T;
}
export declare type PaymentProfileConfigBN = PaymentProfileConfig<BN>;
/*********************************
 ****** PAYMENT & PURCHASE *******
 *********************************/
export interface EmailRequest {
    to: string;
    subject: string;
    text: string;
}
export interface CustodialBalanceRow<T = string> {
    user: string;
    totalReceivedWei: T;
    totalReceivedToken: T;
    totalWithdrawnWei: T;
    totalWithdrawnToken: T;
    balanceWei: T;
    balanceToken: T;
    sentWei: T;
}
export declare type CustodialBalanceRowBN = CustodialBalanceRow<BN>;
export interface CreateCustodialWithdrawalOptions<T = string> {
    user: string;
    recipient: string;
    requestedToken: T;
    exchangeRate: string;
    sentWei: T;
    onchainTransactionId: number;
}
export declare type CreateCustodialWithdrawalOptionsBN = CreateCustodialWithdrawalOptions<BN>;
export interface CustodialWithdrawalRow<T = string> {
    id: number;
    createdOn: Date;
    user: string;
    recipient: string;
    requestedToken: T;
    exchangeRate: string;
    sentWei: T;
    state: string;
    txHash: string;
    onchainTransactionId: number;
}
export declare type CustodialWithdrawalRowBN = CustodialWithdrawalRow<BN>;
export interface CustodialPaymentsRow {
    paymentId: number;
    updateId: number;
}
export declare type OptimisticPaymentStatus = 'NEW' | 'COMPLETED' | 'FAILED';
export declare type OptimisticPurchasePaymentRow<T = string> = Omit<PurchasePaymentRow<any, T>, 'type' | 'id' | 'custodianAddress'> & {
    status: OptimisticPaymentStatus;
    channelUpdateId: number;
    paymentId: number;
    threadUpdateId?: number;
    redemptionId?: number;
};
export declare type OptimisticPurchasePaymentRowBN = OptimisticPurchasePaymentRow<BN>;
export declare type PurchasePaymentType = 'PT_CHANNEL' | 'PT_THREAD' | 'PT_CUSTODIAL' | 'PT_LINK' | 'PT_OPTIMISTIC';
export interface Purchase<MetadataType = any, PaymentMetadataType = any> {
    purchaseId: string;
    meta: MetadataType;
    amount: Payment;
    payments: Array<PurchasePayment<PaymentMetadataType>>;
}
export declare type PurchasePayment<MetadataType = any, T = string> = ({
    recipient: string;
    amount: Payment<T>;
    meta: MetadataType;
} & ({
    type: 'PT_CHANNEL';
    update: UpdateRequest<T>;
} | {
    type: 'PT_CUSTODIAL';
    update: UpdateRequest<T>;
} | {
    type: 'PT_THREAD';
    update: ThreadStateUpdate<T>;
} | {
    type: 'PT_LINK';
    update: UpdateRequest<T, PaymentArgs<T>>;
} | {
    type: 'PT_OPTIMISTIC';
    update: UpdateRequest<T>;
}));
export declare type PurchasePaymentBN = PurchasePayment<any, BN>;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type PurchasePaymentSummary<MetaType = any, T = string> = Omit<PurchasePayment<MetaType, T>, 'update'>;
export declare type PurchasePaymentSummaryBN = PurchasePaymentSummary<any, BN>;
export declare type PurchasePaymentHubResponse<T = string> = ({
    purchaseId: string;
    sync: Sync<T>;
});
export declare type PurchasePaymentHubResponseBN = PurchasePaymentHubResponse<BN>;
export interface PurchaseRowWithPayments<MetaType = any, PaymentMetaType = any, T = string> {
    purchaseId: string;
    createdOn: Date;
    sender: string;
    meta: MetaType;
    amount: Payment<T>;
    payments: Array<PurchasePaymentRow<PaymentMetaType, T>>;
}
export declare type PurchaseRowWithPaymentsBN = PurchaseRowWithPayments<any, any, BN>;
export interface PurchasePaymentRow<MetaType = any, T = string> extends PurchasePaymentSummary<MetaType, T> {
    id: number;
    createdOn: Date;
    purchaseId: string;
    sender: string;
    custodianAddress: string;
}
export declare type PurchasePaymentRowBN = PurchasePaymentRow<any, BN>;
export interface PartialPurchasePaymentRequest<MetadataType = any> extends Partial<Payment> {
    type?: PurchasePaymentType;
    recipient: string;
    meta?: MetadataType;
}
export interface PartialPurchaseRequest<MetadataType = any> {
    meta?: MetadataType;
    payments: PartialPurchasePaymentRequest[];
}
export interface PurchaseRequest<MetadataType = any, PaymentMetadataType = any> {
    meta: MetadataType;
    payments: Array<PurchasePaymentRequest<PaymentMetadataType>>;
}
export declare type PurchasePaymentRequest<MetadataType = any> = Omit<PurchasePayment<MetadataType>, 'update'>;
/*********************************
 ******* TYPE CONVERSIONS ********
 *********************************/
export declare const objMap: <T, F extends keyof T, R>(obj: T, func: (val: T[F], field: F) => R) => { [key in keyof T]: R; };
export declare const objMapPromise: <T, F extends keyof T, R>(obj: T, func: (val: T[F], field: F) => Promise<R>) => Promise<{ [key in keyof T]: R; }>;
export declare const insertDefault: (val: string, obj: any, keys: string[]) => any;
export declare const channelNumericFields: string[];
export declare const custodialWithdrawalRowNumericFields: string[];
export declare const custodialBalanceRowNumericFields: string[];
export declare const withdrawalParamsNumericFields: string[];
export interface ConvertCustodialBalanceRowOverloaded {
    (to: 'bn', obj: CustodialBalanceRow<any>): CustodialBalanceRowBN;
    (to: 'str', obj: CustodialBalanceRow<any>): CustodialBalanceRow;
}
export declare const convertCustodialBalanceRow: ConvertCustodialBalanceRowOverloaded;
export interface ConvertCustodialWithdrawalRowOverloaded {
    (to: 'bn', obj: CustodialWithdrawalRow<any>): CustodialWithdrawalRowBN;
    (to: 'str', obj: CustodialWithdrawalRow<any>): CustodialWithdrawalRow;
}
export declare const convertCustodialWithdrawalRow: ConvertCustodialWithdrawalRowOverloaded;
export interface ConvertChannelRowOverloaded {
    (to: 'bn', obj: ChannelRow<any>): ChannelRowBN;
    (to: 'str', obj: ChannelRow<any>): ChannelRow;
}
export declare const convertChannelRow: (to: "bn" | "str", obj: ChannelRow<any>) => any;
export interface ConvertChannelStateUpdateRowOverloaded {
    (to: 'bn', obj: ChannelStateUpdateRow<any>): ChannelStateUpdateRowBN;
    (to: 'str', obj: ChannelStateUpdateRow<any>): ChannelStateUpdateRow;
}
export declare const convertChannelStateUpdateRow: ConvertChannelStateUpdateRowOverloaded;
export declare const channelUpdateToUpdateRequest: (up: ChannelStateUpdate<string>) => UpdateRequest<string, ArgsTypes<string>>;
export interface ConvertChannelStateOverloaded {
    (to: 'bn', obj: ChannelState<any>): ChannelStateBN;
    (to: 'str', obj: ChannelState<any>): ChannelState;
    (to: 'bn-unsigned', obj: ChannelState<any> | UnsignedChannelState<any>): UnsignedChannelStateBN;
    (to: 'str-unsigned', obj: ChannelState<any> | UnsignedChannelState<any>): UnsignedChannelState;
}
export declare const convertChannelState: ConvertChannelStateOverloaded;
export declare const unsignedChannel: <T>(obj: UnsignedChannelState<T> | (UnsignedChannelState<T> & {
    sigUser: string;
    sigHub: string;
}) | (UnsignedChannelState<T> & {
    sigUser?: string | undefined;
    sigHub: string;
}) | (UnsignedChannelState<T> & {
    sigUser: string;
    sigHub?: string | undefined;
})) => UnsignedChannelState<T>;
export interface ConvertThreadStateOverloaded {
    (to: 'bn', obj: ThreadState<any>): ThreadStateBN;
    (to: 'str', obj: ThreadState<any>): ThreadState;
    (to: 'bn-unsigned', obj: ThreadState<any> | UnsignedThreadState<any>): UnsignedThreadStateBN;
    (to: 'str-unsigned', obj: ThreadState<any> | UnsignedThreadState<any>): UnsignedThreadState;
}
export declare const convertThreadState: ConvertThreadStateOverloaded;
export declare const unsignedThread: <T>(obj: UnsignedThreadState<T> | ThreadState<T>) => UnsignedThreadState<T>;
export declare const argNumericFields: {
    [Name in keyof UpdateArgTypes]: Array<keyof UpdateArgTypes[Name]>;
};
export interface ConvertPaymentOverloaded {
    <To extends NumericTypeName>(to: To, obj: PaymentArgs<any>): PaymentArgs<NumericTypes[To]>;
    <To extends NumericTypeName>(to: To, obj: Payment<any>): Payment<NumericTypes[To]>;
}
export declare const convertPayment: ConvertPaymentOverloaded;
export declare const convertWithdrawalParameters: <To extends "number" | "bn" | "str">(to: To, obj: WithdrawalParameters<any>) => WithdrawalParameters<NumericTypes[To]>;
export declare const convertThreadPayment: <To extends "number" | "bn" | "str">(to: To, obj: Payment<any>) => Payment<NumericTypes[To]>;
export declare const convertExchange: <To extends "number" | "bn" | "str">(to: To, obj: ExchangeArgs<any>) => ExchangeArgs<NumericTypes[To]>;
export declare const convertDeposit: <To extends "number" | "bn" | "str">(to: To, obj: DepositArgs<any>) => DepositArgs<NumericTypes[To]>;
export declare const convertWithdrawal: <To extends "number" | "bn" | "str">(to: To, obj: WithdrawalArgs<any>) => WithdrawalArgs<NumericTypes[To]>;
export declare const convertWithdrawalParams: <To extends "number" | "bn" | "str">(to: To, obj: WithdrawalParameters<any>) => WithdrawalParameters<NumericTypes[To]>;
export declare const proposePendingNumericArgs: string[];
export declare const convertProposePending: <To extends "number" | "bn" | "str">(to: To, obj: PendingArgs<any>) => PendingArgs<NumericTypes[To]>;
export declare const proposePendingExchangeNumericArgs: string[];
export declare const convertProposePendingExchange: <To extends "number" | "bn" | "str">(to: To, obj: PendingExchangeArgs<any>) => PendingExchangeArgs<NumericTypes[To]>;
export declare const convertArgs: <Reason extends "Payment" | "Exchange" | "ProposePendingDeposit" | "ProposePendingWithdrawal" | "ConfirmPending" | "Invalidation" | "EmptyChannel" | "OpenThread" | "CloseThread", To extends "number" | "bn" | "str">(to: To, reason: Reason, args: UpdateArgTypes<string>[Reason]) => UpdateArgTypes<To>[Reason];
export declare const paymentProfileNumericFields: string[];
export interface ConvertPaymentProfileOverloaded {
    (to: 'bn', obj: PaymentProfileConfig<any>): PaymentProfileConfigBN;
    (to: 'str', obj: PaymentProfileConfig<any>): PaymentProfileConfig;
}
export declare const convertPaymentProfile: ConvertPaymentProfileOverloaded;
export declare const convert: any;
