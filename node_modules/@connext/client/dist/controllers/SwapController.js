"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const cfCore_1 = require("../lib/cfCore");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
exports.calculateExchange = (amount, swapRate) => {
    return utils_1.bigNumberify(utils_1.formatEther(amount.mul(utils_1.parseEther(swapRate))).replace(/\.[0-9]*$/, ""));
};
class SwapController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.swapAppInstall = (amount, toAssetId, fromAssetId, swapRate, appInfo) => __awaiter(this, void 0, void 0, function* () {
            const swappedAmount = exports.calculateExchange(amount, swapRate);
            this.log.info(`Installing swap app. Swapping ${amount.toString()} of ${fromAssetId}` +
                ` for ${swappedAmount.toString()} of ${toAssetId}`);
            const initialState = {
                coinTransfers: [
                    [
                        {
                            amount,
                            to: this.connext.freeBalanceAddress,
                        },
                    ],
                    [
                        {
                            amount: swappedAmount,
                            to: cfCore_1.xpubToAddress(this.connext.nodePublicIdentifier),
                        },
                    ],
                ],
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding } = appInfo;
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: amount,
                initiatorDepositTokenAddress: fromAssetId,
                outcomeType: appInfo.outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: swappedAmount,
                responderDepositTokenAddress: toAssetId,
                timeout: constants_1.Zero,
            };
            const appInstanceId = yield this.proposeAndInstallLedgerApp(params);
            return appInstanceId;
        });
    }
    swap(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { amount, toAssetId, fromAssetId, swapRate } = types_1.convert.SwapParameters("bignumber", params);
            const preSwapFromBal = yield this.connext.getFreeBalance(fromAssetId);
            const userBal = preSwapFromBal[this.connext.freeBalanceAddress];
            const preSwapToBal = yield this.connext.getFreeBalance(toAssetId);
            const nodeBal = preSwapToBal[cfCore_1.xpubToAddress(this.connext.nodePublicIdentifier)];
            const swappedAmount = exports.calculateExchange(amount, swapRate);
            validation_1.validate(validation_1.invalidAddress(fromAssetId), validation_1.invalidAddress(toAssetId), validation_1.notLessThanOrEqualTo(amount, userBal), validation_1.notGreaterThan(amount, constants_1.Zero), validation_1.notLessThanOrEqualTo(swappedAmount, nodeBal), validation_1.notPositive(utils_1.parseEther(swapRate)));
            const appInfo = this.connext.getRegisteredAppDetails("SimpleTwoPartySwapApp");
            const appId = yield this.swapAppInstall(amount, toAssetId, fromAssetId, swapRate, appInfo);
            this.log.info(`Swap app installed! Uninstalling without updating state.`);
            yield this.connext.uninstallApp(appId);
            const postSwapFromBal = yield this.connext.getFreeBalance(fromAssetId);
            const postSwapToBal = yield this.connext.getFreeBalance(toAssetId);
            const diffFrom = preSwapFromBal[this.connext.freeBalanceAddress].sub(postSwapFromBal[this.connext.freeBalanceAddress]);
            const diffTo = postSwapToBal[this.connext.freeBalanceAddress].sub(preSwapToBal[this.connext.freeBalanceAddress]);
            if (!diffFrom.eq(amount) || !diffTo.eq(swappedAmount)) {
                throw new Error("Invalid final swap amounts - this shouldn't happen!!");
            }
            const newState = yield this.connext.getChannel();
            return newState;
        });
    }
}
exports.SwapController = SwapController;
//# sourceMappingURL=SwapController.js.map