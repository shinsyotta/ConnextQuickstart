"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class DepositController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.deposit = (params) => __awaiter(this, void 0, void 0, function* () {
            const myFreeBalanceAddress = this.connext.freeBalanceAddress;
            const { assetId, amount } = types_1.convert.Deposit("bignumber", params);
            let bal;
            if (assetId === constants_1.AddressZero) {
                bal = yield this.ethProvider.getBalance(myFreeBalanceAddress);
            }
            else {
                const token = new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider);
                bal = yield token.balanceOf(myFreeBalanceAddress);
            }
            validation_1.validate(validation_1.invalidAddress(assetId), validation_1.notPositive(amount), validation_1.notLessThanOrEqualTo(amount, bal));
            const preDepositBalances = yield this.connext.getFreeBalance(assetId);
            this.log.info(`\nDepositing ${amount} of ${assetId} into ${this.connext.multisigAddress}\n`);
            const appId = yield this.proposeDepositInstall(assetId);
            this.log.debug(`Coin balance refund app proposed with id: ${appId}`);
            try {
                this.log.info(`Calling ${types_1.CFCoreTypes.RpcMethodNames.chan_deposit}`);
                yield this.connext.rescindDepositRights({ assetId });
                const depositResponse = yield this.connext.providerDeposit(amount, assetId);
                this.log.info(`Deposit Response: ${lib_1.stringify(depositResponse)}`);
                const postDepositBalances = yield this.connext.getFreeBalance(assetId);
                const diff = postDepositBalances[myFreeBalanceAddress].sub(preDepositBalances[myFreeBalanceAddress]);
                if (diff.lt(amount)) {
                    throw new Error("My balance was not increased by the deposit amount.");
                }
                this.log.info("Deposited!");
            }
            catch (e) {
                this.log.error(`Failed to deposit: ${e.stack || e.message}`);
                throw e;
            }
            return {
                apps: yield this.connext.getAppInstances(this.connext.multisigAddress),
                freeBalance: yield this.connext.getFreeBalance(assetId),
            };
        });
        this.proposeDepositInstall = (assetId) => __awaiter(this, void 0, void 0, function* () {
            const threshold = assetId === constants_1.AddressZero
                ? yield this.ethProvider.getBalance(this.connext.multisigAddress)
                : yield new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.connext.multisigAddress);
            const initialState = {
                multisig: this.connext.multisigAddress,
                recipient: this.connext.freeBalanceAddress,
                threshold,
                tokenAddress: assetId,
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding, outcomeType, } = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.CoinBalanceRefundApp);
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: constants_1.Zero,
                initiatorDepositTokenAddress: assetId,
                outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
            };
            const appId = yield this.proposeAndWaitForAccepted(params);
            return appId;
        });
    }
}
exports.DepositController = DepositController;
//# sourceMappingURL=DepositController.js.map