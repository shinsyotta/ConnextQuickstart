"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const loglevel_1 = __importDefault(require("loglevel"));
const rpc_server_1 = require("rpc-server");
const contracts_1 = require("../../../contracts");
const xkeys_1 = require("../../../machine/xkeys");
const types_1 = require("../../../types");
const utils_2 = require("../../../utils");
const controller_1 = require("../../controller");
const errors_1 = require("../../errors");
const CREATE_PROXY_AND_SETUP_GAS = 500000;
class DeployStateDepositHolderController extends controller_1.NodeController {
    constructor() {
        super(...arguments);
        this.executeMethod = super.executeMethod;
    }
    async beforeExecution(requestHandler, params) {
        const { store, provider, networkContext } = requestHandler;
        const { multisigAddress } = params;
        const channel = await store.getStateChannel(multisigAddress);
        if (!channel.proxyFactoryAddress) {
            throw Error(errors_1.INVALID_FACTORY_ADDRESS(channel.proxyFactoryAddress));
        }
        const expectedMultisigAddress = await utils_2.getCreate2MultisigAddress(channel.userNeuteredExtendedKeys, channel.proxyFactoryAddress, networkContext.MinimumViableMultisig, provider);
        if (expectedMultisigAddress !== channel.multisigAddress) {
            throw Error(errors_1.INCORRECT_MULTISIG_ADDRESS);
        }
    }
    async executeMethodImplementation(requestHandler, params) {
        const { multisigAddress, retryCount } = params;
        const { networkContext, store, provider, wallet } = requestHandler;
        let tx = { hash: constants_1.HashZero };
        const channel = await store.getStateChannel(multisigAddress);
        const expectedMultisigAddress = await utils_2.getCreate2MultisigAddress(channel.userNeuteredExtendedKeys, channel.proxyFactoryAddress, networkContext.MinimumViableMultisig, provider);
        if (expectedMultisigAddress !== channel.multisigAddress) {
            throw Error(errors_1.INCORRECT_MULTISIG_ADDRESS);
        }
        if ((await provider.getCode(multisigAddress)) === "0x") {
            tx = await sendMultisigDeployTx(wallet, channel, networkContext, retryCount);
        }
        return { transactionHash: tx.hash };
    }
}
__decorate([
    rpc_server_1.jsonRpcMethod(types_1.CFCoreTypes.RpcMethodNames.chan_deployStateDepositHolder),
    __metadata("design:type", Object)
], DeployStateDepositHolderController.prototype, "executeMethod", void 0);
exports.default = DeployStateDepositHolderController;
async function sendMultisigDeployTx(signer, stateChannel, networkContext, retryCount = 1) {
    const proxyFactory = new ethers_1.Contract(stateChannel.proxyFactoryAddress, contracts_1.ProxyFactory.abi, signer);
    const owners = stateChannel.userNeuteredExtendedKeys;
    const provider = signer.provider;
    if (!provider) {
        throw Error("wallet must have a provider");
    }
    const signerAddress = await signer.getAddress();
    const nonce = await provider.getTransactionCount(signerAddress);
    let error;
    for (let tryCount = 1; tryCount < retryCount + 1; tryCount += 1) {
        try {
            const tx = await proxyFactory.functions.createProxyWithNonce(networkContext.MinimumViableMultisig, new utils_1.Interface(contracts_1.MinimumViableMultisig.abi).functions.setup.encode([
                xkeys_1.xkeysToSortedKthAddresses(owners, 0)
            ]), 0, {
                gasLimit: CREATE_PROXY_AND_SETUP_GAS,
                gasPrice: provider.getGasPrice(),
                nonce
            });
            if (!tx.hash) {
                throw Error(`${errors_1.NO_TRANSACTION_HASH_FOR_MULTISIG_DEPLOYMENT}: ${utils_2.prettyPrintObject(tx)}`);
            }
            const ownersAreCorrectlySet = await checkForCorrectOwners(tx, provider, owners, stateChannel.multisigAddress);
            if (!ownersAreCorrectlySet) {
                loglevel_1.default.error(`${errors_1.CHANNEL_CREATION_FAILED}: Could not confirm, on the ${tryCount} try, that the deployed multisig contract has the expected owners`);
                await utils_2.sleep(1000 * tryCount);
                continue;
            }
            if (tryCount > 0) {
                loglevel_1.default.debug(`Deploying multisig failed on first try, but succeeded on try #${tryCount}`);
            }
            return tx;
        }
        catch (e) {
            error = e;
            loglevel_1.default.error(`Channel creation attempt ${tryCount} failed: ${e}.\n
                    Retrying ${retryCount - tryCount} more times`);
        }
    }
    throw Error(`${errors_1.CHANNEL_CREATION_FAILED}: ${utils_2.prettyPrintObject(error)}`);
}
async function checkForCorrectOwners(tx, provider, xpubs, multisigAddress) {
    await tx.wait();
    const contract = new ethers_1.Contract(multisigAddress, contracts_1.MinimumViableMultisig.abi, provider);
    const expectedOwners = xkeys_1.xkeysToSortedKthAddresses(xpubs, 0);
    const actualOwners = xkeys_1.sortAddresses(await contract.functions.getOwners());
    return (expectedOwners[0] === actualOwners[0] &&
        expectedOwners[1] === actualOwners[1]);
}
//# sourceMappingURL=controller.js.map