"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const machine_1 = require("../../../machine");
const errors_1 = require("../../errors");
async function installVirtual(store, protocolRunner, params) {
    const { appInstanceId, intermediaryIdentifier } = params;
    if (!appInstanceId || !appInstanceId.trim()) {
        throw Error(errors_1.NO_APP_INSTANCE_ID_TO_INSTALL);
    }
    const proposal = await store.getAppInstanceProposal(appInstanceId);
    const { abiEncodings, appDefinition, initialState, initiatorDeposit, initiatorDepositTokenAddress, outcomeType, proposedByIdentifier, proposedToIdentifier, responderDeposit, responderDepositTokenAddress, timeout, } = proposal;
    if (initiatorDepositTokenAddress !== responderDepositTokenAddress) {
        throw Error("Cannot install virtual app with different token addresses");
    }
    try {
        await protocolRunner.initiateProtocol(machine_1.Protocol.InstallVirtualApp, await store.getStateChannelsMap(), {
            appInterface: Object.assign({ addr: appDefinition }, abiEncodings),
            appSeqNo: proposal.appSeqNo,
            defaultTimeout: utils_1.bigNumberify(timeout).toNumber(),
            initialState,
            initiatorBalanceDecrement: utils_1.bigNumberify(initiatorDeposit),
            initiatorXpub: proposedToIdentifier,
            intermediaryXpub: intermediaryIdentifier,
            outcomeType,
            responderBalanceDecrement: utils_1.bigNumberify(responderDeposit),
            responderXpub: proposedByIdentifier,
            tokenAddress: initiatorDepositTokenAddress,
        });
    }
    catch (e) {
        throw Error(`Node Error: ${errors_1.VIRTUAL_APP_INSTALLATION_FAIL}\nStack Trace: ${e.stack}`);
    }
    await store.saveStateChannel((await store.getChannelFromAppInstanceID(appInstanceId)).removeProposal(appInstanceId));
    return proposal;
}
exports.installVirtual = installVirtual;
//# sourceMappingURL=operation.js.map