"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
const lib_1 = require("../lib");
const types_1 = require("../types");
const validation_1 = require("../validation");
const AbstractController_1 = require("./AbstractController");
class RequestDepositRightsController extends AbstractController_1.AbstractController {
    constructor() {
        super(...arguments);
        this.requestDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            params.assetId = params.assetId || constants_1.AddressZero;
            const { assetId } = params;
            validation_1.validate(validation_1.invalidAddress(assetId));
            let multisigBalance;
            if (assetId === constants_1.AddressZero) {
                multisigBalance = yield this.connext.ethProvider.getBalance(this.connext.multisigAddress);
            }
            else {
                const token = new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.connext.ethProvider);
                multisigBalance = yield token.balanceOf(this.connext.multisigAddress);
            }
            const { collateralizationInFlight } = yield this.node.getChannel();
            if (collateralizationInFlight) {
                throw new Error(`Cannot claim deposit rights while hub is depositing.`);
            }
            const existingBalanceRefundApp = yield this.connext.getBalanceRefundApp(assetId);
            if (existingBalanceRefundApp) {
                if (utils_1.bigNumberify(existingBalanceRefundApp.latestState["threshold"]).eq(multisigBalance) &&
                    existingBalanceRefundApp.latestState["recipient"] === this.connext.freeBalanceAddress) {
                    this.log.info(`Balance refund app for ${assetId} is in the correct state, doing nothing`);
                    return {
                        freeBalance: yield this.connext.getFreeBalance(assetId),
                        recipient: this.connext.freeBalanceAddress,
                        tokenAddress: assetId,
                    };
                }
                this.log.info(`Balance refund app is not in the correct state, uninstalling first`);
                yield this.connext.rescindDepositRights(assetId);
                this.log.info(`Balance refund app uninstalled`);
            }
            this.log.info(`Installing balance refund app for ${assetId}`);
            const err = yield this.proposeDepositInstall(assetId);
            if (err) {
                throw new Error(err);
            }
            const requestDepositRightsResponse = yield this.connext.channelRouter.requestDepositRights(assetId);
            this.log.info(`requestDepositRightsResponse Response: ${lib_1.stringify(requestDepositRightsResponse)}`);
            this.log.info(`Deposit rights gained for ${assetId}`);
            const freeBalance = yield this.connext.getFreeBalance(assetId);
            this.listener.emit(`indra.client.${this.connext.publicIdentifier}.freeBalanceUpdated`, {
                freeBalance,
            });
            return {
                freeBalance,
                recipient: this.connext.freeBalanceAddress,
                tokenAddress: assetId,
            };
        });
        this.registerListeners = (assetId = constants_1.AddressZero) => {
            if (assetId === constants_1.AddressZero) {
                this.ethProvider.on(this.connext.multisigAddress, (balance) => __awaiter(this, void 0, void 0, function* () {
                    this.log.info(`Got a transfer to multisig. balance: ${balance}`);
                    if (balance.isZero()) {
                        this.log.info(`Multisig transfer has 0 balance, not uninstalling`);
                        return;
                    }
                    yield this.connext.rescindDepositRights(constants_1.AddressZero);
                    const freeBalance = yield this.connext.getFreeBalance(constants_1.AddressZero);
                    this.log.info(`updated FreeBalance: ${lib_1.stringify(freeBalance)}`);
                }));
            }
            else {
                this.connext.token.on("Transfer", (src, dst, wad) => __awaiter(this, void 0, void 0, function* () {
                    if (utils_1.getAddress(dst) !== this.connext.multisigAddress) {
                        return;
                    }
                    this.log.info(`Got a transfer to multisig. src: ${src}, dst: ${dst}, wad: ${wad}`);
                    if (utils_1.getAddress(src) === lib_1.xpubToAddress(this.connext.nodePublicIdentifier)) {
                        this.log.info(`Transfer from node, not uninstalling balance refund app`);
                        return;
                    }
                    this.log.info(`Uninstalling balance refund app`);
                    yield this.connext.rescindDepositRights(this.connext.config.contractAddresses.Token);
                    const freeBalance = yield this.connext.getFreeBalance(this.connext.config.contractAddresses.Token);
                    this.log.info(`updated FreeBalance: ${lib_1.stringify(freeBalance)}`);
                }));
            }
        };
        this.cleanupListeners = (assetId = constants_1.AddressZero) => {
            if (assetId === constants_1.AddressZero) {
                this.log.info(`Removing all eth provider listeners for multisig`);
                this.ethProvider.removeAllListeners(this.connext.multisigAddress);
            }
            else {
                this.log.info(`Removing all token transfer listeners`);
                this.connext.token.removeAllListeners("Transfer");
            }
        };
        this.proposeDepositInstall = (assetId) => __awaiter(this, void 0, void 0, function* () {
            let boundReject;
            const threshold = assetId === constants_1.AddressZero
                ? yield this.ethProvider.getBalance(this.connext.multisigAddress)
                : yield new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.connext.multisigAddress);
            const initialState = {
                multisig: this.connext.multisigAddress,
                recipient: this.connext.freeBalanceAddress,
                threshold,
                tokenAddress: assetId,
            };
            const { actionEncoding, appDefinitionAddress: appDefinition, stateEncoding, outcomeType, } = this.connext.getRegisteredAppDetails(types_1.SupportedApplications.CoinBalanceRefundApp);
            const params = {
                abiEncodings: {
                    actionEncoding,
                    stateEncoding,
                },
                appDefinition,
                initialState,
                initiatorDeposit: constants_1.Zero,
                initiatorDepositTokenAddress: assetId,
                outcomeType,
                proposedToIdentifier: this.connext.nodePublicIdentifier,
                responderDeposit: constants_1.Zero,
                responderDepositTokenAddress: assetId,
                timeout: constants_1.Zero,
            };
            let appId;
            try {
                yield Promise.race([
                    new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                        boundReject = this.rejectInstallCoinBalance.bind(null, rej);
                        this.log.info(`subscribing to indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`);
                        yield this.connext.messaging.subscribe(`indra.node.${this.connext.nodePublicIdentifier}.proposalAccepted.${this.connext.multisigAddress}`, res);
                        const { appInstanceId } = yield this.connext.proposeInstallApp(params);
                        appId = appInstanceId;
                        this.log.info(`waiting for proposal acceptance of ${appInstanceId}`);
                        this.listener.on(types_1.CFCoreTypes.EventName.REJECT_INSTALL, boundReject);
                    })),
                    lib_1.delayAndThrow(lib_1.CF_METHOD_TIMEOUT, `App install took longer than ${lib_1.CF_METHOD_TIMEOUT / 1000} seconds`),
                ]);
                this.log.info(`App was proposed successfully!: ${appId}`);
                return undefined;
            }
            catch (e) {
                this.log.error(`Error installing app: ${e.toString()}`);
                return e.message;
            }
            finally {
                this.cleanupInstallListeners(appId, boundReject);
            }
        });
        this.rejectInstallCoinBalance = (rej, msg) => {
            return rej(`Install failed. Event data: ${lib_1.stringify(msg)}`);
        };
        this.cleanupInstallListeners = (appId, boundReject) => {
            this.connext.messaging.unsubscribe(`indra.node.${this.connext.nodePublicIdentifier}.install.${appId}`);
            this.listener.removeListener(types_1.CFCoreTypes.EventName.REJECT_INSTALL_VIRTUAL, boundReject);
        };
    }
}
exports.RequestDepositRightsController = RequestDepositRightsController;
//# sourceMappingURL=RequestDepositRightsController.js.map