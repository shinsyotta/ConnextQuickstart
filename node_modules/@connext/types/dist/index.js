'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('ethers/utils');
var constants = require('ethers/constants');

const SupportedApplications = {
    CoinBalanceRefundApp: "CoinBalanceRefundApp",
    SimpleLinkedTransferApp: "SimpleLinkedTransferApp",
    SimpleTransferApp: "SimpleTransferApp",
    SimpleTwoPartySwapApp: "SimpleTwoPartySwapApp",
};
const SupportedNetworks = {
    ganache: "ganache",
    goerli: "goerli",
    homestead: "homestead",
    kovan: "kovan",
    rinkeby: "rinkeby",
    ropsten: "ropsten",
};
(function (UnidirectionalTransferAppActionType) {
    UnidirectionalTransferAppActionType[UnidirectionalTransferAppActionType["SEND_MONEY"] = 0] = "SEND_MONEY";
    UnidirectionalTransferAppActionType[UnidirectionalTransferAppActionType["END_CHANNEL"] = 1] = "END_CHANNEL";
})(exports.UnidirectionalTransferAppActionType || (exports.UnidirectionalTransferAppActionType = {}));
(function (UnidirectionalTransferAppStage) {
    UnidirectionalTransferAppStage[UnidirectionalTransferAppStage["POST_FUND"] = 0] = "POST_FUND";
    UnidirectionalTransferAppStage[UnidirectionalTransferAppStage["MONEY_SENT"] = 1] = "MONEY_SENT";
    UnidirectionalTransferAppStage[UnidirectionalTransferAppStage["CHANNEL_CLOSED"] = 2] = "CHANNEL_CLOSED";
})(exports.UnidirectionalTransferAppStage || (exports.UnidirectionalTransferAppStage = {}));
(function (UnidirectionalLinkedTransferAppStage) {
    UnidirectionalLinkedTransferAppStage[UnidirectionalLinkedTransferAppStage["POST_FUND"] = 0] = "POST_FUND";
    UnidirectionalLinkedTransferAppStage[UnidirectionalLinkedTransferAppStage["PAYMENT_CLAIMED"] = 1] = "PAYMENT_CLAIMED";
    UnidirectionalLinkedTransferAppStage[UnidirectionalLinkedTransferAppStage["CHANNEL_CLOSED"] = 2] = "CHANNEL_CLOSED";
})(exports.UnidirectionalLinkedTransferAppStage || (exports.UnidirectionalLinkedTransferAppStage = {}));

const multiAssetMultiPartyCoinTransferInterpreterParamsEncoding = `tuple(uint256[] limit, address[] tokenAddresses)`;
const singleAssetTwoPartyCoinTransferInterpreterParamsEncoding = `tuple(uint256 limit, address tokenAddress)`;
const twoPartyFixedOutcomeInterpreterParamsEncoding = `tuple(address[2] playerAddrs, uint256 amount)`;
const virtualAppAgreementEncoding = `tuple(uint256 capitalProvided, address capitalProvider, address virtualAppUser, address tokenAddress)`;
const multiAssetMultiPartyCoinTransferEncoding = `tuple(address to, uint256 amount)[][]`;
const coinBalanceRefundStateEncoding = `tuple(address recipient, address multisig, uint256 threshold, address tokenAddress)`;
(function (OutcomeType) {
    OutcomeType["TWO_PARTY_FIXED_OUTCOME"] = "TWO_PARTY_FIXED_OUTCOME";
    OutcomeType["MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER"] = "MULTI_ASSET_MULTI_PARTY_COIN_TRANSFER";
    OutcomeType["SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER"] = "SINGLE_ASSET_TWO_PARTY_COIN_TRANSFER";
})(exports.OutcomeType || (exports.OutcomeType = {}));
(function (TwoPartyFixedOutcome) {
    TwoPartyFixedOutcome[TwoPartyFixedOutcome["SEND_TO_ADDR_ONE"] = 0] = "SEND_TO_ADDR_ONE";
    TwoPartyFixedOutcome[TwoPartyFixedOutcome["SEND_TO_ADDR_TWO"] = 1] = "SEND_TO_ADDR_TWO";
    TwoPartyFixedOutcome[TwoPartyFixedOutcome["SPLIT_AND_SEND_TO_BOTH_ADDRS"] = 2] = "SPLIT_AND_SEND_TO_BOTH_ADDRS";
})(exports.TwoPartyFixedOutcome || (exports.TwoPartyFixedOutcome = {}));

(function (CFCoreTypes) {
    let ErrorType;
    (function (ErrorType) {
        ErrorType["ERROR"] = "error";
    })(ErrorType = CFCoreTypes.ErrorType || (CFCoreTypes.ErrorType = {}));
    let MethodName;
    (function (MethodName) {
        MethodName["ACCEPT_STATE"] = "acceptState";
        MethodName["GET_PROPOSED_APP_INSTANCE"] = "getProposedAppInstance";
    })(MethodName = CFCoreTypes.MethodName || (CFCoreTypes.MethodName = {}));
    CFCoreTypes.RpcMethodNames = {
        chan_create: "chan_create",
        chan_deposit: "chan_deposit",
        chan_deployStateDepositHolder: "chan_deployStateDepositHolder",
        chan_getChannelAddresses: "chan_getChannelAddresses",
        chan_getAppInstance: "chan_getAppInstance",
        chan_getAppInstances: "chan_getAppInstances",
        chan_getStateDepositHolderAddress: "chan_getStateDepositHolderAddress",
        chan_getFreeBalanceState: "chan_getFreeBalanceState",
        chan_getTokenIndexedFreeBalanceStates: "chan_getTokenIndexedFreeBalanceStates",
        chan_getProposedAppInstances: "chan_getProposedAppInstances",
        chan_getState: "chan_getState",
        chan_getStateChannel: "chan_getStateChannel",
        chan_install: "chan_install",
        chan_requestDepositRights: "chan_requestDepositRights",
        chan_installVirtual: "chan_installVirtual",
        chan_proposeInstall: "chan_proposeInstall",
        chan_rejectInstall: "chan_rejectInstall",
        chan_updateState: "chan_updateState",
        chan_takeAction: "chan_takeAction",
        chan_uninstall: "chan_uninstall",
        chan_uninstallVirtual: "chan_uninstallVirtual",
        chan_rescindDepositRights: "chan_rescindDepositRights",
        chan_withdraw: "chan_withdraw",
        chan_withdrawCommitment: "chan_withdrawCommitment"
    };
    CFCoreTypes.EventNames = {
        CREATE_CHANNEL_EVENT: "CREATE_CHANNEL_EVENT",
        DEPOSIT_CONFIRMED_EVENT: "DEPOSIT_CONFIRMED_EVENT",
        DEPOSIT_FAILED_EVENT: "DEPOSIT_FAILED_EVENT",
        DEPOSIT_STARTED_EVENT: "DEPOSIT_STARTED_EVENT",
        INSTALL_EVENT: "INSTALL_EVENT",
        INSTALL_VIRTUAL_EVENT: "INSTALL_VIRTUAL_EVENT",
        REJECT_INSTALL_EVENT: "REJECT_INSTALL_EVENT",
        UNINSTALL_EVENT: "UNINSTALL_EVENT",
        UNINSTALL_VIRTUAL_EVENT: "UNINSTALL_VIRTUAL_EVENT",
        UPDATE_STATE_EVENT: "UPDATE_STATE_EVENT",
        WITHDRAWAL_CONFIRMED_EVENT: "WITHDRAWAL_CONFIRMED_EVENT",
        WITHDRAWAL_FAILED_EVENT: "WITHDRAWAL_FAILED_EVENT",
        WITHDRAWAL_STARTED_EVENT: "WITHDRAWAL_STARTED_EVENT",
        PROPOSE_INSTALL_EVENT: "PROPOSE_INSTALL_EVENT",
        PROTOCOL_MESSAGE_EVENT: "PROTOCOL_MESSAGE_EVENT"
    };
})(exports.CFCoreTypes || (exports.CFCoreTypes = {}));

const CF_PATH = "m/44'/60'/0'/25446";
const EXPECTED_CONTRACT_NAMES_IN_NETWORK_CONTEXT = [
    "ChallengeRegistry",
    "ConditionalTransactionDelegateTarget",
    "CoinBalanceRefundApp",
    "MultiAssetMultiPartyCoinTransferInterpreter",
    "IdentityApp",
    "MinimumViableMultisig",
    "ProxyFactory",
    "SingleAssetTwoPartyCoinTransferInterpreter",
    "TimeLockedPassThrough",
    "TwoPartyFixedOutcomeInterpreter",
    "TwoPartyFixedOutcomeFromVirtualAppInterpreter"
];

const BigNumber = utils.BigNumber;
const ConnextEvents = Object.assign({}, exports.CFCoreTypes.EventNames, { RECIEVE_TRANSFER_FAILED_EVENT: "RECIEVE_TRANSFER_FAILED_EVENT", RECIEVE_TRANSFER_FINISHED_EVENT: "RECIEVE_TRANSFER_FINISHED_EVENT", RECIEVE_TRANSFER_STARTED_EVENT: "RECIEVE_TRANSFER_STARTED_EVENT" });
const ConnextNodeStorePrefix = "INDRA_NODE_CF_CORE";
const ConnextClientStorePrefix = "INDRA_CLIENT_CF_CORE";

const ConnextRpcMethods = {
    chan_config: "chan_config",
    chan_nodeAuth: "chan_nodeAuth",
    chan_restoreState: "chan_restoreState",
    chan_storeGet: "chan_storeGet",
    chan_storeSet: "chan_storeSet",
};
const ChannelProviderRpcMethods = Object.assign({}, exports.CFCoreTypes.RpcMethodNames, ConnextRpcMethods);

const getType = (input) => {
    if (typeof input === "string")
        return "str";
    if (utils.BigNumber.isBigNumber(input))
        return "bignumber";
    if (typeof input === "number")
        return "number";
    throw new Error(`Unknown input type: ${typeof input}, value: ${JSON.stringify(input)}`);
};
const castFunctions = {
    "bignumber-str": (x) => x.toString(),
    "number-bignumber": (x) => new utils.BigNumber(x),
    "number-str": (x) => x.toString(),
    "str-bignumber": (x) => new utils.BigNumber(x),
};
const convertFields = (fromType, toType, fields, input) => {
    if (fromType === toType)
        return input;
    if (toType === "number") {
        throw new Error("Should not convert fields to numbers");
    }
    let key;
    if (fromType === "number" && toType === "str") {
        key = `bignumber-str`;
    }
    else if (fromType === "number") {
        key = `str-${toType}`;
    }
    const cast = castFunctions[key || [fromType, toType].join("-")];
    if (!cast)
        throw new Error(`No castFunc for ${fromType} -> ${toType}`);
    const res = Object.assign({}, input);
    for (const field of fields) {
        const name = field.split("?")[0];
        const isOptional = field.endsWith("?");
        if (isOptional && !(name in input))
            continue;
        res[name] = cast(input[name]);
    }
    return res;
};
function makeChecksum(address) {
    try {
        return utils.getAddress(address);
    }
    catch (e) {
        console.log(`Caught error converting address, returning original input value (${address}). Error: ${JSON.stringify(e, null, 2)}`);
        return address;
    }
}
function makeChecksumOrEthAddress(address) {
    if (!address) {
        return constants.AddressZero;
    }
    return makeChecksum(address);
}
function convertAmountField(to, obj) {
    const fromType = getType(obj.amount);
    return convertFields(fromType, to, ["amount"], obj);
}
function convertAssetAmount(to, obj) {
    return convertAmountField(to, obj);
}
function convertAssetAmountWithId(to, obj) {
    const asset = Object.assign({}, obj, { assetId: makeChecksumOrEthAddress(obj.assetId) });
    return convertAssetAmount(to, asset);
}
function convertPaymentProfile(to, obj) {
    const fromType = getType(obj.amountToCollateralize);
    return convertFields(fromType, to, ["amountToCollateralize", "minimumMaintainedCollateral"], obj);
}
function convertCoinBalanceRefund(to, obj) {
    const fromType = getType(obj.threshold);
    return convertFields(fromType, to, ["threshold"], obj);
}
function convertDepositParametersToAsset(to, obj) {
    return convertAssetAmountWithId(to, obj);
}
function convertSwapParameters(to, obj) {
    const asset = Object.assign({}, obj, { fromAssetId: makeChecksumOrEthAddress(obj.fromAssetId), toAssetId: makeChecksumOrEthAddress(obj.toAssetId) });
    return convertAmountField(to, asset);
}
function convertTransferParametersToAsset(to, obj) {
    return convertAssetAmountWithId(to, obj);
}
function convertLinkedTransferParametersToAsset(to, obj) {
    return convertAssetAmountWithId(to, obj);
}
function convertLinkedTransferToRecipientParametersToAsset(to, obj) {
    return convertAssetAmountWithId(to, obj);
}
function convertWithdrawParametersToAsset(to, obj) {
    return convertAssetAmountWithId(to, obj);
}
function convertAppState(to, obj) {
    return Object.assign({}, obj, { coinTransfers: [
            convertAmountField(to, obj.coinTransfers[0]),
            convertAmountField(to, obj.coinTransfers[1]),
        ] });
}
function convertLinkedTransferAppState(to, obj) {
    return Object.assign({}, convertAmountField(to, obj), { coinTransfers: [
            convertAmountField(to, obj.coinTransfers[0]),
            convertAmountField(to, obj.coinTransfers[1]),
        ] });
}
const convert = {
    AppState: convertAppState,
    Asset: convertAssetAmount,
    CoinBalanceRefundApp: convertCoinBalanceRefund,
    Deposit: convertDepositParametersToAsset,
    LinkedTransfer: convertLinkedTransferParametersToAsset,
    LinkedTransferAppState: convertLinkedTransferAppState,
    LinkedTransferToRecipient: convertLinkedTransferToRecipientParametersToAsset,
    PaymentProfile: convertPaymentProfile,
    ResolveLinkedTransfer: convertAssetAmountWithId,
    SimpleTransferAppState: convertAppState,
    SwapAppState: convertAppState,
    SwapParameters: convertSwapParameters,
    Transfer: convertAssetAmount,
    TransferParameters: convertTransferParametersToAsset,
    Withdraw: convertWithdrawParametersToAsset,
};

const TransferConditions = {
    LINKED_TRANSFER: "LINKED_TRANSFER",
    LINKED_TRANSFER_TO_RECIPIENT: "LINKED_TRANSFER_TO_RECIPIENT",
};

exports.BigNumber = BigNumber;
exports.CF_PATH = CF_PATH;
exports.ChannelProviderRpcMethods = ChannelProviderRpcMethods;
exports.ConnextClientStorePrefix = ConnextClientStorePrefix;
exports.ConnextEvents = ConnextEvents;
exports.ConnextNodeStorePrefix = ConnextNodeStorePrefix;
exports.ConnextRpcMethods = ConnextRpcMethods;
exports.EXPECTED_CONTRACT_NAMES_IN_NETWORK_CONTEXT = EXPECTED_CONTRACT_NAMES_IN_NETWORK_CONTEXT;
exports.SupportedApplications = SupportedApplications;
exports.SupportedNetworks = SupportedNetworks;
exports.TransferConditions = TransferConditions;
exports.coinBalanceRefundStateEncoding = coinBalanceRefundStateEncoding;
exports.convert = convert;
exports.convertAmountField = convertAmountField;
exports.convertAppState = convertAppState;
exports.convertAssetAmount = convertAssetAmount;
exports.convertAssetAmountWithId = convertAssetAmountWithId;
exports.convertCoinBalanceRefund = convertCoinBalanceRefund;
exports.convertDepositParametersToAsset = convertDepositParametersToAsset;
exports.convertFields = convertFields;
exports.convertLinkedTransferAppState = convertLinkedTransferAppState;
exports.convertLinkedTransferParametersToAsset = convertLinkedTransferParametersToAsset;
exports.convertLinkedTransferToRecipientParametersToAsset = convertLinkedTransferToRecipientParametersToAsset;
exports.convertPaymentProfile = convertPaymentProfile;
exports.convertSwapParameters = convertSwapParameters;
exports.convertTransferParametersToAsset = convertTransferParametersToAsset;
exports.convertWithdrawParametersToAsset = convertWithdrawParametersToAsset;
exports.makeChecksum = makeChecksum;
exports.makeChecksumOrEthAddress = makeChecksumOrEthAddress;
exports.multiAssetMultiPartyCoinTransferEncoding = multiAssetMultiPartyCoinTransferEncoding;
exports.multiAssetMultiPartyCoinTransferInterpreterParamsEncoding = multiAssetMultiPartyCoinTransferInterpreterParamsEncoding;
exports.singleAssetTwoPartyCoinTransferInterpreterParamsEncoding = singleAssetTwoPartyCoinTransferInterpreterParamsEncoding;
exports.twoPartyFixedOutcomeInterpreterParamsEncoding = twoPartyFixedOutcomeInterpreterParamsEncoding;
exports.virtualAppAgreementEncoding = virtualAppAgreementEncoding;
