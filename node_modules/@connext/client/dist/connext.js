"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
require("core-js/stable");
const ethers_1 = require("ethers");
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const hdnode_1 = require("ethers/utils/hdnode");
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
require("regenerator-runtime/runtime");
const channelProvider_1 = require("./channelProvider");
const ConditionalTransferController_1 = require("./controllers/ConditionalTransferController");
const DepositController_1 = require("./controllers/DepositController");
const RequestDepositRightsController_1 = require("./controllers/RequestDepositRightsController");
const ResolveConditionController_1 = require("./controllers/ResolveConditionController");
const SwapController_1 = require("./controllers/SwapController");
const WithdrawalController_1 = require("./controllers/WithdrawalController");
const lib_1 = require("./lib");
const crypto_1 = require("./lib/crypto");
const listener_1 = require("./listener");
const types_2 = require("./types");
const addresses_1 = require("./validation/addresses");
const bn_1 = require("./validation/bn");
const MAX_WITHDRAWAL_RETRIES = 3;
class ConnextClient {
    constructor(opts) {
        this.isAvailable = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const channelIsAvailable = () => __awaiter(this, void 0, void 0, function* () {
                    const chan = yield this.node.getChannel();
                    return chan && chan.available;
                });
                while (!(yield channelIsAvailable())) {
                    yield new Promise((res) => setTimeout(() => res(), 100));
                }
                resolve();
            }));
        });
        this.getBalanceRefundApp = (assetId = constants_1.AddressZero) => __awaiter(this, void 0, void 0, function* () {
            const apps = yield this.getAppInstances(this.multisigAddress);
            const filtered = apps.filter((app) => app.appInterface.addr === this.config.contractAddresses.CoinBalanceRefundApp &&
                app.latestState["tokenAddress"] === assetId);
            return filtered.length === 0 ? undefined : filtered[0];
        });
        this.registerSubscriptions = () => __awaiter(this, void 0, void 0, function* () {
            yield this.listener.register();
        });
        this.restart = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.channelProvider.isSigner) {
                this.log.warn(`Cannot restart with an injected provider.`);
                return;
            }
            const channelProvider = yield channelProvider_1.createCFChannelProvider({
                ethProvider: this.ethProvider,
                keyGen: this.keyGen,
                lockService: { acquireLock: this.node.acquireLock.bind(this.node) },
                messaging: this.messaging,
                networkContext: this.config.contractAddresses,
                nodeConfig: { STORE_KEY_PREFIX: types_2.ConnextClientStorePrefix },
                nodeUrl: this.channelProvider.config.nodeUrl,
                store: this.store,
                xpub: this.publicIdentifier,
            });
            channelProvider.multisigAddress = this.multisigAddress;
            this.node.channelProvider = channelProvider;
            this.channelProvider = channelProvider;
            this.listener = new listener_1.ConnextListener(channelProvider, this);
            yield this.isAvailable();
        });
        this.getChannel = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getChannel();
        });
        this.requestCollateral = (tokenAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.requestCollateral(tokenAddress);
        });
        this.setRecipientAndEncryptedPreImageForLinkedTransfer = (recipient, encryptedPreImage, linkedHash) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.setRecipientAndEncryptedPreImageForLinkedTransfer(recipient, encryptedPreImage, linkedHash);
        });
        this.channelProviderConfig = () => __awaiter(this, void 0, void 0, function* () {
            return this.channelProvider.config;
        });
        this.getLinkedTransfer = (paymentId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.fetchLinkedTransfer(paymentId);
        });
        this.getAppRegistry = (appDetails) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.appRegistry(appDetails);
        });
        this.createChannel = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.createChannel();
        });
        this.subscribeToSwapRates = (from, to, callback) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.subscribeToSwapRates(from, to, callback);
        });
        this.getLatestSwapRate = (from, to) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getLatestSwapRate(from, to);
        });
        this.unsubscribeToSwapRates = (from, to) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.unsubscribeFromSwapRates(from, to);
        });
        this.addPaymentProfile = (profile) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.addPaymentProfile(profile);
        });
        this.getPaymentProfile = (assetId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getPaymentProfile(assetId);
        });
        this.getTransferHistory = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.getTransferHistory();
        });
        this.deposit = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.depositController.deposit(params);
        });
        this.requestDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.requestDepositRightsController.requestDepositRights(params);
        });
        this.rescindDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_rescindDepositRights, {
                multisigAddress: this.multisigAddress,
                tokenAddress: params.assetId,
            });
        });
        this.checkDepositRights = (params) => __awaiter(this, void 0, void 0, function* () {
            const refundApp = yield this.getBalanceRefundApp(params.assetId);
            const multisigBalance = !refundApp.latestState["tokenAddress"] &&
                refundApp.latestState["tokenAddress"] !== constants_1.AddressZero
                ? yield this.ethProvider.getBalance(this.multisigAddress)
                : yield new ethers_1.Contract(refundApp.latestState["tokenAddress"], human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.multisigAddress);
            return refundApp
                ? {
                    assetId: refundApp.latestState["tokenAddress"],
                    multisigBalance: multisigBalance.toString(),
                    recipient: refundApp.latestState["recipient"],
                    threshold: refundApp.latestState["threshold"],
                }
                : undefined;
        });
        this.swap = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.swapController.swap(params);
        });
        this.transfer = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.conditionalTransferController.conditionalTransfer({
                amount: params.amount,
                assetId: params.assetId,
                conditionType: "LINKED_TRANSFER_TO_RECIPIENT",
                meta: params.meta,
                paymentId: utils_1.hexlify(utils_1.randomBytes(32)),
                preImage: utils_1.hexlify(utils_1.randomBytes(32)),
                recipient: params.recipient,
            });
        });
        this.withdraw = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.withdrawalController.withdraw(params);
        });
        this.resolveCondition = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.resolveConditionController.resolve(params);
        });
        this.conditionalTransfer = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.conditionalTransferController.conditionalTransfer(params);
        });
        this.getLatestNodeSubmittedWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const path = lib_1.withdrawalKey(this.publicIdentifier);
            const value = yield this.channelProvider.send("chan_storeGet", { path });
            if (!value || value === "undefined") {
                return undefined;
            }
            const noRetry = value.retry === undefined || value.retry === null;
            if (!value.tx || noRetry) {
                const msg = `Can not find tx or retry in store under key ${lib_1.withdrawalKey(this.publicIdentifier)}`;
                this.log.error(msg);
                throw new Error(msg);
            }
            return value;
        });
        this.watchForUserWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const maxBlocks = 15;
            const startingBlock = yield this.ethProvider.getBlockNumber();
            try {
                yield new Promise((resolve, reject) => {
                    this.ethProvider.on("block", (blockNumber) => __awaiter(this, void 0, void 0, function* () {
                        const found = yield this.checkForUserWithdrawal(blockNumber);
                        if (found) {
                            yield this.channelProvider.send("chan_storeSet", {
                                pairs: [{ path: lib_1.withdrawalKey(this.publicIdentifier), value: undefined }],
                            });
                            this.ethProvider.removeAllListeners("block");
                            resolve();
                        }
                        if (blockNumber - startingBlock >= maxBlocks) {
                            this.ethProvider.removeAllListeners("block");
                            reject(`More than ${maxBlocks} have passed: ${blockNumber - startingBlock}`);
                        }
                    }));
                });
            }
            catch (e) {
                if (e.includes(`More than ${maxBlocks} have passed`)) {
                    this.log.debug(`Retrying node submission`);
                    yield this.retryNodeSubmittedWithdrawal();
                }
            }
        });
        this.restoreState = () => __awaiter(this, void 0, void 0, function* () {
            const path = `${types_2.ConnextClientStorePrefix}/${this.publicIdentifier}/channel/${this.multisigAddress}`;
            let state;
            try {
                state = yield this.channelProvider.send("chan_restoreState", { path });
                this.log.info(`Found state to restore from store's backup: ${lib_1.stringify(state.path)}`);
            }
            catch (e) {
                state = yield this.node.restoreState(this.publicIdentifier);
                if (!state) {
                    throw new Error(`No matching states found by node for ${this.publicIdentifier}`);
                }
                this.log.info(`Found state to restore from node: ${lib_1.stringify(state)}`);
            }
            yield this.channelProvider.send("chan_storeSet", {
                pairs: [{ path, value: state }],
            });
            yield this.restart();
        });
        this.on = (event, callback) => {
            return this.listener.on(event, callback);
        };
        this.once = (event, callback) => {
            return this.listener.once(event, callback);
        };
        this.emit = (event, data) => {
            return this.listener.emit(event, data);
        };
        this.deployMultisig = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send("chan_deployStateDepositHolder", {
                multisigAddress: this.multisigAddress,
            });
        });
        this.getStateChannel = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getStateChannel, {
                multisigAddress: this.multisigAddress,
            });
        });
        this.providerDeposit = (amount, assetId, notifyCounterparty = false) => __awaiter(this, void 0, void 0, function* () {
            const depositAddr = lib_1.xpubToAddress(this.publicIdentifier);
            let bal;
            if (assetId === constants_1.AddressZero) {
                bal = yield this.ethProvider.getBalance(depositAddr);
            }
            else {
                const token = new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider);
                bal = yield token.balanceOf(depositAddr);
            }
            const err = [
                bn_1.notPositive(amount),
                addresses_1.invalidAddress(assetId),
                bn_1.notLessThanOrEqualTo(amount, bal),
            ].filter(bn_1.falsy)[0];
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_deposit, {
                amount,
                multisigAddress: this.multisigAddress,
                notifyCounterparty,
                tokenAddress: types_2.makeChecksum(assetId),
            });
        });
        this.getAppInstances = (multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            const { appInstances } = yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getAppInstances, {
                multisigAddress,
            });
            return appInstances;
        });
        this.getFreeBalance = (assetId = constants_1.AddressZero) => __awaiter(this, void 0, void 0, function* () {
            if (typeof assetId !== "string") {
                throw new Error(`Asset id must be a string: ${lib_1.stringify(assetId)}`);
            }
            const normalizedAssetId = types_2.makeChecksum(assetId);
            try {
                return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getFreeBalanceState, {
                    multisigAddress: this.multisigAddress,
                    tokenAddress: types_2.makeChecksum(assetId),
                });
            }
            catch (e) {
                const error = `No free balance exists for the specified token: ${normalizedAssetId}`;
                if (e.message.includes(error)) {
                    const obj = {};
                    obj[lib_1.xpubToAddress(this.nodePublicIdentifier)] = new utils_1.BigNumber(0);
                    obj[this.freeBalanceAddress] = new utils_1.BigNumber(0);
                    return obj;
                }
                throw e;
            }
        });
        this.getProposedAppInstances = (multisigAddress) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getProposedAppInstances, {
                multisigAddress,
            });
        });
        this.getProposedAppInstance = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getProposedAppInstances, {
                appInstanceId,
            });
        });
        this.getAppInstanceDetails = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.warn(err);
                return undefined;
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getAppInstance, {
                appInstanceId,
            });
        });
        this.getAppState = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.warn(err);
                return undefined;
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_getState, {
                appInstanceId,
            });
        });
        this.takeAction = (appInstanceId, action) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            const state = yield this.getAppState(appInstanceId);
            if (state.state.finalized) {
                throw new Error("Cannot take action on an app with a finalized state.");
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_takeAction, {
                action,
                appInstanceId,
            });
        });
        this.updateState = (appInstanceId, newState) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            const state = yield this.getAppState(appInstanceId);
            if (state.state.finalized) {
                throw new Error("Cannot take action on an app with a finalized state.");
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_updateState, {
                appInstanceId,
                newState,
            });
        });
        this.proposeInstallApp = (params) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_proposeInstall, params);
        });
        this.installVirtualApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const alreadyInstalled = yield this.appInstalled(appInstanceId);
            if (alreadyInstalled) {
                throw new Error(alreadyInstalled);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_installVirtual, {
                appInstanceId,
                intermediaryIdentifier: this.nodePublicIdentifier,
            });
        });
        this.installApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const alreadyInstalled = yield this.appInstalled(appInstanceId);
            if (alreadyInstalled) {
                throw new Error(alreadyInstalled);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_install, {
                appInstanceId,
            });
        });
        this.uninstallApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_uninstall, {
                appInstanceId,
            });
        });
        this.uninstallVirtualApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const err = yield this.appNotInstalled(appInstanceId);
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_uninstallVirtual, {
                appInstanceId,
                intermediaryIdentifier: this.nodePublicIdentifier,
            });
        });
        this.rejectInstallApp = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_rejectInstall, {
                appInstanceId,
            });
        });
        this.providerWithdraw = (assetId, amount, recipient) => __awaiter(this, void 0, void 0, function* () {
            const freeBalance = yield this.getFreeBalance(assetId);
            const preWithdrawalBal = freeBalance[this.freeBalanceAddress];
            const err = [
                bn_1.notLessThanOrEqualTo(amount, preWithdrawalBal),
                assetId ? addresses_1.invalidAddress(assetId) : null,
                recipient ? addresses_1.invalidAddress(recipient) : null,
            ].filter(bn_1.falsy)[0];
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_withdraw, {
                amount,
                multisigAddress: this.multisigAddress,
                recipient,
                tokenAddress: types_2.makeChecksum(assetId),
            });
        });
        this.withdrawCommitment = (amount, assetId, recipient) => __awaiter(this, void 0, void 0, function* () {
            const freeBalance = yield this.getFreeBalance(assetId);
            const preWithdrawalBal = freeBalance[this.freeBalanceAddress];
            const err = [
                bn_1.notLessThanOrEqualTo(amount, preWithdrawalBal),
                assetId ? addresses_1.invalidAddress(assetId) : null,
                recipient ? addresses_1.invalidAddress(recipient) : null,
            ].filter(bn_1.falsy)[0];
            if (err) {
                this.log.error(err);
                throw new Error(err);
            }
            return yield this.channelProvider.send(types_2.CFCoreTypes.RpcMethodNames.chan_withdrawCommitment, {
                amount,
                multisigAddress: this.multisigAddress,
                recipient,
                tokenAddress: types_2.makeChecksumOrEthAddress(assetId),
            });
        });
        this.clientCheckIn = () => __awaiter(this, void 0, void 0, function* () {
            return yield this.node.clientCheckIn();
        });
        this.verifyAppSequenceNumber = () => __awaiter(this, void 0, void 0, function* () {
            const { data: sc } = yield this.channelProvider.send("chan_getStateChannel", {
                multisigAddress: this.multisigAddress,
            });
            let appSequenceNumber;
            try {
                appSequenceNumber = (yield sc.mostRecentlyInstalledAppInstance()).appSeqNo;
            }
            catch (e) {
                if (e.message.includes("There are no installed AppInstances in this StateChannel")) {
                    appSequenceNumber = 0;
                }
                else {
                    throw e;
                }
            }
            return yield this.node.verifyAppSequenceNumber(appSequenceNumber);
        });
        this.reclaimPendingAsyncTransfers = () => __awaiter(this, void 0, void 0, function* () {
            const pendingTransfers = yield this.node.getPendingAsyncTransfers();
            for (const transfer of pendingTransfers) {
                const { encryptedPreImage, paymentId, amount, assetId } = transfer;
                yield this.reclaimPendingAsyncTransfer(amount, assetId, paymentId, encryptedPreImage);
            }
        });
        this.reclaimPendingAsyncTransfer = (amount, assetId, paymentId, encryptedPreImage) => __awaiter(this, void 0, void 0, function* () {
            this.log.info(`Reclaiming transfer ${paymentId}`);
            let privateKey;
            if (this.opts.mnemonic) {
                privateKey = hdnode_1.fromMnemonic(this.opts.mnemonic)
                    .derivePath(types_1.CF_PATH)
                    .derivePath("0").privateKey;
            }
            else if (this.keyGen) {
                privateKey = yield this.keyGen("0");
            }
            else {
                throw new Error(`No way to decode transfer, this should never happen!`);
            }
            const preImage = yield crypto_1.decryptWithPrivateKey(privateKey, encryptedPreImage);
            this.log.debug(`Decrypted message and recovered preImage: ${preImage}`);
            const response = yield this.resolveCondition({
                amount,
                assetId,
                conditionType: "LINKED_TRANSFER_TO_RECIPIENT",
                paymentId,
                preImage,
            });
            this.log.info(`Redeemed transfer ${lib_1.stringify(response)}`);
            return response;
        });
        this.getRegisteredAppDetails = (appName) => {
            const appInfo = this.appRegistry.filter((app) => {
                return app.name === appName && app.network === this.network.name;
            });
            if (!appInfo || appInfo.length === 0) {
                throw new Error(`Could not find ${appName} app details on ${this.network.name} network`);
            }
            if (appInfo.length > 1) {
                throw new Error(`Found multiple ${appName} app details on ${this.network.name} network`);
            }
            return appInfo[0];
        };
        this.matchTx = (givenTransaction, expected) => {
            return (givenTransaction &&
                givenTransaction.to === expected.to &&
                utils_1.bigNumberify(givenTransaction.value).eq(expected.value) &&
                givenTransaction.data === expected.data);
        };
        this.cleanupRegistryApps = () => __awaiter(this, void 0, void 0, function* () {
            const swapAppRegistryInfo = this.appRegistry.filter((app) => app.name === "SimpleTwoPartySwapApp")[0];
            const linkedRegistryInfo = this.appRegistry.filter((app) => app.name === "SimpleLinkedTransferApp")[0];
            yield this.removeHangingProposalsByDefinition([
                swapAppRegistryInfo.appDefinitionAddress,
                linkedRegistryInfo.appDefinitionAddress,
            ]);
            yield this.uninstallAllAppsByDefintion([swapAppRegistryInfo.appDefinitionAddress]);
        });
        this.removeHangingProposalsByDefinition = (appDefinitions) => __awaiter(this, void 0, void 0, function* () {
            const { appInstances: proposed } = yield this.getProposedAppInstances();
            const hangingProposals = proposed.filter((proposal) => appDefinitions.includes(proposal.appDefinition));
            for (const hanging of hangingProposals) {
                yield this.rejectInstallApp(hanging.identityHash);
            }
        });
        this.uninstallAllAppsByDefintion = (appDefinitions) => __awaiter(this, void 0, void 0, function* () {
            const apps = (yield this.getAppInstances()).filter((app) => appDefinitions.includes(app.appInterface.addr));
            for (const app of apps) {
                yield this.uninstallApp(app.identityHash);
            }
        });
        this.uninstallCoinBalanceIfNeeded = (assetId = constants_1.AddressZero) => __awaiter(this, void 0, void 0, function* () {
            const coinRefund = yield this.getBalanceRefundApp(assetId);
            if (!coinRefund) {
                this.log.debug("No coin balance refund app found");
                return undefined;
            }
            const latestState = coinRefund.latestState;
            const threshold = utils_1.bigNumberify(latestState["threshold"]);
            const isTokenDeposit = latestState["tokenAddress"] && latestState["tokenAddress"] !== constants_1.AddressZero;
            const isClientDeposit = latestState["recipient"] === this.freeBalanceAddress;
            const multisigBalance = !isTokenDeposit
                ? yield this.ethProvider.getBalance(this.multisigAddress)
                : yield new ethers_1.Contract(latestState["tokenAddress"], human_standard_token_abi_1.default, this.ethProvider).functions.balanceOf(this.multisigAddress);
            if (multisigBalance.lt(threshold)) {
                throw new Error(`Something is wrong! multisig balance is less than the threshold of the installed coin balance refund app.`);
            }
            const uninstallRefund = () => __awaiter(this, void 0, void 0, function* () {
                this.log.debug("Deposit has been executed, uninstalling refund app");
                yield this.uninstallApp(coinRefund.identityHash);
                this.log.debug("Successfully uninstalled");
            });
            if (multisigBalance.eq(threshold)) {
                this.log.warn(`Coin balance refund app found installed, but no deposit successfully executed. Leaving app installed and waiting for deposit of ${latestState["tokenAddress"]} from ${isClientDeposit ? `client` : `node`}`);
                if (isClientDeposit) {
                    if (isTokenDeposit) {
                        new ethers_1.Contract(assetId, human_standard_token_abi_1.default, this.ethProvider).once("Transfer", (sender, recipient, amount) => __awaiter(this, void 0, void 0, function* () {
                            if (recipient === this.multisigAddress && amount.gt(0)) {
                                this.log.info(`Multisig transfer was for our channel, uninstalling refund app`);
                                yield uninstallRefund();
                            }
                        }));
                    }
                    else {
                        this.ethProvider.once(this.multisigAddress, () => __awaiter(this, void 0, void 0, function* () { return yield uninstallRefund(); }));
                    }
                }
                return;
            }
            yield uninstallRefund();
        });
        this.resubmitActiveWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const path = lib_1.withdrawalKey(this.publicIdentifier);
            const withdrawal = yield this.channelProvider.send("chan_storeGet", { path });
            if (!withdrawal || withdrawal === "undefined") {
                return;
            }
            if (withdrawal.retry >= MAX_WITHDRAWAL_RETRIES) {
                const msg = `Cannot connect client, hub failed to submit latest withdrawal ${MAX_WITHDRAWAL_RETRIES} times.`;
                this.log.error(msg);
                throw new Error(msg);
            }
            const tx = yield this.node.getLatestWithdrawal();
            if (this.matchTx(tx, withdrawal.tx)) {
                yield this.channelProvider.send("chan_storeSet", {
                    pairs: [
                        {
                            path: lib_1.withdrawalKey(this.publicIdentifier),
                            value: undefined,
                        },
                    ],
                });
                return;
            }
            this.log.debug(`Found active withdrawal with ${withdrawal.retry} retries, waiting for withdrawal to be caught`);
            yield this.retryNodeSubmittedWithdrawal();
        });
        this.retryNodeSubmittedWithdrawal = () => __awaiter(this, void 0, void 0, function* () {
            const val = yield this.getLatestNodeSubmittedWithdrawal();
            if (!val) {
                this.log.error(`No transaction found to retry`);
                return;
            }
            let { retry } = val;
            const { tx } = val;
            retry += 1;
            yield this.channelProvider.send("chan_storeSet", {
                pairs: [
                    {
                        path: lib_1.withdrawalKey(this.publicIdentifier),
                        value: { tx, retry },
                    },
                ],
            });
            if (retry >= MAX_WITHDRAWAL_RETRIES) {
                const msg = `Tried to have node submit withdrawal ${MAX_WITHDRAWAL_RETRIES} times and it did not work, try submitting from wallet.`;
                this.log.error(msg);
                throw new Error(msg);
            }
            yield this.node.withdraw(tx);
            yield this.watchForUserWithdrawal();
        });
        this.appNotInstalled = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const apps = yield this.getAppInstances(this.multisigAddress);
            const app = apps.filter((app) => app.identityHash === appInstanceId);
            if (!app || app.length === 0) {
                return (`Could not find installed app with id: ${appInstanceId}. ` +
                    `Installed apps: ${lib_1.stringify(apps)}.`);
            }
            if (app.length > 1) {
                return (`CRITICAL ERROR: found multiple apps with the same id. ` +
                    `Installed apps: ${lib_1.stringify(apps)}.`);
            }
            return undefined;
        });
        this.appInstalled = (appInstanceId) => __awaiter(this, void 0, void 0, function* () {
            const apps = yield this.getAppInstances(this.multisigAddress);
            const app = apps.filter((app) => app.identityHash === appInstanceId);
            if (app.length > 0) {
                return (`App with id ${appInstanceId} is already installed. ` +
                    `Installed apps: ${lib_1.stringify(apps)}.`);
            }
            return undefined;
        });
        this.checkForUserWithdrawal = (inBlock) => __awaiter(this, void 0, void 0, function* () {
            const val = yield this.getLatestNodeSubmittedWithdrawal();
            if (!val) {
                this.log.error(`No transaction found in store.`);
                return false;
            }
            const { tx } = val;
            const txsTo = yield this.ethProvider.getTransactionCount(tx.to, inBlock);
            if (txsTo === 0) {
                return false;
            }
            const block = yield this.ethProvider.getBlock(inBlock);
            const { transactions } = block;
            if (transactions.length === 0) {
                return false;
            }
            for (const transactionHash of transactions) {
                const transaction = yield this.ethProvider.getTransaction(transactionHash);
                if (this.matchTx(transaction, tx)) {
                    return true;
                }
            }
            return false;
        });
        this.opts = opts;
        this.appRegistry = opts.appRegistry;
        this.channelProvider = opts.channelProvider;
        this.config = opts.config;
        this.ethProvider = opts.ethProvider;
        this.keyGen = opts.keyGen;
        this.messaging = opts.messaging;
        this.network = opts.network;
        this.node = opts.node;
        this.token = opts.token;
        this.store = opts.store;
        this.freeBalanceAddress = this.channelProvider.config.freeBalanceAddress;
        this.signerAddress = this.channelProvider.config.signerAddress;
        this.publicIdentifier = this.channelProvider.config.userPublicIdentifier;
        this.multisigAddress = this.channelProvider.config.multisigAddress;
        this.nodePublicIdentifier = this.opts.config.nodePublicIdentifier;
        this.log = new lib_1.Logger("ConnextClient", opts.logLevel);
        this.listener = new listener_1.ConnextListener(opts.channelProvider, this);
        this.depositController = new DepositController_1.DepositController("DepositController", this);
        this.swapController = new SwapController_1.SwapController("SwapController", this);
        this.withdrawalController = new WithdrawalController_1.WithdrawalController("WithdrawalController", this);
        this.resolveConditionController = new ResolveConditionController_1.ResolveConditionController("ResolveConditionController", this);
        this.conditionalTransferController = new ConditionalTransferController_1.ConditionalTransferController("ConditionalTransferController", this);
        this.requestDepositRightsController = new RequestDepositRightsController_1.RequestDepositRightsController("RequestDepositRightsController", this);
    }
}
exports.ConnextClient = ConnextClient;
//# sourceMappingURL=connext.js.map