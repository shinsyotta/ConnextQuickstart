"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("ethers/constants");
const utils_1 = require("ethers/utils");
const bignumber_jest_matcher_1 = require("../machine/integration/bignumber-jest-matcher");
const connext_utils_1 = require("./connext-utils");
const linked_transfer_1 = require("./linked-transfer");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
jest.setTimeout(10000);
expect.extend({ toBeEq: bignumber_jest_matcher_1.toBeEq });
function generateInitialLinkedTransferStates(sender, intermediary, redeemer, numberApps = 3) {
    const linkStatesSender = [];
    const linkStatesRedeemer = [];
    for (let i = 0; i < numberApps; i += 1) {
        const { action, state } = linked_transfer_1.initialLinkedState(intermediary.freeBalanceAddress, redeemer.freeBalanceAddress);
        linkStatesRedeemer.push({ action, state });
        const hubTransfers = [
            {
                to: sender.freeBalanceAddress,
                amount: action.amount
            },
            {
                to: intermediary.freeBalanceAddress,
                amount: constants_1.Zero
            }
        ];
        linkStatesSender.push({
            action,
            state: Object.assign({}, state, { transfers: hubTransfers })
        });
    }
    return {
        linkStatesRedeemer,
        linkStatesSender
    };
}
async function installLinks(funder, redeemer, statesAndActions) {
    const appIds = [];
    for (const { state, action } of statesAndActions) {
        appIds.push(await connext_utils_1.installLink(funder, redeemer, state, action));
    }
    return appIds;
}
function redeemLinkPoller(funder, intermediary, redeemer, statesAndActions, done) {
    setTimeout(async () => {
        while (statesAndActions.length > 0) {
            await connext_utils_1.installAndRedeemLink(funder, intermediary, redeemer, statesAndActions.pop());
        }
        done();
    }, 200);
}
describe("Can update and install multiple apps simultaneously", () => {
    let nodeA;
    let nodeB;
    let nodeC;
    let multisigAddressAB;
    let multisigAddressBC;
    beforeEach(async () => {
        const context = await setup_1.setup(global, true);
        nodeA = context["A"].node;
        nodeB = context["B"].node;
        nodeC = context["C"].node;
        multisigAddressAB = await utils_2.createChannel(nodeA, nodeB);
        multisigAddressBC = await utils_2.createChannel(nodeB, nodeC);
        await utils_2.deposit(nodeA, multisigAddressAB, utils_1.bigNumberify(15), nodeB);
        await utils_2.deposit(nodeB, multisigAddressBC, utils_1.bigNumberify(15), nodeC);
    });
    it("should be able to redeem a pregenerated linked payment while simultaneously receiving a direct transfer", async (done) => {
        const { linkStatesRedeemer, linkStatesSender } = generateInitialLinkedTransferStates(nodeA, nodeB, nodeC, 2);
        await installLinks(nodeA, nodeB, linkStatesSender);
        redeemLinkPoller(nodeA, nodeB, nodeC, linkStatesRedeemer, done);
        for (const i of Array(2)) {
            await connext_utils_1.makeSimpleTransfer(nodeA, nodeB, nodeC);
        }
    });
});
//# sourceMappingURL=connext-issue.spec.js.map