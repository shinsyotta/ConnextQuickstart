"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@connext/types");
const ethers_1 = require("ethers");
const providers_1 = require("ethers/providers");
const utils_1 = require("ethers/utils");
const hdnode_1 = require("ethers/utils/hdnode");
const uuid_1 = require("uuid");
const src_1 = require("../../src");
const xkeys_1 = require("../../src/machine/xkeys");
const memory_lock_service_1 = __importDefault(require("../services/memory-lock-service"));
const memory_messaging_service_1 = require("../services/memory-messaging-service");
const memory_store_service_1 = require("../services/memory-store-service");
const test_constants_jest_1 = require("../test-constants.jest");
async function setupWithMemoryMessagingAndSlowStore(global, nodeCPresent = false, newExtendedPrvKeys = false) {
    const storeDelay = 2;
    return setup(global, nodeCPresent, newExtendedPrvKeys, new memory_messaging_service_1.MemoryMessagingService(), new memory_store_service_1.MemoryStoreServiceFactory(storeDelay));
}
exports.setupWithMemoryMessagingAndSlowStore = setupWithMemoryMessagingAndSlowStore;
async function setup(global, nodeCPresent = false, newExtendedPrvKey = false, messagingService = new memory_messaging_service_1.MemoryMessagingService(), storeServiceFactory = new memory_store_service_1.MemoryStoreServiceFactory()) {
    const setupContext = {};
    const nodeConfig = { STORE_KEY_PREFIX: "test" };
    const provider = new providers_1.JsonRpcProvider(global["ganacheURL"]);
    const extendedPrvKeyA = test_constants_jest_1.A_EXTENDED_PRIVATE_KEY;
    let extendedPrvKeyB = test_constants_jest_1.B_EXTENDED_PRIVATE_KEY;
    if (newExtendedPrvKey) {
        const newExtendedPrvKeys = await generateNewFundedExtendedPrvKeys(global["fundedPrivateKey"], provider);
        extendedPrvKeyB = newExtendedPrvKeys.B_EXTENDED_PRV_KEY;
    }
    const lockService = new memory_lock_service_1.default();
    const hdNodeA = hdnode_1.fromExtendedKey(extendedPrvKeyA).derivePath(types_1.CF_PATH);
    const storeServiceA = storeServiceFactory.createStoreService(`test_${uuid_1.v4()}`);
    const nodeA = await src_1.Node.create(messagingService, storeServiceA, global["networkContext"], nodeConfig, provider, lockService, hdNodeA.neuter().extendedKey, (index) => Promise.resolve(hdNodeA.derivePath(index).privateKey));
    setupContext["A"] = {
        node: nodeA,
        store: storeServiceA,
    };
    const hdNodeB = hdnode_1.fromExtendedKey(extendedPrvKeyB).derivePath(types_1.CF_PATH);
    const storeServiceB = storeServiceFactory.createStoreService(`test_${uuid_1.v4()}`);
    const nodeB = await src_1.Node.create(messagingService, storeServiceB, global["networkContext"], nodeConfig, provider, lockService, hdNodeB.neuter().extendedKey, (index) => Promise.resolve(hdNodeB.derivePath(index).privateKey));
    setupContext["B"] = {
        node: nodeB,
        store: storeServiceB,
    };
    let nodeC;
    if (nodeCPresent) {
        const hdNodeC = hdnode_1.fromExtendedKey(test_constants_jest_1.C_EXTENDED_PRIVATE_KEY).derivePath(types_1.CF_PATH);
        const storeServiceC = storeServiceFactory.createStoreService(`test_${uuid_1.v4()}`);
        nodeC = await src_1.Node.create(messagingService, storeServiceC, global["networkContext"], nodeConfig, provider, lockService, hdNodeC.neuter().extendedKey, (index) => Promise.resolve(hdNodeC.derivePath(index).privateKey));
        setupContext["C"] = {
            node: nodeC,
            store: storeServiceC,
        };
    }
    return setupContext;
}
exports.setup = setup;
async function generateNewFundedWallet(fundedPrivateKey, provider) {
    const fundedWallet = new ethers_1.Wallet(fundedPrivateKey, provider);
    const wallet = ethers_1.Wallet.createRandom().connect(provider);
    const transactionToA = {
        to: wallet.address,
        value: utils_1.parseEther("20").toHexString(),
    };
    await fundedWallet.sendTransaction(transactionToA);
    return wallet;
}
exports.generateNewFundedWallet = generateNewFundedWallet;
async function generateNewFundedExtendedPrvKeys(fundedPrivateKey, provider) {
    const fundedWallet = new ethers_1.Wallet(fundedPrivateKey, provider);
    const A_EXTENDED_PRV_KEY = xkeys_1.computeRandomExtendedPrvKey();
    const B_EXTENDED_PRV_KEY = xkeys_1.computeRandomExtendedPrvKey();
    const signerAPrivateKey = hdnode_1.fromExtendedKey(A_EXTENDED_PRV_KEY).derivePath(types_1.CF_PATH).privateKey;
    const signerBPrivateKey = hdnode_1.fromExtendedKey(B_EXTENDED_PRV_KEY).derivePath(types_1.CF_PATH).privateKey;
    const signerAAddress = new ethers_1.Wallet(signerAPrivateKey).address;
    const signerBAddress = new ethers_1.Wallet(signerBPrivateKey).address;
    const transactionToA = {
        to: signerAAddress,
        value: utils_1.parseEther("1").toHexString(),
    };
    const transactionToB = {
        to: signerBAddress,
        value: utils_1.parseEther("1").toHexString(),
    };
    await fundedWallet.sendTransaction(transactionToA);
    await fundedWallet.sendTransaction(transactionToB);
    return {
        A_EXTENDED_PRV_KEY,
        B_EXTENDED_PRV_KEY,
    };
}
exports.generateNewFundedExtendedPrvKeys = generateNewFundedExtendedPrvKeys;
//# sourceMappingURL=setup.js.map