"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const machine_1 = require("../../../machine");
const errors_1 = require("../../errors");
async function install(store, protocolRunner, params, initiatorXpub) {
    const { appInstanceId } = params;
    if (!appInstanceId || !appInstanceId.trim()) {
        throw Error(errors_1.NO_APP_INSTANCE_ID_TO_INSTALL);
    }
    const proposal = await store.getAppInstanceProposal(appInstanceId);
    const stateChannel = await store.getChannelFromAppInstanceID(appInstanceId);
    await protocolRunner.initiateProtocol(machine_1.Protocol.Install, new Map([
        [stateChannel.multisigAddress, stateChannel]
    ]), {
        initiatorXpub,
        responderXpub: initiatorXpub === proposal.proposedToIdentifier
            ? proposal.proposedByIdentifier
            : proposal.proposedToIdentifier,
        initiatorBalanceDecrement: utils_1.bigNumberify(proposal.initiatorDeposit),
        responderBalanceDecrement: utils_1.bigNumberify(proposal.responderDeposit),
        multisigAddress: stateChannel.multisigAddress,
        participants: stateChannel.getSigningKeysFor(proposal.appSeqNo),
        initialState: proposal.initialState,
        appInterface: Object.assign({}, proposal.abiEncodings, { addr: proposal.appDefinition }),
        appSeqNo: proposal.appSeqNo,
        defaultTimeout: utils_1.bigNumberify(proposal.timeout).toNumber(),
        outcomeType: proposal.outcomeType,
        initiatorDepositTokenAddress: proposal.initiatorDepositTokenAddress,
        responderDepositTokenAddress: proposal.responderDepositTokenAddress,
        disableLimit: false
    });
    await store.saveStateChannel((await store.getChannelFromAppInstanceID(appInstanceId)).removeProposal(appInstanceId));
    return proposal;
}
exports.install = install;
//# sourceMappingURL=operation.js.map